// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
)

// ConfigServerInheritance ServerInheritance
//
// Inheritance configuration specifies how and which fields _Server_ object inherits from _Global_ parent.
//
// swagger:model configServerInheritance
type ConfigServerInheritance struct {

	// Optional. Field config for _custom_root_ns_block_ field from _Server_ object.
	CustomRootNsBlock *ConfigInheritedCustomRootNSBlock `json:"custom_root_ns_block,omitempty"`

	// Optional. Field config for _dnssec_validation_block_ field from _Server_ object.
	DnssecValidationBlock *ConfigInheritedDNSSECValidationBlock `json:"dnssec_validation_block,omitempty"`

	// Optional. Field config for _ecs_block_ field from _Server_ object.
	EcsBlock *ConfigInheritedECSBlock `json:"ecs_block,omitempty"`

	// Optional. Field config for _forwarders_block_ field from _Server_ object.
	ForwardersBlock *ConfigInheritedForwardersBlock `json:"forwarders_block,omitempty"`

	// Optional. Field config for _gss_tsig_enabled_ field from _Server_ object.
	GssTsigEnabled *Inheritance2InheritedBool `json:"gss_tsig_enabled,omitempty"`

	// Optional. Field config for _kerberos_keys_ field from _Server_ object.
	KerberosKeys *ConfigInheritedKerberosKeys `json:"kerberos_keys,omitempty"`

	// Optional. Field config for _lame_ttl_ field from _Server_ object.
	LameTTL *Inheritance2InheritedUInt32 `json:"lame_ttl,omitempty"`

	// Optional. Field config for _log_queries_response_ field from _Server_ object.
	LogQueryResponse *Inheritance2InheritedBool `json:"log_query_response,omitempty"`

	// Optional. Field config for _match_recursive_only_ field from _Server_ object.
	MatchRecursiveOnly *Inheritance2InheritedBool `json:"match_recursive_only,omitempty"`

	// Optional. Field config for _max_cache_ttl_ field from _Server_ object.
	MaxCacheTTL *Inheritance2InheritedUInt32 `json:"max_cache_ttl,omitempty"`

	// Optional. Field config for _max_negative_ttl_ field from _Server_ object.
	MaxNegativeTTL *Inheritance2InheritedUInt32 `json:"max_negative_ttl,omitempty"`

	// Optional. Field config for _minimal_responses_ field from _Server_ object.
	MinimalResponses *Inheritance2InheritedBool `json:"minimal_responses,omitempty"`

	// Field config for _notify_ field from _Server_ object.
	Notify *Inheritance2InheritedBool `json:"notify,omitempty"`

	// Optional. Field config for _query_acl_ field from _Server_ object.
	QueryACL *ConfigInheritedACLItems `json:"query_acl,omitempty"`

	// Optional. Field config for _query_port_ field from _Server_ object.
	QueryPort *Inheritance2InheritedUInt32 `json:"query_port,omitempty"`

	// Optional. Field config for _recursion_acl_ field from _Server_ object.
	RecursionACL *ConfigInheritedACLItems `json:"recursion_acl,omitempty"`

	// Optional. Field config for _recursion_enabled_ field from _Server_ object.
	RecursionEnabled *Inheritance2InheritedBool `json:"recursion_enabled,omitempty"`

	// Optional. Field config for _recursive_clients_ field from _Server_ object.
	RecursiveClients *Inheritance2InheritedUInt32 `json:"recursive_clients,omitempty"`

	// Optional. Field config for _resolver_query_timeout_ field from _Server_ object.
	ResolverQueryTimeout *Inheritance2InheritedUInt32 `json:"resolver_query_timeout,omitempty"`

	// Optional. Field config for _secondary_axfr_query_limit_ field from _Server_ object.
	SecondaryAxfrQueryLimit *Inheritance2InheritedUInt32 `json:"secondary_axfr_query_limit,omitempty"`

	// Optional. Field config for _secondary_soa_query_limit_ field from _Server_ object.
	SecondarySoaQueryLimit *Inheritance2InheritedUInt32 `json:"secondary_soa_query_limit,omitempty"`

	// Optional. Field config for _transfer_acl_ field from _Server_ object.
	TransferACL *ConfigInheritedACLItems `json:"transfer_acl,omitempty"`

	// Optional. Field config for _update_acl_ field from _Server_ object.
	UpdateACL *ConfigInheritedACLItems `json:"update_acl,omitempty"`

	// Optional. Field config for _use_forwarders_for_subzones_ field from _Server_ object.
	UseForwardersForSubzones *Inheritance2InheritedBool `json:"use_forwarders_for_subzones,omitempty"`
}

// Validate validates this config server inheritance
func (m *ConfigServerInheritance) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCustomRootNsBlock(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDnssecValidationBlock(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEcsBlock(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateForwardersBlock(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateGssTsigEnabled(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateKerberosKeys(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLameTTL(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLogQueryResponse(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMatchRecursiveOnly(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMaxCacheTTL(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMaxNegativeTTL(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMinimalResponses(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNotify(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateQueryACL(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateQueryPort(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRecursionACL(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRecursionEnabled(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRecursiveClients(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateResolverQueryTimeout(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSecondaryAxfrQueryLimit(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSecondarySoaQueryLimit(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTransferACL(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUpdateACL(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUseForwardersForSubzones(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ConfigServerInheritance) validateCustomRootNsBlock(formats strfmt.Registry) error {
	if swag.IsZero(m.CustomRootNsBlock) { // not required
		return nil
	}

	if m.CustomRootNsBlock != nil {
		if err := m.CustomRootNsBlock.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("custom_root_ns_block")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("custom_root_ns_block")
			}
			return err
		}
	}

	return nil
}

func (m *ConfigServerInheritance) validateDnssecValidationBlock(formats strfmt.Registry) error {
	if swag.IsZero(m.DnssecValidationBlock) { // not required
		return nil
	}

	if m.DnssecValidationBlock != nil {
		if err := m.DnssecValidationBlock.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("dnssec_validation_block")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("dnssec_validation_block")
			}
			return err
		}
	}

	return nil
}

func (m *ConfigServerInheritance) validateEcsBlock(formats strfmt.Registry) error {
	if swag.IsZero(m.EcsBlock) { // not required
		return nil
	}

	if m.EcsBlock != nil {
		if err := m.EcsBlock.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ecs_block")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("ecs_block")
			}
			return err
		}
	}

	return nil
}

func (m *ConfigServerInheritance) validateForwardersBlock(formats strfmt.Registry) error {
	if swag.IsZero(m.ForwardersBlock) { // not required
		return nil
	}

	if m.ForwardersBlock != nil {
		if err := m.ForwardersBlock.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("forwarders_block")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("forwarders_block")
			}
			return err
		}
	}

	return nil
}

func (m *ConfigServerInheritance) validateGssTsigEnabled(formats strfmt.Registry) error {
	if swag.IsZero(m.GssTsigEnabled) { // not required
		return nil
	}

	if m.GssTsigEnabled != nil {
		if err := m.GssTsigEnabled.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("gss_tsig_enabled")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("gss_tsig_enabled")
			}
			return err
		}
	}

	return nil
}

func (m *ConfigServerInheritance) validateKerberosKeys(formats strfmt.Registry) error {
	if swag.IsZero(m.KerberosKeys) { // not required
		return nil
	}

	if m.KerberosKeys != nil {
		if err := m.KerberosKeys.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("kerberos_keys")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("kerberos_keys")
			}
			return err
		}
	}

	return nil
}

func (m *ConfigServerInheritance) validateLameTTL(formats strfmt.Registry) error {
	if swag.IsZero(m.LameTTL) { // not required
		return nil
	}

	if m.LameTTL != nil {
		if err := m.LameTTL.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("lame_ttl")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("lame_ttl")
			}
			return err
		}
	}

	return nil
}

func (m *ConfigServerInheritance) validateLogQueryResponse(formats strfmt.Registry) error {
	if swag.IsZero(m.LogQueryResponse) { // not required
		return nil
	}

	if m.LogQueryResponse != nil {
		if err := m.LogQueryResponse.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("log_query_response")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("log_query_response")
			}
			return err
		}
	}

	return nil
}

func (m *ConfigServerInheritance) validateMatchRecursiveOnly(formats strfmt.Registry) error {
	if swag.IsZero(m.MatchRecursiveOnly) { // not required
		return nil
	}

	if m.MatchRecursiveOnly != nil {
		if err := m.MatchRecursiveOnly.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("match_recursive_only")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("match_recursive_only")
			}
			return err
		}
	}

	return nil
}

func (m *ConfigServerInheritance) validateMaxCacheTTL(formats strfmt.Registry) error {
	if swag.IsZero(m.MaxCacheTTL) { // not required
		return nil
	}

	if m.MaxCacheTTL != nil {
		if err := m.MaxCacheTTL.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("max_cache_ttl")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("max_cache_ttl")
			}
			return err
		}
	}

	return nil
}

func (m *ConfigServerInheritance) validateMaxNegativeTTL(formats strfmt.Registry) error {
	if swag.IsZero(m.MaxNegativeTTL) { // not required
		return nil
	}

	if m.MaxNegativeTTL != nil {
		if err := m.MaxNegativeTTL.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("max_negative_ttl")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("max_negative_ttl")
			}
			return err
		}
	}

	return nil
}

func (m *ConfigServerInheritance) validateMinimalResponses(formats strfmt.Registry) error {
	if swag.IsZero(m.MinimalResponses) { // not required
		return nil
	}

	if m.MinimalResponses != nil {
		if err := m.MinimalResponses.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("minimal_responses")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("minimal_responses")
			}
			return err
		}
	}

	return nil
}

func (m *ConfigServerInheritance) validateNotify(formats strfmt.Registry) error {
	if swag.IsZero(m.Notify) { // not required
		return nil
	}

	if m.Notify != nil {
		if err := m.Notify.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("notify")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("notify")
			}
			return err
		}
	}

	return nil
}

func (m *ConfigServerInheritance) validateQueryACL(formats strfmt.Registry) error {
	if swag.IsZero(m.QueryACL) { // not required
		return nil
	}

	if m.QueryACL != nil {
		if err := m.QueryACL.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("query_acl")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("query_acl")
			}
			return err
		}
	}

	return nil
}

func (m *ConfigServerInheritance) validateQueryPort(formats strfmt.Registry) error {
	if swag.IsZero(m.QueryPort) { // not required
		return nil
	}

	if m.QueryPort != nil {
		if err := m.QueryPort.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("query_port")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("query_port")
			}
			return err
		}
	}

	return nil
}

func (m *ConfigServerInheritance) validateRecursionACL(formats strfmt.Registry) error {
	if swag.IsZero(m.RecursionACL) { // not required
		return nil
	}

	if m.RecursionACL != nil {
		if err := m.RecursionACL.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("recursion_acl")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("recursion_acl")
			}
			return err
		}
	}

	return nil
}

func (m *ConfigServerInheritance) validateRecursionEnabled(formats strfmt.Registry) error {
	if swag.IsZero(m.RecursionEnabled) { // not required
		return nil
	}

	if m.RecursionEnabled != nil {
		if err := m.RecursionEnabled.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("recursion_enabled")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("recursion_enabled")
			}
			return err
		}
	}

	return nil
}

func (m *ConfigServerInheritance) validateRecursiveClients(formats strfmt.Registry) error {
	if swag.IsZero(m.RecursiveClients) { // not required
		return nil
	}

	if m.RecursiveClients != nil {
		if err := m.RecursiveClients.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("recursive_clients")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("recursive_clients")
			}
			return err
		}
	}

	return nil
}

func (m *ConfigServerInheritance) validateResolverQueryTimeout(formats strfmt.Registry) error {
	if swag.IsZero(m.ResolverQueryTimeout) { // not required
		return nil
	}

	if m.ResolverQueryTimeout != nil {
		if err := m.ResolverQueryTimeout.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("resolver_query_timeout")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("resolver_query_timeout")
			}
			return err
		}
	}

	return nil
}

func (m *ConfigServerInheritance) validateSecondaryAxfrQueryLimit(formats strfmt.Registry) error {
	if swag.IsZero(m.SecondaryAxfrQueryLimit) { // not required
		return nil
	}

	if m.SecondaryAxfrQueryLimit != nil {
		if err := m.SecondaryAxfrQueryLimit.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("secondary_axfr_query_limit")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("secondary_axfr_query_limit")
			}
			return err
		}
	}

	return nil
}

func (m *ConfigServerInheritance) validateSecondarySoaQueryLimit(formats strfmt.Registry) error {
	if swag.IsZero(m.SecondarySoaQueryLimit) { // not required
		return nil
	}

	if m.SecondarySoaQueryLimit != nil {
		if err := m.SecondarySoaQueryLimit.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("secondary_soa_query_limit")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("secondary_soa_query_limit")
			}
			return err
		}
	}

	return nil
}

func (m *ConfigServerInheritance) validateTransferACL(formats strfmt.Registry) error {
	if swag.IsZero(m.TransferACL) { // not required
		return nil
	}

	if m.TransferACL != nil {
		if err := m.TransferACL.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("transfer_acl")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("transfer_acl")
			}
			return err
		}
	}

	return nil
}

func (m *ConfigServerInheritance) validateUpdateACL(formats strfmt.Registry) error {
	if swag.IsZero(m.UpdateACL) { // not required
		return nil
	}

	if m.UpdateACL != nil {
		if err := m.UpdateACL.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("update_acl")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("update_acl")
			}
			return err
		}
	}

	return nil
}

func (m *ConfigServerInheritance) validateUseForwardersForSubzones(formats strfmt.Registry) error {
	if swag.IsZero(m.UseForwardersForSubzones) { // not required
		return nil
	}

	if m.UseForwardersForSubzones != nil {
		if err := m.UseForwardersForSubzones.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("use_forwarders_for_subzones")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("use_forwarders_for_subzones")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this config server inheritance based on the context it is used
func (m *ConfigServerInheritance) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateCustomRootNsBlock(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDnssecValidationBlock(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateEcsBlock(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateForwardersBlock(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateGssTsigEnabled(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateKerberosKeys(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLameTTL(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLogQueryResponse(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMatchRecursiveOnly(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMaxCacheTTL(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMaxNegativeTTL(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMinimalResponses(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateNotify(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateQueryACL(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateQueryPort(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateRecursionACL(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateRecursionEnabled(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateRecursiveClients(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateResolverQueryTimeout(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSecondaryAxfrQueryLimit(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSecondarySoaQueryLimit(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTransferACL(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUpdateACL(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUseForwardersForSubzones(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ConfigServerInheritance) contextValidateCustomRootNsBlock(ctx context.Context, formats strfmt.Registry) error {

	if m.CustomRootNsBlock != nil {
		if err := m.CustomRootNsBlock.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("custom_root_ns_block")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("custom_root_ns_block")
			}
			return err
		}
	}

	return nil
}

func (m *ConfigServerInheritance) contextValidateDnssecValidationBlock(ctx context.Context, formats strfmt.Registry) error {

	if m.DnssecValidationBlock != nil {
		if err := m.DnssecValidationBlock.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("dnssec_validation_block")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("dnssec_validation_block")
			}
			return err
		}
	}

	return nil
}

func (m *ConfigServerInheritance) contextValidateEcsBlock(ctx context.Context, formats strfmt.Registry) error {

	if m.EcsBlock != nil {
		if err := m.EcsBlock.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ecs_block")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("ecs_block")
			}
			return err
		}
	}

	return nil
}

func (m *ConfigServerInheritance) contextValidateForwardersBlock(ctx context.Context, formats strfmt.Registry) error {

	if m.ForwardersBlock != nil {
		if err := m.ForwardersBlock.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("forwarders_block")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("forwarders_block")
			}
			return err
		}
	}

	return nil
}

func (m *ConfigServerInheritance) contextValidateGssTsigEnabled(ctx context.Context, formats strfmt.Registry) error {

	if m.GssTsigEnabled != nil {
		if err := m.GssTsigEnabled.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("gss_tsig_enabled")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("gss_tsig_enabled")
			}
			return err
		}
	}

	return nil
}

func (m *ConfigServerInheritance) contextValidateKerberosKeys(ctx context.Context, formats strfmt.Registry) error {

	if m.KerberosKeys != nil {
		if err := m.KerberosKeys.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("kerberos_keys")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("kerberos_keys")
			}
			return err
		}
	}

	return nil
}

func (m *ConfigServerInheritance) contextValidateLameTTL(ctx context.Context, formats strfmt.Registry) error {

	if m.LameTTL != nil {
		if err := m.LameTTL.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("lame_ttl")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("lame_ttl")
			}
			return err
		}
	}

	return nil
}

func (m *ConfigServerInheritance) contextValidateLogQueryResponse(ctx context.Context, formats strfmt.Registry) error {

	if m.LogQueryResponse != nil {
		if err := m.LogQueryResponse.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("log_query_response")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("log_query_response")
			}
			return err
		}
	}

	return nil
}

func (m *ConfigServerInheritance) contextValidateMatchRecursiveOnly(ctx context.Context, formats strfmt.Registry) error {

	if m.MatchRecursiveOnly != nil {
		if err := m.MatchRecursiveOnly.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("match_recursive_only")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("match_recursive_only")
			}
			return err
		}
	}

	return nil
}

func (m *ConfigServerInheritance) contextValidateMaxCacheTTL(ctx context.Context, formats strfmt.Registry) error {

	if m.MaxCacheTTL != nil {
		if err := m.MaxCacheTTL.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("max_cache_ttl")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("max_cache_ttl")
			}
			return err
		}
	}

	return nil
}

func (m *ConfigServerInheritance) contextValidateMaxNegativeTTL(ctx context.Context, formats strfmt.Registry) error {

	if m.MaxNegativeTTL != nil {
		if err := m.MaxNegativeTTL.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("max_negative_ttl")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("max_negative_ttl")
			}
			return err
		}
	}

	return nil
}

func (m *ConfigServerInheritance) contextValidateMinimalResponses(ctx context.Context, formats strfmt.Registry) error {

	if m.MinimalResponses != nil {
		if err := m.MinimalResponses.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("minimal_responses")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("minimal_responses")
			}
			return err
		}
	}

	return nil
}

func (m *ConfigServerInheritance) contextValidateNotify(ctx context.Context, formats strfmt.Registry) error {

	if m.Notify != nil {
		if err := m.Notify.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("notify")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("notify")
			}
			return err
		}
	}

	return nil
}

func (m *ConfigServerInheritance) contextValidateQueryACL(ctx context.Context, formats strfmt.Registry) error {

	if m.QueryACL != nil {
		if err := m.QueryACL.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("query_acl")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("query_acl")
			}
			return err
		}
	}

	return nil
}

func (m *ConfigServerInheritance) contextValidateQueryPort(ctx context.Context, formats strfmt.Registry) error {

	if m.QueryPort != nil {
		if err := m.QueryPort.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("query_port")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("query_port")
			}
			return err
		}
	}

	return nil
}

func (m *ConfigServerInheritance) contextValidateRecursionACL(ctx context.Context, formats strfmt.Registry) error {

	if m.RecursionACL != nil {
		if err := m.RecursionACL.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("recursion_acl")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("recursion_acl")
			}
			return err
		}
	}

	return nil
}

func (m *ConfigServerInheritance) contextValidateRecursionEnabled(ctx context.Context, formats strfmt.Registry) error {

	if m.RecursionEnabled != nil {
		if err := m.RecursionEnabled.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("recursion_enabled")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("recursion_enabled")
			}
			return err
		}
	}

	return nil
}

func (m *ConfigServerInheritance) contextValidateRecursiveClients(ctx context.Context, formats strfmt.Registry) error {

	if m.RecursiveClients != nil {
		if err := m.RecursiveClients.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("recursive_clients")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("recursive_clients")
			}
			return err
		}
	}

	return nil
}

func (m *ConfigServerInheritance) contextValidateResolverQueryTimeout(ctx context.Context, formats strfmt.Registry) error {

	if m.ResolverQueryTimeout != nil {
		if err := m.ResolverQueryTimeout.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("resolver_query_timeout")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("resolver_query_timeout")
			}
			return err
		}
	}

	return nil
}

func (m *ConfigServerInheritance) contextValidateSecondaryAxfrQueryLimit(ctx context.Context, formats strfmt.Registry) error {

	if m.SecondaryAxfrQueryLimit != nil {
		if err := m.SecondaryAxfrQueryLimit.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("secondary_axfr_query_limit")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("secondary_axfr_query_limit")
			}
			return err
		}
	}

	return nil
}

func (m *ConfigServerInheritance) contextValidateSecondarySoaQueryLimit(ctx context.Context, formats strfmt.Registry) error {

	if m.SecondarySoaQueryLimit != nil {
		if err := m.SecondarySoaQueryLimit.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("secondary_soa_query_limit")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("secondary_soa_query_limit")
			}
			return err
		}
	}

	return nil
}

func (m *ConfigServerInheritance) contextValidateTransferACL(ctx context.Context, formats strfmt.Registry) error {

	if m.TransferACL != nil {
		if err := m.TransferACL.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("transfer_acl")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("transfer_acl")
			}
			return err
		}
	}

	return nil
}

func (m *ConfigServerInheritance) contextValidateUpdateACL(ctx context.Context, formats strfmt.Registry) error {

	if m.UpdateACL != nil {
		if err := m.UpdateACL.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("update_acl")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("update_acl")
			}
			return err
		}
	}

	return nil
}

func (m *ConfigServerInheritance) contextValidateUseForwardersForSubzones(ctx context.Context, formats strfmt.Registry) error {

	if m.UseForwardersForSubzones != nil {
		if err := m.UseForwardersForSubzones.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("use_forwarders_for_subzones")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("use_forwarders_for_subzones")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ConfigServerInheritance) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ConfigServerInheritance) UnmarshalBinary(b []byte) error {
	var res ConfigServerInheritance
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
