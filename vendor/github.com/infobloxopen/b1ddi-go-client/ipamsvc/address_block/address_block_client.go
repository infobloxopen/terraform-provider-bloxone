// Code generated by go-swagger; DO NOT EDIT.

package address_block

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"fmt"

	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"

	b1cliruntime "github.com/infobloxopen/b1ddi-go-client/runtime"
)

// New creates a new address block API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry) ClientService {
	return &Client{transport: transport, formats: formats}
}

/*
Client for address block API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
}

// ClientOption is the option for Client methods
type ClientOption func(*runtime.ClientOperation)

// ClientService is the interface for Client methods
type ClientService interface {
	AddressBlockCopy(params *AddressBlockCopyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AddressBlockCopyCreated, error)

	AddressBlockCreate(params *AddressBlockCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AddressBlockCreateCreated, error)

	AddressBlockCreateNextAvailableAB(params *AddressBlockCreateNextAvailableABParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AddressBlockCreateNextAvailableABCreated, error)

	AddressBlockCreateNextAvailableIP(params *AddressBlockCreateNextAvailableIPParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AddressBlockCreateNextAvailableIPCreated, error)

	AddressBlockCreateNextAvailableSubnet(params *AddressBlockCreateNextAvailableSubnetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AddressBlockCreateNextAvailableSubnetCreated, error)

	AddressBlockDelete(params *AddressBlockDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AddressBlockDeleteNoContent, error)

	AddressBlockList(params *AddressBlockListParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AddressBlockListOK, error)

	AddressBlockListNextAvailableAB(params *AddressBlockListNextAvailableABParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AddressBlockListNextAvailableABOK, error)

	AddressBlockListNextAvailableIP(params *AddressBlockListNextAvailableIPParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AddressBlockListNextAvailableIPOK, error)

	AddressBlockListNextAvailableSubnet(params *AddressBlockListNextAvailableSubnetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AddressBlockListNextAvailableSubnetOK, error)

	AddressBlockRead(params *AddressBlockReadParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AddressBlockReadOK, error)

	AddressBlockUpdate(params *AddressBlockUpdateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AddressBlockUpdateCreated, error)

	SetTransport(transport runtime.ClientTransport)
}

/*
  AddressBlockCopy copies the address block

  Use this method to copy an __AddressBlock__ object.
The __AddressBlock__ object allows a uniform representation of the address space segmentation, supporting functions such as administrative grouping, routing aggregation, delegation etc.
*/
func (a *Client) AddressBlockCopy(params *AddressBlockCopyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AddressBlockCopyCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewAddressBlockCopyParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "address_blockCopy",
		Method:             "POST",
		PathPattern:        "/ipam/address_block/{id}/copy",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &AddressBlockCopyReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	params.ID = b1cliruntime.TrimIDPrefix(op.PathPattern, params.ID)
	op.Params = params

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*AddressBlockCopyCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for address_blockCopy: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  AddressBlockCreate creates the address block

  Use this method to create an __AddressBlock__ object.
The __AddressBlock__ object allows a uniform representation of the address space segmentation, supporting functions such as administrative grouping, routing aggregation, delegation etc.
*/
func (a *Client) AddressBlockCreate(params *AddressBlockCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AddressBlockCreateCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewAddressBlockCreateParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "address_blockCreate",
		Method:             "POST",
		PathPattern:        "/ipam/address_block",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &AddressBlockCreateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*AddressBlockCreateCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for address_blockCreate: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  AddressBlockCreateNextAvailableAB creates the next available address block object

  Use this method to create a Next Available __AddressBlock__ object.
The Next Available Address Block is a generator that allocates one or more _ipam/address_block_ resource from available address blocks when the network address is not known prior to allocation.
*/
func (a *Client) AddressBlockCreateNextAvailableAB(params *AddressBlockCreateNextAvailableABParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AddressBlockCreateNextAvailableABCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewAddressBlockCreateNextAvailableABParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "address_blockCreateNextAvailableAB",
		Method:             "POST",
		PathPattern:        "/ipam/address_block/{id}/nextavailableaddressblock",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &AddressBlockCreateNextAvailableABReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	params.ID = b1cliruntime.TrimIDPrefix(op.PathPattern, params.ID)
	op.Params = params

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*AddressBlockCreateNextAvailableABCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for address_blockCreateNextAvailableAB: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  AddressBlockCreateNextAvailableIP allocates the next available IP address

  Use this method to allocate the next available IP address.
This allocates one or more __Address__ (_ipam/address_) resource from available addresses, when the IP address is not known prior to allocation.
*/
func (a *Client) AddressBlockCreateNextAvailableIP(params *AddressBlockCreateNextAvailableIPParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AddressBlockCreateNextAvailableIPCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewAddressBlockCreateNextAvailableIPParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "address_blockCreateNextAvailableIP",
		Method:             "POST",
		PathPattern:        "/ipam/address_block/{id}/nextavailableip",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &AddressBlockCreateNextAvailableIPReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	params.ID = b1cliruntime.TrimIDPrefix(op.PathPattern, params.ID)
	op.Params = params

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*AddressBlockCreateNextAvailableIPCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for address_blockCreateNextAvailableIP: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  AddressBlockCreateNextAvailableSubnet creates the next available subnet object

  Use this method to create a Next Available __Subnet__ object.
The Next Available Subnet is a generator that allocates one or more _ipam/subnet_ resource from available subnets when the network address is not known prior to allocation.
*/
func (a *Client) AddressBlockCreateNextAvailableSubnet(params *AddressBlockCreateNextAvailableSubnetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AddressBlockCreateNextAvailableSubnetCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewAddressBlockCreateNextAvailableSubnetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "address_blockCreateNextAvailableSubnet",
		Method:             "POST",
		PathPattern:        "/ipam/address_block/{id}/nextavailablesubnet",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &AddressBlockCreateNextAvailableSubnetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	params.ID = b1cliruntime.TrimIDPrefix(op.PathPattern, params.ID)
	op.Params = params

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*AddressBlockCreateNextAvailableSubnetCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for address_blockCreateNextAvailableSubnet: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  AddressBlockDelete moves the address block to the recycle bin

  Use this method to move an __AddressBlock__ object to the recycle bin.
The __AddressBlock__ object allows a uniform representation of the address space segmentation, supporting functions such as administrative grouping, routing aggregation, delegation etc.
*/
func (a *Client) AddressBlockDelete(params *AddressBlockDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AddressBlockDeleteNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewAddressBlockDeleteParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "address_blockDelete",
		Method:             "DELETE",
		PathPattern:        "/ipam/address_block/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &AddressBlockDeleteReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	params.ID = b1cliruntime.TrimIDPrefix(op.PathPattern, params.ID)
	op.Params = params

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*AddressBlockDeleteNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for address_blockDelete: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  AddressBlockList retrieves the address blocks

  Use this method to retrieve __AddressBlock__ objects.
The __AddressBlock__ object allows a uniform representation of the address space segmentation, supporting functions such as administrative grouping, routing aggregation, delegation etc.
*/
func (a *Client) AddressBlockList(params *AddressBlockListParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AddressBlockListOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewAddressBlockListParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "address_blockList",
		Method:             "GET",
		PathPattern:        "/ipam/address_block",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &AddressBlockListReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*AddressBlockListOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for address_blockList: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  AddressBlockListNextAvailableAB lists next available address block objects

  Use this method to list Next Available __AddressBlock__ objects.
The Next Available __AddressBlock__ is a generator that returns one or more _ipam/address_block_ resource from available address blocks when the network address is not known prior to allocation.
*/
func (a *Client) AddressBlockListNextAvailableAB(params *AddressBlockListNextAvailableABParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AddressBlockListNextAvailableABOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewAddressBlockListNextAvailableABParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "address_blockListNextAvailableAB",
		Method:             "GET",
		PathPattern:        "/ipam/address_block/{id}/nextavailableaddressblock",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &AddressBlockListNextAvailableABReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	params.ID = b1cliruntime.TrimIDPrefix(op.PathPattern, params.ID)
	op.Params = params

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*AddressBlockListNextAvailableABOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for address_blockListNextAvailableAB: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  AddressBlockListNextAvailableIP retrieves the next available IP address

  Use this method to retrieve the next available IP address.
This returns one or more __Address__ (_ipam/address_) resource from available addresses, when IP address is not known prior to allocation.
*/
func (a *Client) AddressBlockListNextAvailableIP(params *AddressBlockListNextAvailableIPParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AddressBlockListNextAvailableIPOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewAddressBlockListNextAvailableIPParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "address_blockListNextAvailableIP",
		Method:             "GET",
		PathPattern:        "/ipam/address_block/{id}/nextavailableip",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &AddressBlockListNextAvailableIPReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	params.ID = b1cliruntime.TrimIDPrefix(op.PathPattern, params.ID)
	op.Params = params

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*AddressBlockListNextAvailableIPOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for address_blockListNextAvailableIP: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  AddressBlockListNextAvailableSubnet lists next available subnet objects

  Use this method to list Next Available __Subnet__ objects.
The Next Available Address Block is a generator that returns one or more _ipam/subnet_ resource from available subnets when the network address is not known prior to allocation.
*/
func (a *Client) AddressBlockListNextAvailableSubnet(params *AddressBlockListNextAvailableSubnetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AddressBlockListNextAvailableSubnetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewAddressBlockListNextAvailableSubnetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "address_blockListNextAvailableSubnet",
		Method:             "GET",
		PathPattern:        "/ipam/address_block/{id}/nextavailablesubnet",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &AddressBlockListNextAvailableSubnetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	params.ID = b1cliruntime.TrimIDPrefix(op.PathPattern, params.ID)
	op.Params = params

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*AddressBlockListNextAvailableSubnetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for address_blockListNextAvailableSubnet: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  AddressBlockRead retrieves the address block

  Use this method to retrieve an __AddressBlock__ object.
The __AddressBlock__ object allows a uniform representation of the address space segmentation, supporting functions such as administrative grouping, routing aggregation, delegation etc.
*/
func (a *Client) AddressBlockRead(params *AddressBlockReadParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AddressBlockReadOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewAddressBlockReadParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "address_blockRead",
		Method:             "GET",
		PathPattern:        "/ipam/address_block/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &AddressBlockReadReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	params.ID = b1cliruntime.TrimIDPrefix(op.PathPattern, params.ID)
	op.Params = params

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*AddressBlockReadOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for address_blockRead: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  AddressBlockUpdate updates the address block

  Use this method to update an __AddressBlock__ object.
The __AddressBlock__ object allows a uniform representation of the address space segmentation, supporting functions such as administrative grouping, routing aggregation, delegation etc.
*/
func (a *Client) AddressBlockUpdate(params *AddressBlockUpdateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AddressBlockUpdateCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewAddressBlockUpdateParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "address_blockUpdate",
		Method:             "PATCH",
		PathPattern:        "/ipam/address_block/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &AddressBlockUpdateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	params.ID = b1cliruntime.TrimIDPrefix(op.PathPattern, params.ID)
	op.Params = params

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*AddressBlockUpdateCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for address_blockUpdate: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

// SetTransport changes the transport on the client
func (a *Client) SetTransport(transport runtime.ClientTransport) {
	a.transport = transport
}
