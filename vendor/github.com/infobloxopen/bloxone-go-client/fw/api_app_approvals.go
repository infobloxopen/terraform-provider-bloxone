/*
BloxOne FW API

BloxOne Threat Defense Cloud is an extension of the BloxOne Suite that provides visibility into infected and compromised off-premises devices, roaming users, remote sites, and branch offices. You can subscribe to BloxOne Cloud and use its functionality to mitigate and control malware as well as provide unprecedented insight into your network security posture and enable timely action. BloxOne Cloud also offers unified policy management, reporting, and threat analytics across the entire spectrum. Using automated and high-quality threat intelligence feeds and unique behavioral analytics, it automatically stops device communications with C&Cs/botnets and prevents DNS based data exfiltration.  The mission-critical DNS infrastructure can become a vulnerable component in your network when it is inadequately protected by traditional security solutions and consequently used as an attack surface. Compromised DNS services can result in catastrophic network and system failures. To fully protect your network in todayâ€™s cyber security threat environment, Infoblox sets a new DNS security standard by offering scalable, enterprise-grade, and integrated protection for your DNS infrastructure.  Through the Infoblox Cloud Services Portal, you can view the status of your subscription and threat intelligence feeds, manage your network scope and roaming end users, and learn more about threats on your networks through the Infoblox Threat Lookup tool and predefined reports.

API version: v1
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package fw

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"

	"github.com/infobloxopen/bloxone-go-client/internal"
)

type AppApprovalsAPI interface {
	/*
		AppApprovalsListAppApprovals Method for AppApprovalsListAppApprovals

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiAppApprovalsListAppApprovalsRequest
	*/
	AppApprovalsListAppApprovals(ctx context.Context) ApiAppApprovalsListAppApprovalsRequest

	// AppApprovalsListAppApprovalsExecute executes the request
	//  @return AtcfwAppApprovalMultiResponse
	AppApprovalsListAppApprovalsExecute(r ApiAppApprovalsListAppApprovalsRequest) (*AtcfwAppApprovalMultiResponse, *http.Response, error)
	/*
			AppApprovalsReplaceAppApprovals Update Application Approval.

			Use this method to update the specified Application Approved object.

		Required: an array of approvals
		- status
		- app_name



			@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			@return ApiAppApprovalsReplaceAppApprovalsRequest
	*/
	AppApprovalsReplaceAppApprovals(ctx context.Context) ApiAppApprovalsReplaceAppApprovalsRequest

	// AppApprovalsReplaceAppApprovalsExecute executes the request
	//  @return AtcfwAppApprovalMultiResponse
	AppApprovalsReplaceAppApprovalsExecute(r ApiAppApprovalsReplaceAppApprovalsRequest) (*AtcfwAppApprovalMultiResponse, *http.Response, error)
	/*
		AppApprovalsUpdateAppApprovals Method for AppApprovalsUpdateAppApprovals

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiAppApprovalsUpdateAppApprovalsRequest
	*/
	AppApprovalsUpdateAppApprovals(ctx context.Context) ApiAppApprovalsUpdateAppApprovalsRequest

	// AppApprovalsUpdateAppApprovalsExecute executes the request
	//  @return AtcfwAppApprovalMultiResponse
	AppApprovalsUpdateAppApprovalsExecute(r ApiAppApprovalsUpdateAppApprovalsRequest) (*AtcfwAppApprovalMultiResponse, *http.Response, error)
}

// AppApprovalsAPIService AppApprovalsAPI service
type AppApprovalsAPIService internal.Service

type ApiAppApprovalsListAppApprovalsRequest struct {
	ctx        context.Context
	ApiService AppApprovalsAPI
	filter     *string
}

// A collection of response resources can be filtered by a logical expression string that includes JSON tag references to values in each resource, literal values, and logical operators. If a resource does not have the specified tag, its value is assumed to be null.  Literal values include numbers (integer and floating-point), and quoted (both single- or double-quoted) literal strings, and &#39;null&#39;. The following operators are commonly used in filter expressions:  |  Op   |  Description               |  |  --   |  -----------               |  |  &#x3D;&#x3D;   |  Equal                     |  |  !&#x3D;   |  Not Equal                 |  |  &gt;    |  Greater Than              |  |   &gt;&#x3D;  |  Greater Than or Equal To  |  |  &lt;    |  Less Than                 |  |  &lt;&#x3D;   |  Less Than or Equal To     |  |  and  |  Logical AND               |  |  ~    |  Matches Regex             |  |  !~   |  Does Not Match Regex      |  |  or   |  Logical OR                |  |  not  |  Logical NOT               |  |  ()   |  Groupping Operators       |
func (r ApiAppApprovalsListAppApprovalsRequest) Filter(filter string) ApiAppApprovalsListAppApprovalsRequest {
	r.filter = &filter
	return r
}

func (r ApiAppApprovalsListAppApprovalsRequest) Execute() (*AtcfwAppApprovalMultiResponse, *http.Response, error) {
	return r.ApiService.AppApprovalsListAppApprovalsExecute(r)
}

/*
AppApprovalsListAppApprovals Method for AppApprovalsListAppApprovals

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiAppApprovalsListAppApprovalsRequest
*/
func (a *AppApprovalsAPIService) AppApprovalsListAppApprovals(ctx context.Context) ApiAppApprovalsListAppApprovalsRequest {
	return ApiAppApprovalsListAppApprovalsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return AtcfwAppApprovalMultiResponse
func (a *AppApprovalsAPIService) AppApprovalsListAppApprovalsExecute(r ApiAppApprovalsListAppApprovalsRequest) (*AtcfwAppApprovalMultiResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []internal.FormFile
		localVarReturnValue *AtcfwAppApprovalMultiResponse
	)

	localBasePath, err := a.Client.Cfg.ServerURLWithContext(r.ctx, "AppApprovalsAPIService.AppApprovalsListAppApprovals")
	if err != nil {
		return localVarReturnValue, nil, internal.NewGenericOpenAPIError(err.Error())
	}

	localVarPath := localBasePath + "/app_approvals"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filter != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "_filter", r.filter, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := internal.SelectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := internal.SelectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.Client.PrepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.Client.CallAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := internal.NewGenericOpenAPIErrorWithBody(localVarHTTPResponse.Status, localVarBody)
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.Client.Decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := internal.NewGenericOpenAPIErrorWithBody(err.Error(), localVarBody)
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAppApprovalsReplaceAppApprovalsRequest struct {
	ctx        context.Context
	ApiService AppApprovalsAPI
	body       *AtcfwAppApprovalsReplaceRequest
}

func (r ApiAppApprovalsReplaceAppApprovalsRequest) Body(body AtcfwAppApprovalsReplaceRequest) ApiAppApprovalsReplaceAppApprovalsRequest {
	r.body = &body
	return r
}

func (r ApiAppApprovalsReplaceAppApprovalsRequest) Execute() (*AtcfwAppApprovalMultiResponse, *http.Response, error) {
	return r.ApiService.AppApprovalsReplaceAppApprovalsExecute(r)
}

/*
AppApprovalsReplaceAppApprovals Update Application Approval.

Use this method to update the specified Application Approved object.

Required: an array of approvals
- status
- app_name

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiAppApprovalsReplaceAppApprovalsRequest
*/
func (a *AppApprovalsAPIService) AppApprovalsReplaceAppApprovals(ctx context.Context) ApiAppApprovalsReplaceAppApprovalsRequest {
	return ApiAppApprovalsReplaceAppApprovalsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return AtcfwAppApprovalMultiResponse
func (a *AppApprovalsAPIService) AppApprovalsReplaceAppApprovalsExecute(r ApiAppApprovalsReplaceAppApprovalsRequest) (*AtcfwAppApprovalMultiResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []internal.FormFile
		localVarReturnValue *AtcfwAppApprovalMultiResponse
	)

	localBasePath, err := a.Client.Cfg.ServerURLWithContext(r.ctx, "AppApprovalsAPIService.AppApprovalsReplaceAppApprovals")
	if err != nil {
		return localVarReturnValue, nil, internal.NewGenericOpenAPIError(err.Error())
	}

	localVarPath := localBasePath + "/app_approvals"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, internal.ReportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := internal.SelectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := internal.SelectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.Client.PrepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.Client.CallAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := internal.NewGenericOpenAPIErrorWithBody(localVarHTTPResponse.Status, localVarBody)
		if localVarHTTPResponse.StatusCode == 500 {
			var v AccessCodesListAccessCodes500Response
			err = a.Client.Decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr = internal.NewGenericOpenAPIErrorWithBody(err.Error(), localVarBody)
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr = internal.NewGenericOpenAPIErrorWithBodyAndModel(localVarHTTPResponse.Status, localVarBody, v)
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.Client.Decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := internal.NewGenericOpenAPIErrorWithBody(err.Error(), localVarBody)
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAppApprovalsUpdateAppApprovalsRequest struct {
	ctx        context.Context
	ApiService AppApprovalsAPI
	body       *AtcfwAppApprovalsUpdateRequest
}

func (r ApiAppApprovalsUpdateAppApprovalsRequest) Body(body AtcfwAppApprovalsUpdateRequest) ApiAppApprovalsUpdateAppApprovalsRequest {
	r.body = &body
	return r
}

func (r ApiAppApprovalsUpdateAppApprovalsRequest) Execute() (*AtcfwAppApprovalMultiResponse, *http.Response, error) {
	return r.ApiService.AppApprovalsUpdateAppApprovalsExecute(r)
}

/*
AppApprovalsUpdateAppApprovals Method for AppApprovalsUpdateAppApprovals

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiAppApprovalsUpdateAppApprovalsRequest
*/
func (a *AppApprovalsAPIService) AppApprovalsUpdateAppApprovals(ctx context.Context) ApiAppApprovalsUpdateAppApprovalsRequest {
	return ApiAppApprovalsUpdateAppApprovalsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return AtcfwAppApprovalMultiResponse
func (a *AppApprovalsAPIService) AppApprovalsUpdateAppApprovalsExecute(r ApiAppApprovalsUpdateAppApprovalsRequest) (*AtcfwAppApprovalMultiResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []internal.FormFile
		localVarReturnValue *AtcfwAppApprovalMultiResponse
	)

	localBasePath, err := a.Client.Cfg.ServerURLWithContext(r.ctx, "AppApprovalsAPIService.AppApprovalsUpdateAppApprovals")
	if err != nil {
		return localVarReturnValue, nil, internal.NewGenericOpenAPIError(err.Error())
	}

	localVarPath := localBasePath + "/app_approvals"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, internal.ReportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := internal.SelectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := internal.SelectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.Client.PrepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.Client.CallAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := internal.NewGenericOpenAPIErrorWithBody(localVarHTTPResponse.Status, localVarBody)
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.Client.Decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := internal.NewGenericOpenAPIErrorWithBody(err.Error(), localVarBody)
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	return localVarReturnValue, localVarHTTPResponse, nil
}
