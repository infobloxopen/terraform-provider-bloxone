/*
BloxOne FW API

BloxOne Threat Defense Cloud is an extension of the BloxOne Suite that provides visibility into infected and compromised off-premises devices, roaming users, remote sites, and branch offices. You can subscribe to BloxOne Cloud and use its functionality to mitigate and control malware as well as provide unprecedented insight into your network security posture and enable timely action. BloxOne Cloud also offers unified policy management, reporting, and threat analytics across the entire spectrum. Using automated and high-quality threat intelligence feeds and unique behavioral analytics, it automatically stops device communications with C&Cs/botnets and prevents DNS based data exfiltration.  The mission-critical DNS infrastructure can become a vulnerable component in your network when it is inadequately protected by traditional security solutions and consequently used as an attack surface. Compromised DNS services can result in catastrophic network and system failures. To fully protect your network in today’s cyber security threat environment, Infoblox sets a new DNS security standard by offering scalable, enterprise-grade, and integrated protection for your DNS infrastructure.  Through the Infoblox Cloud Services Portal, you can view the status of your subscription and threat intelligence feeds, manage your network scope and roaming end users, and learn more about threats on your networks through the Infoblox Threat Lookup tool and predefined reports.

API version: v1
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package fw

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/infobloxopen/bloxone-go-client/internal"
)

type SecurityPoliciesAPI interface {
	/*
			SecurityPoliciesCreateSecurityPolicy Create Security Policy.

			Use this method to create a Security Policy object. If no rule list is specified, the newly created Security Policy object will create these rules as a copy of default Security Policy rules ("Default Global Policy"). If rule list is provided it must contain at least the complete list of policy rules, including the rules based on all feeds that the account is entitled to. If no network list is specified, networking scope for this policy is empty, thus no action can be performed by this policy. Note that you are not allowed to add DNS Forwarding Proxies and Roaming Device Groups that are already assigned to a Security Policy different from "Default Global Policy", to assign them to this Security Policy object you should remove them from other Security Policy first.

		A security policy defines a set of rules and actions that you define to balance access and constraints so you can mitigate malicious attacks and provide security for your networks. When you create a new security policy, you first define a network scope to which you add networks, DNS forwarding proxies, and BloxOne Endpoint groups. BloxOne Cloud applies the security policy to all the entities that you include in the network scope. You can also include DNS forwarding proxies to which you want to apply the security policy.  After you define the network scope, you can add custom lists and category filters to the security policy. You can also specify actions for the added lists and filters, and to determine the precedence order for the entities. Depending on your subscription level, each security policy also comes with a set of predefined threat intelligence feeds and Threat Insight rules that are inherited from the default global policy. You cannot delete the inherited feeds and rules, but you can change their precedence order. For each policy you can define policy-level action (Default Action) gets applied when none of the policy rules apply/match. If an user really needs access to some blocked domain (web page) via a browser - there is a possibility to assign special bypass code(s) (Bypass Code) to any policy.

		Required:
		- name





			@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			@return ApiSecurityPoliciesCreateSecurityPolicyRequest
	*/
	SecurityPoliciesCreateSecurityPolicy(ctx context.Context) ApiSecurityPoliciesCreateSecurityPolicyRequest

	// SecurityPoliciesCreateSecurityPolicyExecute executes the request
	//  @return AtcfwSecurityPolicyCreateResponse
	SecurityPoliciesCreateSecurityPolicyExecute(r ApiSecurityPoliciesCreateSecurityPolicyRequest) (*AtcfwSecurityPolicyCreateResponse, *http.Response, error)
	/*
			SecurityPoliciesDeleteSecurityPolicy Delete Security Policies.

			Use this method to delete Security Policy objects. Deletion of multiple lists is an all-or-nothing operation (if any of the specified lists can not be deleted then none of the specified lists will be deleted).

		A security policy defines a set of rules and actions that you define to balance access and constraints so you can mitigate malicious attacks and provide security for your networks. When you create a new security policy, you first define a network scope to which you add networks, DNS forwarding proxies, and BloxOne Endpoint groups. BloxOne Cloud applies the security policy to all the entities that you include in the network scope. You can also include DNS forwarding proxies to which you want to apply the security policy.  After you define the network scope, you can add custom lists and category filters to the security policy. You can also specify actions for the added lists and filters, and to determine the precedence order for the entities. Depending on your subscription level, each security policy also comes with a set of predefined threat intelligence feeds and Threat Insight rules that are inherited from the default global policy. You cannot delete the inherited feeds and rules, but you can change their precedence order. For each policy you can define policy-level action (Default Action) gets applied when none of the policy rules apply/match. If an user really needs access to some blocked domain (web page) via a browser - there is a possibility to assign special bypass code(s) (Bypass Code) to any policy.

		Required:
		- ids


			@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			@return ApiSecurityPoliciesDeleteSecurityPolicyRequest
	*/
	SecurityPoliciesDeleteSecurityPolicy(ctx context.Context) ApiSecurityPoliciesDeleteSecurityPolicyRequest

	// SecurityPoliciesDeleteSecurityPolicyExecute executes the request
	SecurityPoliciesDeleteSecurityPolicyExecute(r ApiSecurityPoliciesDeleteSecurityPolicyRequest) (*http.Response, error)
	/*
			SecurityPoliciesDeleteSingleSecurityPolicy Delete Security Policy.

			Use this method to delete Security Policy object by given Security Policy object id.

		A security policy defines a set of rules and actions that you define to balance access and constraints so you can mitigate malicious attacks and provide security for your networks. When you create a new security policy, you first define a network scope to which you add networks, DNS forwarding proxies, and BloxOne Endpoint groups. BloxOne Cloud applies the security policy to all the entities that you include in the network scope. You can also include DNS forwarding proxies to which you want to apply the security policy.  After you define the network scope, you can add custom lists and category filters to the security policy. You can also specify actions for the added lists and filters, and to determine the precedence order for the entities. Depending on your subscription level, each security policy also comes with a set of predefined threat intelligence feeds and Threat Insight rules that are inherited from the default global policy. You cannot delete the inherited feeds and rules, but you can change their precedence order. For each policy you can define policy-level action (Default Action) gets applied when none of the policy rules apply/match. If an user really needs access to some blocked domain (web page) via a browser - there is a possibility to assign special bypass code(s) (Bypass Code) to any policy.



			@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			@param id The Security Policy object identifiers.
			@return ApiSecurityPoliciesDeleteSingleSecurityPolicyRequest
	*/
	SecurityPoliciesDeleteSingleSecurityPolicy(ctx context.Context, id int32) ApiSecurityPoliciesDeleteSingleSecurityPolicyRequest

	// SecurityPoliciesDeleteSingleSecurityPolicyExecute executes the request
	SecurityPoliciesDeleteSingleSecurityPolicyExecute(r ApiSecurityPoliciesDeleteSingleSecurityPolicyRequest) (*http.Response, error)
	/*
			SecurityPoliciesListSecurityPolicies List Security Policies.

			Use this method to retrieve information on all Security Policy objects for the account.

		A security policy defines a set of rules and actions that you define to balance access and constraints so you can mitigate malicious attacks and provide security for your networks. When you create a new security policy, you first define a network scope to which you add networks, DNS forwarding proxies, and BloxOne Endpoint groups. BloxOne Cloud applies the security policy to all the entities that you include in the network scope. You can also include DNS forwarding proxies to which you want to apply the security policy.  After you define the network scope, you can add custom lists and category filters to the security policy. You can also specify actions for the added lists and filters, and to determine the precedence order for the entities. Depending on your subscription level, each security policy also comes with a set of predefined threat intelligence feeds and Threat Insight rules that are inherited from the default global policy. You cannot delete the inherited feeds and rules, but you can change their precedence order. For each policy you can define policy-level action (Default Action) gets applied when none of the policy rules apply/match. If an user really needs access to some blocked domain (web page) via a browser - there is a possibility to assign special bypass code(s) (Bypass Code) to any policy.



			@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			@return ApiSecurityPoliciesListSecurityPoliciesRequest
	*/
	SecurityPoliciesListSecurityPolicies(ctx context.Context) ApiSecurityPoliciesListSecurityPoliciesRequest

	// SecurityPoliciesListSecurityPoliciesExecute executes the request
	//  @return AtcfwSecurityPolicyMultiResponse
	SecurityPoliciesListSecurityPoliciesExecute(r ApiSecurityPoliciesListSecurityPoliciesRequest) (*AtcfwSecurityPolicyMultiResponse, *http.Response, error)
	/*
			SecurityPoliciesReadSecurityPolicy Read Security Policy.

			Use this method to retrieve information on the specified Security Policy object.

		A security policy defines a set of rules and actions that you define to balance access and constraints so you can mitigate malicious attacks and provide security for your networks. When you create a new security policy, you first define a network scope to which you add networks, DNS forwarding proxies, and BloxOne Endpoint groups. BloxOne Cloud applies the security policy to all the entities that you include in the network scope. You can also include DNS forwarding proxies to which you want to apply the security policy.  After you define the network scope, you can add custom lists and category filters to the security policy. You can also specify actions for the added lists and filters, and to determine the precedence order for the entities. Depending on your subscription level, each security policy also comes with a set of predefined threat intelligence feeds and Threat Insight rules that are inherited from the default global policy. You cannot delete the inherited feeds and rules, but you can change their precedence order. For each policy you can define policy-level action (Default Action) gets applied when none of the policy rules apply/match. If an user really needs access to some blocked domain (web page) via a browser - there is a possibility to assign special bypass code(s) (Bypass Code) to any policy.


			@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			@param id The Security Policy object identifier.
			@return ApiSecurityPoliciesReadSecurityPolicyRequest
	*/
	SecurityPoliciesReadSecurityPolicy(ctx context.Context, id int32) ApiSecurityPoliciesReadSecurityPolicyRequest

	// SecurityPoliciesReadSecurityPolicyExecute executes the request
	//  @return AtcfwSecurityPolicyReadResponse
	SecurityPoliciesReadSecurityPolicyExecute(r ApiSecurityPoliciesReadSecurityPolicyRequest) (*AtcfwSecurityPolicyReadResponse, *http.Response, error)
	/*
			SecurityPoliciesUpdateSecurityPolicy Update Security Policy.

			Use this method to update a specified Network List object. The policy data supplied with the update request must have the complete list of policy rules, including the rules based on all feeds that the account is entitled to. If no network list is specified, networking scope for this policy is empty, thus no action can be performed by this policy. Note that you are not allowed to add DNS Forwarding Proxies and Roaming Device Groups that are already assigned to a Security Policy different from "Default Global Policy", to assign them to this Security Policy object you should remove them from other Security Policy first.

		A security policy defines a set of rules and actions that you define to balance access and constraints so you can mitigate malicious attacks and provide security for your networks. When you create a new security policy, you first define a network scope to which you add networks, DNS forwarding proxies, and BloxOne Endpoint groups. BloxOne Cloud applies the security policy to all the entities that you include in the network scope. You can also include DNS forwarding proxies to which you want to apply the security policy.  After you define the network scope, you can add custom lists and category filters to the security policy. You can also specify actions for the added lists and filters, and to determine the precedence order for the entities. Depending on your subscription level, each security policy also comes with a set of predefined threat intelligence feeds and Threat Insight rules that are inherited from the default global policy. You cannot delete the inherited feeds and rules, but you can change their precedence order. For each policy you can define policy-level action (Default Action) gets applied when none of the policy rules apply/match. If an user really needs access to some blocked domain (web page) via a browser - there is a possibility to assign special bypass code(s) (Bypass Code) to any policy.

		Required:
		- name
		- rules
		- dfps
		- network_lists
		- roaming_device_groups


			@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			@param id The Security Policy object identifier.
			@return ApiSecurityPoliciesUpdateSecurityPolicyRequest
	*/
	SecurityPoliciesUpdateSecurityPolicy(ctx context.Context, id int32) ApiSecurityPoliciesUpdateSecurityPolicyRequest

	// SecurityPoliciesUpdateSecurityPolicyExecute executes the request
	//  @return AtcfwSecurityPolicyUpdateResponse
	SecurityPoliciesUpdateSecurityPolicyExecute(r ApiSecurityPoliciesUpdateSecurityPolicyRequest) (*AtcfwSecurityPolicyUpdateResponse, *http.Response, error)
}

// SecurityPoliciesAPIService SecurityPoliciesAPI service
type SecurityPoliciesAPIService internal.Service

type ApiSecurityPoliciesCreateSecurityPolicyRequest struct {
	ctx        context.Context
	ApiService SecurityPoliciesAPI
	body       *AtcfwSecurityPolicy
}

// The Security Policy object.
func (r ApiSecurityPoliciesCreateSecurityPolicyRequest) Body(body AtcfwSecurityPolicy) ApiSecurityPoliciesCreateSecurityPolicyRequest {
	r.body = &body
	return r
}

func (r ApiSecurityPoliciesCreateSecurityPolicyRequest) Execute() (*AtcfwSecurityPolicyCreateResponse, *http.Response, error) {
	return r.ApiService.SecurityPoliciesCreateSecurityPolicyExecute(r)
}

/*
SecurityPoliciesCreateSecurityPolicy Create Security Policy.

Use this method to create a Security Policy object. If no rule list is specified, the newly created Security Policy object will create these rules as a copy of default Security Policy rules ("Default Global Policy"). If rule list is provided it must contain at least the complete list of policy rules, including the rules based on all feeds that the account is entitled to. If no network list is specified, networking scope for this policy is empty, thus no action can be performed by this policy. Note that you are not allowed to add DNS Forwarding Proxies and Roaming Device Groups that are already assigned to a Security Policy different from "Default Global Policy", to assign them to this Security Policy object you should remove them from other Security Policy first.

A security policy defines a set of rules and actions that you define to balance access and constraints so you can mitigate malicious attacks and provide security for your networks. When you create a new security policy, you first define a network scope to which you add networks, DNS forwarding proxies, and BloxOne Endpoint groups. BloxOne Cloud applies the security policy to all the entities that you include in the network scope. You can also include DNS forwarding proxies to which you want to apply the security policy.  After you define the network scope, you can add custom lists and category filters to the security policy. You can also specify actions for the added lists and filters, and to determine the precedence order for the entities. Depending on your subscription level, each security policy also comes with a set of predefined threat intelligence feeds and Threat Insight rules that are inherited from the default global policy. You cannot delete the inherited feeds and rules, but you can change their precedence order. For each policy you can define policy-level action (Default Action) gets applied when none of the policy rules apply/match. If an user really needs access to some blocked domain (web page) via a browser - there is a possibility to assign special bypass code(s) (Bypass Code) to any policy.

Required:
- name

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSecurityPoliciesCreateSecurityPolicyRequest
*/
func (a *SecurityPoliciesAPIService) SecurityPoliciesCreateSecurityPolicy(ctx context.Context) ApiSecurityPoliciesCreateSecurityPolicyRequest {
	return ApiSecurityPoliciesCreateSecurityPolicyRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return AtcfwSecurityPolicyCreateResponse
func (a *SecurityPoliciesAPIService) SecurityPoliciesCreateSecurityPolicyExecute(r ApiSecurityPoliciesCreateSecurityPolicyRequest) (*AtcfwSecurityPolicyCreateResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []internal.FormFile
		localVarReturnValue *AtcfwSecurityPolicyCreateResponse
	)

	localBasePath, err := a.Client.Cfg.ServerURLWithContext(r.ctx, "SecurityPoliciesAPIService.SecurityPoliciesCreateSecurityPolicy")
	if err != nil {
		return localVarReturnValue, nil, internal.NewGenericOpenAPIError(err.Error())
	}

	localVarPath := localBasePath + "/security_policies"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, internal.ReportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := internal.SelectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := internal.SelectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.Client.PrepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.Client.CallAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := internal.NewGenericOpenAPIErrorWithBody(localVarHTTPResponse.Status, localVarBody)
		if localVarHTTPResponse.StatusCode == 400 {
			var v SecurityPoliciesCreateSecurityPolicy400Response
			err = a.Client.Decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr = internal.NewGenericOpenAPIErrorWithBody(err.Error(), localVarBody)
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr = internal.NewGenericOpenAPIErrorWithBodyAndModel(localVarHTTPResponse.Status, localVarBody, v)
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v AccessCodesCreateAccessCode404Response
			err = a.Client.Decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr = internal.NewGenericOpenAPIErrorWithBody(err.Error(), localVarBody)
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr = internal.NewGenericOpenAPIErrorWithBodyAndModel(localVarHTTPResponse.Status, localVarBody, v)
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v SecurityPoliciesCreateSecurityPolicy409Response
			err = a.Client.Decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr = internal.NewGenericOpenAPIErrorWithBody(err.Error(), localVarBody)
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr = internal.NewGenericOpenAPIErrorWithBodyAndModel(localVarHTTPResponse.Status, localVarBody, v)
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v AccessCodesListAccessCodes500Response
			err = a.Client.Decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr = internal.NewGenericOpenAPIErrorWithBody(err.Error(), localVarBody)
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr = internal.NewGenericOpenAPIErrorWithBodyAndModel(localVarHTTPResponse.Status, localVarBody, v)
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.Client.Decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := internal.NewGenericOpenAPIErrorWithBody(err.Error(), localVarBody)
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSecurityPoliciesDeleteSecurityPolicyRequest struct {
	ctx        context.Context
	ApiService SecurityPoliciesAPI
	body       *AtcfwSecurityPolicyDeleteRequest
}

func (r ApiSecurityPoliciesDeleteSecurityPolicyRequest) Body(body AtcfwSecurityPolicyDeleteRequest) ApiSecurityPoliciesDeleteSecurityPolicyRequest {
	r.body = &body
	return r
}

func (r ApiSecurityPoliciesDeleteSecurityPolicyRequest) Execute() (*http.Response, error) {
	return r.ApiService.SecurityPoliciesDeleteSecurityPolicyExecute(r)
}

/*
SecurityPoliciesDeleteSecurityPolicy Delete Security Policies.

Use this method to delete Security Policy objects. Deletion of multiple lists is an all-or-nothing operation (if any of the specified lists can not be deleted then none of the specified lists will be deleted).

A security policy defines a set of rules and actions that you define to balance access and constraints so you can mitigate malicious attacks and provide security for your networks. When you create a new security policy, you first define a network scope to which you add networks, DNS forwarding proxies, and BloxOne Endpoint groups. BloxOne Cloud applies the security policy to all the entities that you include in the network scope. You can also include DNS forwarding proxies to which you want to apply the security policy.  After you define the network scope, you can add custom lists and category filters to the security policy. You can also specify actions for the added lists and filters, and to determine the precedence order for the entities. Depending on your subscription level, each security policy also comes with a set of predefined threat intelligence feeds and Threat Insight rules that are inherited from the default global policy. You cannot delete the inherited feeds and rules, but you can change their precedence order. For each policy you can define policy-level action (Default Action) gets applied when none of the policy rules apply/match. If an user really needs access to some blocked domain (web page) via a browser - there is a possibility to assign special bypass code(s) (Bypass Code) to any policy.

Required:
- ids

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSecurityPoliciesDeleteSecurityPolicyRequest
*/
func (a *SecurityPoliciesAPIService) SecurityPoliciesDeleteSecurityPolicy(ctx context.Context) ApiSecurityPoliciesDeleteSecurityPolicyRequest {
	return ApiSecurityPoliciesDeleteSecurityPolicyRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *SecurityPoliciesAPIService) SecurityPoliciesDeleteSecurityPolicyExecute(r ApiSecurityPoliciesDeleteSecurityPolicyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []internal.FormFile
	)

	localBasePath, err := a.Client.Cfg.ServerURLWithContext(r.ctx, "SecurityPoliciesAPIService.SecurityPoliciesDeleteSecurityPolicy")
	if err != nil {
		return nil, internal.NewGenericOpenAPIError(err.Error())
	}

	localVarPath := localBasePath + "/security_policies"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, internal.ReportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := internal.SelectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := internal.SelectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.Client.PrepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.Client.CallAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := internal.NewGenericOpenAPIErrorWithBody(localVarHTTPResponse.Status, localVarBody)
		if localVarHTTPResponse.StatusCode == 400 {
			var v AccessCodesDeleteAccessCodes400Response
			err = a.Client.Decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr = internal.NewGenericOpenAPIErrorWithBody(err.Error(), localVarBody)
				return localVarHTTPResponse, newErr
			}
			newErr = internal.NewGenericOpenAPIErrorWithBodyAndModel(localVarHTTPResponse.Status, localVarBody, v)
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v AccessCodesListAccessCodes500Response
			err = a.Client.Decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr = internal.NewGenericOpenAPIErrorWithBody(err.Error(), localVarBody)
				return localVarHTTPResponse, newErr
			}
			newErr = internal.NewGenericOpenAPIErrorWithBodyAndModel(localVarHTTPResponse.Status, localVarBody, v)
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSecurityPoliciesDeleteSingleSecurityPolicyRequest struct {
	ctx        context.Context
	ApiService SecurityPoliciesAPI
	id         int32
}

func (r ApiSecurityPoliciesDeleteSingleSecurityPolicyRequest) Execute() (*http.Response, error) {
	return r.ApiService.SecurityPoliciesDeleteSingleSecurityPolicyExecute(r)
}

/*
SecurityPoliciesDeleteSingleSecurityPolicy Delete Security Policy.

Use this method to delete Security Policy object by given Security Policy object id.

A security policy defines a set of rules and actions that you define to balance access and constraints so you can mitigate malicious attacks and provide security for your networks. When you create a new security policy, you first define a network scope to which you add networks, DNS forwarding proxies, and BloxOne Endpoint groups. BloxOne Cloud applies the security policy to all the entities that you include in the network scope. You can also include DNS forwarding proxies to which you want to apply the security policy.  After you define the network scope, you can add custom lists and category filters to the security policy. You can also specify actions for the added lists and filters, and to determine the precedence order for the entities. Depending on your subscription level, each security policy also comes with a set of predefined threat intelligence feeds and Threat Insight rules that are inherited from the default global policy. You cannot delete the inherited feeds and rules, but you can change their precedence order. For each policy you can define policy-level action (Default Action) gets applied when none of the policy rules apply/match. If an user really needs access to some blocked domain (web page) via a browser - there is a possibility to assign special bypass code(s) (Bypass Code) to any policy.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The Security Policy object identifiers.
	@return ApiSecurityPoliciesDeleteSingleSecurityPolicyRequest
*/
func (a *SecurityPoliciesAPIService) SecurityPoliciesDeleteSingleSecurityPolicy(ctx context.Context, id int32) ApiSecurityPoliciesDeleteSingleSecurityPolicyRequest {
	return ApiSecurityPoliciesDeleteSingleSecurityPolicyRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
func (a *SecurityPoliciesAPIService) SecurityPoliciesDeleteSingleSecurityPolicyExecute(r ApiSecurityPoliciesDeleteSingleSecurityPolicyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []internal.FormFile
	)

	localBasePath, err := a.Client.Cfg.ServerURLWithContext(r.ctx, "SecurityPoliciesAPIService.SecurityPoliciesDeleteSingleSecurityPolicy")
	if err != nil {
		return nil, internal.NewGenericOpenAPIError(err.Error())
	}

	localVarPath := localBasePath + "/security_policies/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(internal.ParameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := internal.SelectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := internal.SelectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.Client.PrepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.Client.CallAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := internal.NewGenericOpenAPIErrorWithBody(localVarHTTPResponse.Status, localVarBody)
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApplicationFiltersDeleteSingleApplicationFilters400Response
			err = a.Client.Decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr = internal.NewGenericOpenAPIErrorWithBody(err.Error(), localVarBody)
				return localVarHTTPResponse, newErr
			}
			newErr = internal.NewGenericOpenAPIErrorWithBodyAndModel(localVarHTTPResponse.Status, localVarBody, v)
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v AccessCodesListAccessCodes500Response
			err = a.Client.Decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr = internal.NewGenericOpenAPIErrorWithBody(err.Error(), localVarBody)
				return localVarHTTPResponse, newErr
			}
			newErr = internal.NewGenericOpenAPIErrorWithBodyAndModel(localVarHTTPResponse.Status, localVarBody, v)
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSecurityPoliciesListSecurityPoliciesRequest struct {
	ctx                context.Context
	ApiService         SecurityPoliciesAPI
	filter             *string
	fields             *string
	includeAccessCodes *bool
	offset             *int32
	limit              *int32
	pageToken          *string
	tfilter            *string
	torderBy           *string
}

// A collection of response resources can be filtered by a logical expression string that includes JSON tag references to values in each resource, literal values, and logical operators. If a resource does not have the specified tag, its value is assumed to be null.  Literal values include numbers (integer and floating-point), and quoted (both single- or double-quoted) literal strings, and &#39;null&#39;.  You can filter by following fields:  | Name               | type   | Supported Op                | | ------------------ | ------ | --------------------------- | | id                 | int32  | !&#x3D;, &#x3D;&#x3D;, &gt;, &lt;, &lt;&#x3D;, &gt;&#x3D;        | | name               | string | !&#x3D;, &#x3D;&#x3D;, ~, !~, &gt;, &lt;, &lt;&#x3D;, &gt;&#x3D; | | description        | string | !&#x3D;, &#x3D;&#x3D;, ~, !~, &gt;, &lt;, &lt;&#x3D;, &gt;&#x3D; | | is_default         | bool   | !&#x3D;, &#x3D;&#x3D;                      |  In addition grouping operators are supported:  | Op  | Description          | | --- | -------------------- | | and | Logical AND          | | or  | Logical OR           | | not | Logical NOT          | | ()  | Groupping Operators  |  Example: &#x60;&#x60;&#x60; ?_filter&#x3D;\&quot;((name&#x3D;&#x3D;&#39;sec_policy_a&#39;)or(name~&#39;policy_b&#39;))and(is_default!&#x3D;&#39;true&#39;)\&quot; &#x60;&#x60;&#x60;
func (r ApiSecurityPoliciesListSecurityPoliciesRequest) Filter(filter string) ApiSecurityPoliciesListSecurityPoliciesRequest {
	r.filter = &filter
	return r
}

// A collection of response resources can be transformed by specifying a set of JSON tags to be returned. For a “flat” resource, the tag name is straightforward. If field selection is allowed on non-flat hierarchical resources, the service should implement a qualified naming scheme such as dot-qualification to reference data down the hierarchy. If a resource does not have the specified tag, the tag does not appear in the output resource.  Specify this parameter as a comma-separated list of JSON tag names.
func (r ApiSecurityPoliciesListSecurityPoliciesRequest) Fields(fields string) ApiSecurityPoliciesListSecurityPoliciesRequest {
	r.fields = &fields
	return r
}

func (r ApiSecurityPoliciesListSecurityPoliciesRequest) IncludeAccessCodes(includeAccessCodes bool) ApiSecurityPoliciesListSecurityPoliciesRequest {
	r.includeAccessCodes = &includeAccessCodes
	return r
}

// The integer index (zero-origin) of the offset into a collection of resources. If omitted or null the value is assumed to be &#39;0&#39;.
func (r ApiSecurityPoliciesListSecurityPoliciesRequest) Offset(offset int32) ApiSecurityPoliciesListSecurityPoliciesRequest {
	r.offset = &offset
	return r
}

// The integer number of resources to be returned in the response. The service may impose maximum value. If omitted the service may impose a default value.
func (r ApiSecurityPoliciesListSecurityPoliciesRequest) Limit(limit int32) ApiSecurityPoliciesListSecurityPoliciesRequest {
	r.limit = &limit
	return r
}

// The service-defined string used to identify a page of resources. A null value indicates the first page.
func (r ApiSecurityPoliciesListSecurityPoliciesRequest) PageToken(pageToken string) ApiSecurityPoliciesListSecurityPoliciesRequest {
	r.pageToken = &pageToken
	return r
}

// Filtering by tags.
func (r ApiSecurityPoliciesListSecurityPoliciesRequest) Tfilter(tfilter string) ApiSecurityPoliciesListSecurityPoliciesRequest {
	r.tfilter = &tfilter
	return r
}

// Sorting by tags.
func (r ApiSecurityPoliciesListSecurityPoliciesRequest) TorderBy(torderBy string) ApiSecurityPoliciesListSecurityPoliciesRequest {
	r.torderBy = &torderBy
	return r
}

func (r ApiSecurityPoliciesListSecurityPoliciesRequest) Execute() (*AtcfwSecurityPolicyMultiResponse, *http.Response, error) {
	return r.ApiService.SecurityPoliciesListSecurityPoliciesExecute(r)
}

/*
SecurityPoliciesListSecurityPolicies List Security Policies.

Use this method to retrieve information on all Security Policy objects for the account.

A security policy defines a set of rules and actions that you define to balance access and constraints so you can mitigate malicious attacks and provide security for your networks. When you create a new security policy, you first define a network scope to which you add networks, DNS forwarding proxies, and BloxOne Endpoint groups. BloxOne Cloud applies the security policy to all the entities that you include in the network scope. You can also include DNS forwarding proxies to which you want to apply the security policy.  After you define the network scope, you can add custom lists and category filters to the security policy. You can also specify actions for the added lists and filters, and to determine the precedence order for the entities. Depending on your subscription level, each security policy also comes with a set of predefined threat intelligence feeds and Threat Insight rules that are inherited from the default global policy. You cannot delete the inherited feeds and rules, but you can change their precedence order. For each policy you can define policy-level action (Default Action) gets applied when none of the policy rules apply/match. If an user really needs access to some blocked domain (web page) via a browser - there is a possibility to assign special bypass code(s) (Bypass Code) to any policy.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSecurityPoliciesListSecurityPoliciesRequest
*/
func (a *SecurityPoliciesAPIService) SecurityPoliciesListSecurityPolicies(ctx context.Context) ApiSecurityPoliciesListSecurityPoliciesRequest {
	return ApiSecurityPoliciesListSecurityPoliciesRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return AtcfwSecurityPolicyMultiResponse
func (a *SecurityPoliciesAPIService) SecurityPoliciesListSecurityPoliciesExecute(r ApiSecurityPoliciesListSecurityPoliciesRequest) (*AtcfwSecurityPolicyMultiResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []internal.FormFile
		localVarReturnValue *AtcfwSecurityPolicyMultiResponse
	)

	localBasePath, err := a.Client.Cfg.ServerURLWithContext(r.ctx, "SecurityPoliciesAPIService.SecurityPoliciesListSecurityPolicies")
	if err != nil {
		return localVarReturnValue, nil, internal.NewGenericOpenAPIError(err.Error())
	}

	localVarPath := localBasePath + "/security_policies"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filter != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "_filter", r.filter, "")
	}
	if r.fields != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "_fields", r.fields, "")
	}
	if r.includeAccessCodes != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "include_access_codes", r.includeAccessCodes, "")
	}
	if r.offset != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "_offset", r.offset, "")
	}
	if r.limit != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "_limit", r.limit, "")
	}
	if r.pageToken != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "_page_token", r.pageToken, "")
	}
	if r.tfilter != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "_tfilter", r.tfilter, "")
	}
	if r.torderBy != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "_torder_by", r.torderBy, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := internal.SelectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := internal.SelectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.Client.PrepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.Client.CallAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := internal.NewGenericOpenAPIErrorWithBody(localVarHTTPResponse.Status, localVarBody)
		if localVarHTTPResponse.StatusCode == 500 {
			var v AccessCodesListAccessCodes500Response
			err = a.Client.Decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr = internal.NewGenericOpenAPIErrorWithBody(err.Error(), localVarBody)
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr = internal.NewGenericOpenAPIErrorWithBodyAndModel(localVarHTTPResponse.Status, localVarBody, v)
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.Client.Decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := internal.NewGenericOpenAPIErrorWithBody(err.Error(), localVarBody)
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSecurityPoliciesReadSecurityPolicyRequest struct {
	ctx        context.Context
	ApiService SecurityPoliciesAPI
	id         int32
	fields     *string
	name       *string
}

// A collection of response resources can be transformed by specifying a set of JSON tags to be returned. For a “flat” resource, the tag name is straightforward. If field selection is allowed on non-flat hierarchical resources, the service should implement a qualified naming scheme such as dot-qualification to reference data down the hierarchy. If a resource does not have the specified tag, the tag does not appear in the output resource.  Specify this parameter as a comma-separated list of JSON tag names.
func (r ApiSecurityPoliciesReadSecurityPolicyRequest) Fields(fields string) ApiSecurityPoliciesReadSecurityPolicyRequest {
	r.fields = &fields
	return r
}

func (r ApiSecurityPoliciesReadSecurityPolicyRequest) Name(name string) ApiSecurityPoliciesReadSecurityPolicyRequest {
	r.name = &name
	return r
}

func (r ApiSecurityPoliciesReadSecurityPolicyRequest) Execute() (*AtcfwSecurityPolicyReadResponse, *http.Response, error) {
	return r.ApiService.SecurityPoliciesReadSecurityPolicyExecute(r)
}

/*
SecurityPoliciesReadSecurityPolicy Read Security Policy.

Use this method to retrieve information on the specified Security Policy object.

A security policy defines a set of rules and actions that you define to balance access and constraints so you can mitigate malicious attacks and provide security for your networks. When you create a new security policy, you first define a network scope to which you add networks, DNS forwarding proxies, and BloxOne Endpoint groups. BloxOne Cloud applies the security policy to all the entities that you include in the network scope. You can also include DNS forwarding proxies to which you want to apply the security policy.  After you define the network scope, you can add custom lists and category filters to the security policy. You can also specify actions for the added lists and filters, and to determine the precedence order for the entities. Depending on your subscription level, each security policy also comes with a set of predefined threat intelligence feeds and Threat Insight rules that are inherited from the default global policy. You cannot delete the inherited feeds and rules, but you can change their precedence order. For each policy you can define policy-level action (Default Action) gets applied when none of the policy rules apply/match. If an user really needs access to some blocked domain (web page) via a browser - there is a possibility to assign special bypass code(s) (Bypass Code) to any policy.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The Security Policy object identifier.
	@return ApiSecurityPoliciesReadSecurityPolicyRequest
*/
func (a *SecurityPoliciesAPIService) SecurityPoliciesReadSecurityPolicy(ctx context.Context, id int32) ApiSecurityPoliciesReadSecurityPolicyRequest {
	return ApiSecurityPoliciesReadSecurityPolicyRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return AtcfwSecurityPolicyReadResponse
func (a *SecurityPoliciesAPIService) SecurityPoliciesReadSecurityPolicyExecute(r ApiSecurityPoliciesReadSecurityPolicyRequest) (*AtcfwSecurityPolicyReadResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []internal.FormFile
		localVarReturnValue *AtcfwSecurityPolicyReadResponse
	)

	localBasePath, err := a.Client.Cfg.ServerURLWithContext(r.ctx, "SecurityPoliciesAPIService.SecurityPoliciesReadSecurityPolicy")
	if err != nil {
		return localVarReturnValue, nil, internal.NewGenericOpenAPIError(err.Error())
	}

	localVarPath := localBasePath + "/security_policies/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(internal.ParameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "_fields", r.fields, "")
	}
	if r.name != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := internal.SelectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := internal.SelectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.Client.PrepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.Client.CallAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := internal.NewGenericOpenAPIErrorWithBody(localVarHTTPResponse.Status, localVarBody)
		if localVarHTTPResponse.StatusCode == 404 {
			var v SecurityPoliciesReadSecurityPolicy404Response
			err = a.Client.Decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr = internal.NewGenericOpenAPIErrorWithBody(err.Error(), localVarBody)
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr = internal.NewGenericOpenAPIErrorWithBodyAndModel(localVarHTTPResponse.Status, localVarBody, v)
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v AccessCodesListAccessCodes500Response
			err = a.Client.Decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr = internal.NewGenericOpenAPIErrorWithBody(err.Error(), localVarBody)
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr = internal.NewGenericOpenAPIErrorWithBodyAndModel(localVarHTTPResponse.Status, localVarBody, v)
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.Client.Decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := internal.NewGenericOpenAPIErrorWithBody(err.Error(), localVarBody)
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSecurityPoliciesUpdateSecurityPolicyRequest struct {
	ctx        context.Context
	ApiService SecurityPoliciesAPI
	id         int32
	body       *AtcfwSecurityPolicy
}

// The Security Policy object.
func (r ApiSecurityPoliciesUpdateSecurityPolicyRequest) Body(body AtcfwSecurityPolicy) ApiSecurityPoliciesUpdateSecurityPolicyRequest {
	r.body = &body
	return r
}

func (r ApiSecurityPoliciesUpdateSecurityPolicyRequest) Execute() (*AtcfwSecurityPolicyUpdateResponse, *http.Response, error) {
	return r.ApiService.SecurityPoliciesUpdateSecurityPolicyExecute(r)
}

/*
SecurityPoliciesUpdateSecurityPolicy Update Security Policy.

Use this method to update a specified Network List object. The policy data supplied with the update request must have the complete list of policy rules, including the rules based on all feeds that the account is entitled to. If no network list is specified, networking scope for this policy is empty, thus no action can be performed by this policy. Note that you are not allowed to add DNS Forwarding Proxies and Roaming Device Groups that are already assigned to a Security Policy different from "Default Global Policy", to assign them to this Security Policy object you should remove them from other Security Policy first.

A security policy defines a set of rules and actions that you define to balance access and constraints so you can mitigate malicious attacks and provide security for your networks. When you create a new security policy, you first define a network scope to which you add networks, DNS forwarding proxies, and BloxOne Endpoint groups. BloxOne Cloud applies the security policy to all the entities that you include in the network scope. You can also include DNS forwarding proxies to which you want to apply the security policy.  After you define the network scope, you can add custom lists and category filters to the security policy. You can also specify actions for the added lists and filters, and to determine the precedence order for the entities. Depending on your subscription level, each security policy also comes with a set of predefined threat intelligence feeds and Threat Insight rules that are inherited from the default global policy. You cannot delete the inherited feeds and rules, but you can change their precedence order. For each policy you can define policy-level action (Default Action) gets applied when none of the policy rules apply/match. If an user really needs access to some blocked domain (web page) via a browser - there is a possibility to assign special bypass code(s) (Bypass Code) to any policy.

Required:
- name
- rules
- dfps
- network_lists
- roaming_device_groups

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The Security Policy object identifier.
	@return ApiSecurityPoliciesUpdateSecurityPolicyRequest
*/
func (a *SecurityPoliciesAPIService) SecurityPoliciesUpdateSecurityPolicy(ctx context.Context, id int32) ApiSecurityPoliciesUpdateSecurityPolicyRequest {
	return ApiSecurityPoliciesUpdateSecurityPolicyRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return AtcfwSecurityPolicyUpdateResponse
func (a *SecurityPoliciesAPIService) SecurityPoliciesUpdateSecurityPolicyExecute(r ApiSecurityPoliciesUpdateSecurityPolicyRequest) (*AtcfwSecurityPolicyUpdateResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []internal.FormFile
		localVarReturnValue *AtcfwSecurityPolicyUpdateResponse
	)

	localBasePath, err := a.Client.Cfg.ServerURLWithContext(r.ctx, "SecurityPoliciesAPIService.SecurityPoliciesUpdateSecurityPolicy")
	if err != nil {
		return localVarReturnValue, nil, internal.NewGenericOpenAPIError(err.Error())
	}

	localVarPath := localBasePath + "/security_policies/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(internal.ParameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, internal.ReportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := internal.SelectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := internal.SelectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.Client.PrepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.Client.CallAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := internal.NewGenericOpenAPIErrorWithBody(localVarHTTPResponse.Status, localVarBody)
		if localVarHTTPResponse.StatusCode == 400 {
			var v SecurityPoliciesCreateSecurityPolicy400Response
			err = a.Client.Decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr = internal.NewGenericOpenAPIErrorWithBody(err.Error(), localVarBody)
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr = internal.NewGenericOpenAPIErrorWithBodyAndModel(localVarHTTPResponse.Status, localVarBody, v)
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v AccessCodesCreateAccessCode404Response
			err = a.Client.Decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr = internal.NewGenericOpenAPIErrorWithBody(err.Error(), localVarBody)
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr = internal.NewGenericOpenAPIErrorWithBodyAndModel(localVarHTTPResponse.Status, localVarBody, v)
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v SecurityPoliciesCreateSecurityPolicy409Response
			err = a.Client.Decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr = internal.NewGenericOpenAPIErrorWithBody(err.Error(), localVarBody)
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr = internal.NewGenericOpenAPIErrorWithBodyAndModel(localVarHTTPResponse.Status, localVarBody, v)
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v AccessCodesListAccessCodes500Response
			err = a.Client.Decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr = internal.NewGenericOpenAPIErrorWithBody(err.Error(), localVarBody)
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr = internal.NewGenericOpenAPIErrorWithBodyAndModel(localVarHTTPResponse.Status, localVarBody, v)
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.Client.Decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := internal.NewGenericOpenAPIErrorWithBody(err.Error(), localVarBody)
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	return localVarReturnValue, localVarHTTPResponse, nil
}
