/*
BloxOne FW API

BloxOne Threat Defense Cloud is an extension of the BloxOne Suite that provides visibility into infected and compromised off-premises devices, roaming users, remote sites, and branch offices. You can subscribe to BloxOne Cloud and use its functionality to mitigate and control malware as well as provide unprecedented insight into your network security posture and enable timely action. BloxOne Cloud also offers unified policy management, reporting, and threat analytics across the entire spectrum. Using automated and high-quality threat intelligence feeds and unique behavioral analytics, it automatically stops device communications with C&Cs/botnets and prevents DNS based data exfiltration.  The mission-critical DNS infrastructure can become a vulnerable component in your network when it is inadequately protected by traditional security solutions and consequently used as an attack surface. Compromised DNS services can result in catastrophic network and system failures. To fully protect your network in todayâ€™s cyber security threat environment, Infoblox sets a new DNS security standard by offering scalable, enterprise-grade, and integrated protection for your DNS infrastructure.  Through the Infoblox Cloud Services Portal, you can view the status of your subscription and threat intelligence feeds, manage your network scope and roaming end users, and learn more about threats on your networks through the Infoblox Threat Lookup tool and predefined reports.

API version: v1
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package fw

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/infobloxopen/bloxone-go-client/internal"
)

type AccessCodesAPI interface {
	/*
			CreateAccessCode Create Access Codes

			Use this method to create the Bypass Code corresponding to the
		security rules passed.
		It's an atomic operation. It should create all the security rules
		and create the policy and bypass codes, or do nothing if any of them fails.

		Required:
		- name
		- rules
		- activation
		- expiration





			@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			@return AccessCodesAPICreateAccessCodeRequest
	*/
	CreateAccessCode(ctx context.Context) AccessCodesAPICreateAccessCodeRequest

	// CreateAccessCodeExecute executes the request
	//  @return AccessCodeCreateResponse
	CreateAccessCodeExecute(r AccessCodesAPICreateAccessCodeRequest) (*AccessCodeCreateResponse, *http.Response, error)
	/*
			DeleteAccessCodes Delete Access Codes

			Use this method to delete Bypass Code objects. Deletion of
		multiple bypass codes is an all-or-nothing operation (if any of
		the specified bypass codes cannot be deleted then none of the
		specified bypass codes will be deleted).

		Required:
		- ids



			@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			@return AccessCodesAPIDeleteAccessCodesRequest
	*/
	DeleteAccessCodes(ctx context.Context) AccessCodesAPIDeleteAccessCodesRequest

	// DeleteAccessCodesExecute executes the request
	DeleteAccessCodesExecute(r AccessCodesAPIDeleteAccessCodesRequest) (*http.Response, error)
	/*
		DeleteSingleAccessCodes Delete Access Code By ID

		Use this method to delete Bypass Code object.



		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param accessKey The Bypass Code identifier.
		@return AccessCodesAPIDeleteSingleAccessCodesRequest
	*/
	DeleteSingleAccessCodes(ctx context.Context, accessKey string) AccessCodesAPIDeleteSingleAccessCodesRequest

	// DeleteSingleAccessCodesExecute executes the request
	DeleteSingleAccessCodesExecute(r AccessCodesAPIDeleteSingleAccessCodesRequest) (*http.Response, error)
	/*
		ListAccessCodes List Access Codes

		Use this method to retrieve a collection of Bypass Code objects.



		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return AccessCodesAPIListAccessCodesRequest
	*/
	ListAccessCodes(ctx context.Context) AccessCodesAPIListAccessCodesRequest

	// ListAccessCodesExecute executes the request
	//  @return AccessCodeMultiResponse
	ListAccessCodesExecute(r AccessCodesAPIListAccessCodesRequest) (*AccessCodeMultiResponse, *http.Response, error)
	/*
		ReadAccessCode Read Access Codes

		Use this method to retrieve the Bypass Code by key.



		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param accessKey The Bypass Code identifier.
		@return AccessCodesAPIReadAccessCodeRequest
	*/
	ReadAccessCode(ctx context.Context, accessKey string) AccessCodesAPIReadAccessCodeRequest

	// ReadAccessCodeExecute executes the request
	//  @return AccessCodeReadResponse
	ReadAccessCodeExecute(r AccessCodesAPIReadAccessCodeRequest) (*AccessCodeReadResponse, *http.Response, error)
	/*
			UpdateAccessCode Update Access Codes

			Use this method to update the Bypass Code corresponding to the security rules passed.
		It's an atomic operation. It should delete existing security rules and
		create all the new security rules for the bypass code,
		or do nothing if any of them fails.

		Required:
		- name
		- rules
		- dfps
		- network_lists
		- roaming_device_groups





			@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			@param payloadAccessKey Auto generated unique Bypass Code value
			@return AccessCodesAPIUpdateAccessCodeRequest
	*/
	UpdateAccessCode(ctx context.Context, payloadAccessKey string) AccessCodesAPIUpdateAccessCodeRequest

	// UpdateAccessCodeExecute executes the request
	//  @return AccessCodeUpdateResponse
	UpdateAccessCodeExecute(r AccessCodesAPIUpdateAccessCodeRequest) (*AccessCodeUpdateResponse, *http.Response, error)
}

// AccessCodesAPIService AccessCodesAPI service
type AccessCodesAPIService internal.Service

type AccessCodesAPICreateAccessCodeRequest struct {
	ctx        context.Context
	ApiService AccessCodesAPI
	body       *AccessCode
}

// The Bypass Code object.
func (r AccessCodesAPICreateAccessCodeRequest) Body(body AccessCode) AccessCodesAPICreateAccessCodeRequest {
	r.body = &body
	return r
}

func (r AccessCodesAPICreateAccessCodeRequest) Execute() (*AccessCodeCreateResponse, *http.Response, error) {
	return r.ApiService.CreateAccessCodeExecute(r)
}

/*
CreateAccessCode Create Access Codes

Use this method to create the Bypass Code corresponding to the
security rules passed.
It's an atomic operation. It should create all the security rules
and create the policy and bypass codes, or do nothing if any of them fails.

Required:
- name
- rules
- activation
- expiration

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return AccessCodesAPICreateAccessCodeRequest
*/
func (a *AccessCodesAPIService) CreateAccessCode(ctx context.Context) AccessCodesAPICreateAccessCodeRequest {
	return AccessCodesAPICreateAccessCodeRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return AccessCodeCreateResponse
func (a *AccessCodesAPIService) CreateAccessCodeExecute(r AccessCodesAPICreateAccessCodeRequest) (*AccessCodeCreateResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []internal.FormFile
		localVarReturnValue *AccessCodeCreateResponse
	)

	localBasePath, err := a.Client.Cfg.ServerURLWithContext(r.ctx, "AccessCodesAPIService.CreateAccessCode")
	if err != nil {
		return localVarReturnValue, nil, internal.NewGenericOpenAPIError(err.Error())
	}

	localVarPath := localBasePath + "/access_codes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, internal.ReportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := internal.SelectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := internal.SelectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.Client.PrepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.Client.CallAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := internal.NewGenericOpenAPIErrorWithBody(localVarHTTPResponse.Status, localVarBody)
		if localVarHTTPResponse.StatusCode == 400 {
			var v AccessCodesCreateAccessCode400Response
			err = a.Client.Decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr = internal.NewGenericOpenAPIErrorWithBody(err.Error(), localVarBody)
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr = internal.NewGenericOpenAPIErrorWithBodyAndModel(localVarHTTPResponse.Status, localVarBody, v)
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v AccessCodesCreateAccessCode404Response
			err = a.Client.Decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr = internal.NewGenericOpenAPIErrorWithBody(err.Error(), localVarBody)
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr = internal.NewGenericOpenAPIErrorWithBodyAndModel(localVarHTTPResponse.Status, localVarBody, v)
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v AccessCodesCreateAccessCode409Response
			err = a.Client.Decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr = internal.NewGenericOpenAPIErrorWithBody(err.Error(), localVarBody)
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr = internal.NewGenericOpenAPIErrorWithBodyAndModel(localVarHTTPResponse.Status, localVarBody, v)
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v AccessCodesListAccessCodes500Response
			err = a.Client.Decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr = internal.NewGenericOpenAPIErrorWithBody(err.Error(), localVarBody)
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr = internal.NewGenericOpenAPIErrorWithBodyAndModel(localVarHTTPResponse.Status, localVarBody, v)
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.Client.Decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := internal.NewGenericOpenAPIErrorWithBody(err.Error(), localVarBody)
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	return localVarReturnValue, localVarHTTPResponse, nil
}

type AccessCodesAPIDeleteAccessCodesRequest struct {
	ctx        context.Context
	ApiService AccessCodesAPI
	body       *AccessCodeDeleteRequest
}

func (r AccessCodesAPIDeleteAccessCodesRequest) Body(body AccessCodeDeleteRequest) AccessCodesAPIDeleteAccessCodesRequest {
	r.body = &body
	return r
}

func (r AccessCodesAPIDeleteAccessCodesRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteAccessCodesExecute(r)
}

/*
DeleteAccessCodes Delete Access Codes

Use this method to delete Bypass Code objects. Deletion of
multiple bypass codes is an all-or-nothing operation (if any of
the specified bypass codes cannot be deleted then none of the
specified bypass codes will be deleted).

Required:
- ids

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return AccessCodesAPIDeleteAccessCodesRequest
*/
func (a *AccessCodesAPIService) DeleteAccessCodes(ctx context.Context) AccessCodesAPIDeleteAccessCodesRequest {
	return AccessCodesAPIDeleteAccessCodesRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *AccessCodesAPIService) DeleteAccessCodesExecute(r AccessCodesAPIDeleteAccessCodesRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []internal.FormFile
	)

	localBasePath, err := a.Client.Cfg.ServerURLWithContext(r.ctx, "AccessCodesAPIService.DeleteAccessCodes")
	if err != nil {
		return nil, internal.NewGenericOpenAPIError(err.Error())
	}

	localVarPath := localBasePath + "/access_codes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, internal.ReportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := internal.SelectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := internal.SelectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.Client.PrepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.Client.CallAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := internal.NewGenericOpenAPIErrorWithBody(localVarHTTPResponse.Status, localVarBody)
		if localVarHTTPResponse.StatusCode == 400 {
			var v AccessCodesDeleteAccessCodes400Response
			err = a.Client.Decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr = internal.NewGenericOpenAPIErrorWithBody(err.Error(), localVarBody)
				return localVarHTTPResponse, newErr
			}
			newErr = internal.NewGenericOpenAPIErrorWithBodyAndModel(localVarHTTPResponse.Status, localVarBody, v)
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v AccessCodesListAccessCodes500Response
			err = a.Client.Decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr = internal.NewGenericOpenAPIErrorWithBody(err.Error(), localVarBody)
				return localVarHTTPResponse, newErr
			}
			newErr = internal.NewGenericOpenAPIErrorWithBodyAndModel(localVarHTTPResponse.Status, localVarBody, v)
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type AccessCodesAPIDeleteSingleAccessCodesRequest struct {
	ctx        context.Context
	ApiService AccessCodesAPI
	accessKey  string
}

func (r AccessCodesAPIDeleteSingleAccessCodesRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteSingleAccessCodesExecute(r)
}

/*
DeleteSingleAccessCodes Delete Access Code By ID

Use this method to delete Bypass Code object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param accessKey The Bypass Code identifier.
	@return AccessCodesAPIDeleteSingleAccessCodesRequest
*/
func (a *AccessCodesAPIService) DeleteSingleAccessCodes(ctx context.Context, accessKey string) AccessCodesAPIDeleteSingleAccessCodesRequest {
	return AccessCodesAPIDeleteSingleAccessCodesRequest{
		ApiService: a,
		ctx:        ctx,
		accessKey:  accessKey,
	}
}

// Execute executes the request
func (a *AccessCodesAPIService) DeleteSingleAccessCodesExecute(r AccessCodesAPIDeleteSingleAccessCodesRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []internal.FormFile
	)

	localBasePath, err := a.Client.Cfg.ServerURLWithContext(r.ctx, "AccessCodesAPIService.DeleteSingleAccessCodes")
	if err != nil {
		return nil, internal.NewGenericOpenAPIError(err.Error())
	}

	localVarPath := localBasePath + "/access_codes/{access_key}"
	localVarPath = strings.Replace(localVarPath, "{"+"access_key"+"}", url.PathEscape(internal.ParameterValueToString(r.accessKey, "accessKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := internal.SelectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := internal.SelectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.Client.PrepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.Client.CallAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := internal.NewGenericOpenAPIErrorWithBody(localVarHTTPResponse.Status, localVarBody)
		if localVarHTTPResponse.StatusCode == 400 {
			var v AccessCodesDeleteSingleAccessCodes400Response
			err = a.Client.Decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr = internal.NewGenericOpenAPIErrorWithBody(err.Error(), localVarBody)
				return localVarHTTPResponse, newErr
			}
			newErr = internal.NewGenericOpenAPIErrorWithBodyAndModel(localVarHTTPResponse.Status, localVarBody, v)
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v AccessCodesListAccessCodes500Response
			err = a.Client.Decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr = internal.NewGenericOpenAPIErrorWithBody(err.Error(), localVarBody)
				return localVarHTTPResponse, newErr
			}
			newErr = internal.NewGenericOpenAPIErrorWithBodyAndModel(localVarHTTPResponse.Status, localVarBody, v)
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type AccessCodesAPIListAccessCodesRequest struct {
	ctx        context.Context
	ApiService AccessCodesAPI
	filter     *string
	offset     *int32
	limit      *int32
	pageToken  *string
}

// A collection of response resources can be filtered by a logical expression string that includes JSON tag references to values in each resource, literal values, and logical operators. If a resource does not have the specified tag, its value is assumed to be null.  Literal values include numbers (integer and floating-point), and quoted (both single- or double-quoted) literal strings, and &#39;null&#39;.  You can filter by following fields:  | Name               | type   | Supported Op                | | ------------------ | ------ | --------------------------- | | access_key         | string | !&#x3D;, &#x3D;&#x3D;, ~, !~, &gt;, &lt;, &lt;&#x3D;, &gt;&#x3D; | | name               | string | !&#x3D;, &#x3D;&#x3D;, ~, !~, &gt;, &lt;, &lt;&#x3D;, &gt;&#x3D; | | description        | string | !&#x3D;, &#x3D;&#x3D;, ~, !~, &gt;, &lt;, &lt;&#x3D;, &gt;&#x3D; | | security_policy_id | int32  | !&#x3D;, &#x3D;&#x3D;, &gt;, &lt;, &lt;&#x3D;, &gt;&#x3D;        |  In addition, grouping operators are supported:  | Op  | Description          | | --- | -------------------- | | and | Logical AND          | | or  | Logical OR           | | not | Logical NOT          | | ()  | Groupping Operators  |  Example: &#x60;&#x60;&#x60; ?_filter&#x3D;\&quot;((name&#x3D;&#x3D;&#39;acc_code&#39;)or(name~&#39;key&#39;))and(security_policy_id!&#x3D;32)\&quot; &#x60;&#x60;&#x60;
func (r AccessCodesAPIListAccessCodesRequest) Filter(filter string) AccessCodesAPIListAccessCodesRequest {
	r.filter = &filter
	return r
}

// The integer index (zero-origin) of the offset into a collection of resources. If omitted or null the value is assumed to be &#39;0&#39;.
func (r AccessCodesAPIListAccessCodesRequest) Offset(offset int32) AccessCodesAPIListAccessCodesRequest {
	r.offset = &offset
	return r
}

// The integer number of resources to be returned in the response. The service may impose maximum value. If omitted the service may impose a default value.
func (r AccessCodesAPIListAccessCodesRequest) Limit(limit int32) AccessCodesAPIListAccessCodesRequest {
	r.limit = &limit
	return r
}

// The service-defined string used to identify a page of resources. A null value indicates the first page.
func (r AccessCodesAPIListAccessCodesRequest) PageToken(pageToken string) AccessCodesAPIListAccessCodesRequest {
	r.pageToken = &pageToken
	return r
}

func (r AccessCodesAPIListAccessCodesRequest) Execute() (*AccessCodeMultiResponse, *http.Response, error) {
	return r.ApiService.ListAccessCodesExecute(r)
}

/*
ListAccessCodes List Access Codes

Use this method to retrieve a collection of Bypass Code objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return AccessCodesAPIListAccessCodesRequest
*/
func (a *AccessCodesAPIService) ListAccessCodes(ctx context.Context) AccessCodesAPIListAccessCodesRequest {
	return AccessCodesAPIListAccessCodesRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return AccessCodeMultiResponse
func (a *AccessCodesAPIService) ListAccessCodesExecute(r AccessCodesAPIListAccessCodesRequest) (*AccessCodeMultiResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []internal.FormFile
		localVarReturnValue *AccessCodeMultiResponse
	)

	localBasePath, err := a.Client.Cfg.ServerURLWithContext(r.ctx, "AccessCodesAPIService.ListAccessCodes")
	if err != nil {
		return localVarReturnValue, nil, internal.NewGenericOpenAPIError(err.Error())
	}

	localVarPath := localBasePath + "/access_codes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filter != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "_filter", r.filter, "")
	}
	if r.offset != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "_offset", r.offset, "")
	}
	if r.limit != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "_limit", r.limit, "")
	}
	if r.pageToken != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "_page_token", r.pageToken, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := internal.SelectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := internal.SelectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.Client.PrepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.Client.CallAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := internal.NewGenericOpenAPIErrorWithBody(localVarHTTPResponse.Status, localVarBody)
		if localVarHTTPResponse.StatusCode == 500 {
			var v AccessCodesListAccessCodes500Response
			err = a.Client.Decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr = internal.NewGenericOpenAPIErrorWithBody(err.Error(), localVarBody)
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr = internal.NewGenericOpenAPIErrorWithBodyAndModel(localVarHTTPResponse.Status, localVarBody, v)
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.Client.Decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := internal.NewGenericOpenAPIErrorWithBody(err.Error(), localVarBody)
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	return localVarReturnValue, localVarHTTPResponse, nil
}

type AccessCodesAPIReadAccessCodeRequest struct {
	ctx        context.Context
	ApiService AccessCodesAPI
	accessKey  string
	name       *string
}

// The Bypass Code name.
func (r AccessCodesAPIReadAccessCodeRequest) Name(name string) AccessCodesAPIReadAccessCodeRequest {
	r.name = &name
	return r
}

func (r AccessCodesAPIReadAccessCodeRequest) Execute() (*AccessCodeReadResponse, *http.Response, error) {
	return r.ApiService.ReadAccessCodeExecute(r)
}

/*
ReadAccessCode Read Access Codes

Use this method to retrieve the Bypass Code by key.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param accessKey The Bypass Code identifier.
	@return AccessCodesAPIReadAccessCodeRequest
*/
func (a *AccessCodesAPIService) ReadAccessCode(ctx context.Context, accessKey string) AccessCodesAPIReadAccessCodeRequest {
	return AccessCodesAPIReadAccessCodeRequest{
		ApiService: a,
		ctx:        ctx,
		accessKey:  accessKey,
	}
}

// Execute executes the request
//
//	@return AccessCodeReadResponse
func (a *AccessCodesAPIService) ReadAccessCodeExecute(r AccessCodesAPIReadAccessCodeRequest) (*AccessCodeReadResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []internal.FormFile
		localVarReturnValue *AccessCodeReadResponse
	)

	localBasePath, err := a.Client.Cfg.ServerURLWithContext(r.ctx, "AccessCodesAPIService.ReadAccessCode")
	if err != nil {
		return localVarReturnValue, nil, internal.NewGenericOpenAPIError(err.Error())
	}

	localVarPath := localBasePath + "/access_codes/{access_key}"
	localVarPath = strings.Replace(localVarPath, "{"+"access_key"+"}", url.PathEscape(internal.ParameterValueToString(r.accessKey, "accessKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.name != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := internal.SelectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := internal.SelectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.Client.PrepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.Client.CallAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := internal.NewGenericOpenAPIErrorWithBody(localVarHTTPResponse.Status, localVarBody)
		if localVarHTTPResponse.StatusCode == 404 {
			var v AccessCodesReadAccessCode404Response
			err = a.Client.Decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr = internal.NewGenericOpenAPIErrorWithBody(err.Error(), localVarBody)
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr = internal.NewGenericOpenAPIErrorWithBodyAndModel(localVarHTTPResponse.Status, localVarBody, v)
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v AccessCodesListAccessCodes500Response
			err = a.Client.Decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr = internal.NewGenericOpenAPIErrorWithBody(err.Error(), localVarBody)
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr = internal.NewGenericOpenAPIErrorWithBodyAndModel(localVarHTTPResponse.Status, localVarBody, v)
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.Client.Decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := internal.NewGenericOpenAPIErrorWithBody(err.Error(), localVarBody)
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	return localVarReturnValue, localVarHTTPResponse, nil
}

type AccessCodesAPIUpdateAccessCodeRequest struct {
	ctx              context.Context
	ApiService       AccessCodesAPI
	payloadAccessKey string
	body             *AccessCode
}

// The Bypass Code object.
func (r AccessCodesAPIUpdateAccessCodeRequest) Body(body AccessCode) AccessCodesAPIUpdateAccessCodeRequest {
	r.body = &body
	return r
}

func (r AccessCodesAPIUpdateAccessCodeRequest) Execute() (*AccessCodeUpdateResponse, *http.Response, error) {
	return r.ApiService.UpdateAccessCodeExecute(r)
}

/*
UpdateAccessCode Update Access Codes

Use this method to update the Bypass Code corresponding to the security rules passed.
It's an atomic operation. It should delete existing security rules and
create all the new security rules for the bypass code,
or do nothing if any of them fails.

Required:
- name
- rules
- dfps
- network_lists
- roaming_device_groups

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param payloadAccessKey Auto generated unique Bypass Code value
	@return AccessCodesAPIUpdateAccessCodeRequest
*/
func (a *AccessCodesAPIService) UpdateAccessCode(ctx context.Context, payloadAccessKey string) AccessCodesAPIUpdateAccessCodeRequest {
	return AccessCodesAPIUpdateAccessCodeRequest{
		ApiService:       a,
		ctx:              ctx,
		payloadAccessKey: payloadAccessKey,
	}
}

// Execute executes the request
//
//	@return AccessCodeUpdateResponse
func (a *AccessCodesAPIService) UpdateAccessCodeExecute(r AccessCodesAPIUpdateAccessCodeRequest) (*AccessCodeUpdateResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []internal.FormFile
		localVarReturnValue *AccessCodeUpdateResponse
	)

	localBasePath, err := a.Client.Cfg.ServerURLWithContext(r.ctx, "AccessCodesAPIService.UpdateAccessCode")
	if err != nil {
		return localVarReturnValue, nil, internal.NewGenericOpenAPIError(err.Error())
	}

	localVarPath := localBasePath + "/access_codes/{payload.access_key}"
	localVarPath = strings.Replace(localVarPath, "{"+"payload.access_key"+"}", url.PathEscape(internal.ParameterValueToString(r.payloadAccessKey, "payloadAccessKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, internal.ReportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := internal.SelectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := internal.SelectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.Client.PrepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.Client.CallAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := internal.NewGenericOpenAPIErrorWithBody(localVarHTTPResponse.Status, localVarBody)
		if localVarHTTPResponse.StatusCode == 400 {
			var v AccessCodesCreateAccessCode400Response
			err = a.Client.Decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr = internal.NewGenericOpenAPIErrorWithBody(err.Error(), localVarBody)
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr = internal.NewGenericOpenAPIErrorWithBodyAndModel(localVarHTTPResponse.Status, localVarBody, v)
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v AccessCodesCreateAccessCode404Response
			err = a.Client.Decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr = internal.NewGenericOpenAPIErrorWithBody(err.Error(), localVarBody)
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr = internal.NewGenericOpenAPIErrorWithBodyAndModel(localVarHTTPResponse.Status, localVarBody, v)
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v AccessCodesCreateAccessCode409Response
			err = a.Client.Decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr = internal.NewGenericOpenAPIErrorWithBody(err.Error(), localVarBody)
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr = internal.NewGenericOpenAPIErrorWithBodyAndModel(localVarHTTPResponse.Status, localVarBody, v)
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v AccessCodesListAccessCodes500Response
			err = a.Client.Decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr = internal.NewGenericOpenAPIErrorWithBody(err.Error(), localVarBody)
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr = internal.NewGenericOpenAPIErrorWithBodyAndModel(localVarHTTPResponse.Status, localVarBody, v)
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.Client.Decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := internal.NewGenericOpenAPIErrorWithBody(err.Error(), localVarBody)
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	return localVarReturnValue, localVarHTTPResponse, nil
}
