/*
BloxOne FW API

BloxOne Threat Defense Cloud is an extension of the BloxOne Suite that provides visibility into infected and compromised off-premises devices, roaming users, remote sites, and branch offices. You can subscribe to BloxOne Cloud and use its functionality to mitigate and control malware as well as provide unprecedented insight into your network security posture and enable timely action. BloxOne Cloud also offers unified policy management, reporting, and threat analytics across the entire spectrum. Using automated and high-quality threat intelligence feeds and unique behavioral analytics, it automatically stops device communications with C&Cs/botnets and prevents DNS based data exfiltration.  The mission-critical DNS infrastructure can become a vulnerable component in your network when it is inadequately protected by traditional security solutions and consequently used as an attack surface. Compromised DNS services can result in catastrophic network and system failures. To fully protect your network in todayâ€™s cyber security threat environment, Infoblox sets a new DNS security standard by offering scalable, enterprise-grade, and integrated protection for your DNS infrastructure.  Through the Infoblox Cloud Services Portal, you can view the status of your subscription and threat intelligence feeds, manage your network scope and roaming end users, and learn more about threats on your networks through the Infoblox Threat Lookup tool and predefined reports.

API version: v1
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package fw

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/infobloxopen/bloxone-go-client/internal"
)

type AccessCodesAPI interface {
	/*
			AccessCodesCreateAccessCode Create Access Codes

			Use this method to create the Bypass Code corresponding to the
		security rules passed.
		It's an atomic operation. It should create all the security rules
		and create the policy and bypass codes, or do nothing if any of them fails.

		Required:
		- name
		- rules
		- activation
		- expiration





			@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			@return ApiAccessCodesCreateAccessCodeRequest
	*/
	AccessCodesCreateAccessCode(ctx context.Context) ApiAccessCodesCreateAccessCodeRequest

	// AccessCodesCreateAccessCodeExecute executes the request
	//  @return AtcfwAccessCodeCreateResponse
	AccessCodesCreateAccessCodeExecute(r ApiAccessCodesCreateAccessCodeRequest) (*AtcfwAccessCodeCreateResponse, *http.Response, error)
	/*
			AccessCodesDeleteAccessCodes Delete Access Codes

			Use this method to delete Bypass Code objects. Deletion of
		multiple bypass codes is an all-or-nothing operation (if any of
		the specified bypass codes cannot be deleted then none of the
		specified bypass codes will be deleted).

		Required:
		- ids



			@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			@return ApiAccessCodesDeleteAccessCodesRequest
	*/
	AccessCodesDeleteAccessCodes(ctx context.Context) ApiAccessCodesDeleteAccessCodesRequest

	// AccessCodesDeleteAccessCodesExecute executes the request
	AccessCodesDeleteAccessCodesExecute(r ApiAccessCodesDeleteAccessCodesRequest) (*http.Response, error)
	/*
		AccessCodesDeleteSingleAccessCodes Delete Access Code By ID

		Use this method to delete Bypass Code object.



		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param accessKey The Bypass Code identifier.
		@return ApiAccessCodesDeleteSingleAccessCodesRequest
	*/
	AccessCodesDeleteSingleAccessCodes(ctx context.Context, accessKey string) ApiAccessCodesDeleteSingleAccessCodesRequest

	// AccessCodesDeleteSingleAccessCodesExecute executes the request
	AccessCodesDeleteSingleAccessCodesExecute(r ApiAccessCodesDeleteSingleAccessCodesRequest) (*http.Response, error)
	/*
		AccessCodesListAccessCodes List Access Codes

		Use this method to retrieve a collection of Bypass Code objects.



		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiAccessCodesListAccessCodesRequest
	*/
	AccessCodesListAccessCodes(ctx context.Context) ApiAccessCodesListAccessCodesRequest

	// AccessCodesListAccessCodesExecute executes the request
	//  @return AtcfwAccessCodeMultiResponse
	AccessCodesListAccessCodesExecute(r ApiAccessCodesListAccessCodesRequest) (*AtcfwAccessCodeMultiResponse, *http.Response, error)
	/*
		AccessCodesReadAccessCode Read Access Codes

		Use this method to retrieve the Bypass Code by key.



		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param accessKey The Bypass Code identifier.
		@return ApiAccessCodesReadAccessCodeRequest
	*/
	AccessCodesReadAccessCode(ctx context.Context, accessKey string) ApiAccessCodesReadAccessCodeRequest

	// AccessCodesReadAccessCodeExecute executes the request
	//  @return AtcfwAccessCodeReadResponse
	AccessCodesReadAccessCodeExecute(r ApiAccessCodesReadAccessCodeRequest) (*AtcfwAccessCodeReadResponse, *http.Response, error)
	/*
			AccessCodesUpdateAccessCode Update Access Codes

			Use this method to update the Bypass Code corresponding to the security rules passed.
		It's an atomic operation. It should delete existing security rules and
		create all the new security rules for the bypass code,
		or do nothing if any of them fails.

		Required:
		- name
		- rules
		- dfps
		- network_lists
		- roaming_device_groups





			@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			@param payloadAccessKey Auto generated unique Bypass Code value
			@return ApiAccessCodesUpdateAccessCodeRequest
	*/
	AccessCodesUpdateAccessCode(ctx context.Context, payloadAccessKey string) ApiAccessCodesUpdateAccessCodeRequest

	// AccessCodesUpdateAccessCodeExecute executes the request
	//  @return AtcfwAccessCodeUpdateResponse
	AccessCodesUpdateAccessCodeExecute(r ApiAccessCodesUpdateAccessCodeRequest) (*AtcfwAccessCodeUpdateResponse, *http.Response, error)
}

// AccessCodesAPIService AccessCodesAPI service
type AccessCodesAPIService internal.Service

type ApiAccessCodesCreateAccessCodeRequest struct {
	ctx        context.Context
	ApiService AccessCodesAPI
	body       *AtcfwAccessCode
}

// The Bypass Code object.
func (r ApiAccessCodesCreateAccessCodeRequest) Body(body AtcfwAccessCode) ApiAccessCodesCreateAccessCodeRequest {
	r.body = &body
	return r
}

func (r ApiAccessCodesCreateAccessCodeRequest) Execute() (*AtcfwAccessCodeCreateResponse, *http.Response, error) {
	return r.ApiService.AccessCodesCreateAccessCodeExecute(r)
}

/*
AccessCodesCreateAccessCode Create Access Codes

Use this method to create the Bypass Code corresponding to the
security rules passed.
It's an atomic operation. It should create all the security rules
and create the policy and bypass codes, or do nothing if any of them fails.

Required:
- name
- rules
- activation
- expiration

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiAccessCodesCreateAccessCodeRequest
*/
func (a *AccessCodesAPIService) AccessCodesCreateAccessCode(ctx context.Context) ApiAccessCodesCreateAccessCodeRequest {
	return ApiAccessCodesCreateAccessCodeRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return AtcfwAccessCodeCreateResponse
func (a *AccessCodesAPIService) AccessCodesCreateAccessCodeExecute(r ApiAccessCodesCreateAccessCodeRequest) (*AtcfwAccessCodeCreateResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []internal.FormFile
		localVarReturnValue *AtcfwAccessCodeCreateResponse
	)

	localBasePath, err := a.Client.Cfg.ServerURLWithContext(r.ctx, "AccessCodesAPIService.AccessCodesCreateAccessCode")
	if err != nil {
		return localVarReturnValue, nil, internal.NewGenericOpenAPIError(err.Error())
	}

	localVarPath := localBasePath + "/access_codes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, internal.ReportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := internal.SelectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := internal.SelectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.Client.PrepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.Client.CallAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := internal.NewGenericOpenAPIErrorWithBody(localVarHTTPResponse.Status, localVarBody)
		if localVarHTTPResponse.StatusCode == 400 {
			var v AccessCodesCreateAccessCode400Response
			err = a.Client.Decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr = internal.NewGenericOpenAPIErrorWithBody(err.Error(), localVarBody)
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr = internal.NewGenericOpenAPIErrorWithBodyAndModel(localVarHTTPResponse.Status, localVarBody, v)
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v AccessCodesCreateAccessCode404Response
			err = a.Client.Decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr = internal.NewGenericOpenAPIErrorWithBody(err.Error(), localVarBody)
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr = internal.NewGenericOpenAPIErrorWithBodyAndModel(localVarHTTPResponse.Status, localVarBody, v)
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v AccessCodesCreateAccessCode409Response
			err = a.Client.Decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr = internal.NewGenericOpenAPIErrorWithBody(err.Error(), localVarBody)
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr = internal.NewGenericOpenAPIErrorWithBodyAndModel(localVarHTTPResponse.Status, localVarBody, v)
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v AccessCodesListAccessCodes500Response
			err = a.Client.Decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr = internal.NewGenericOpenAPIErrorWithBody(err.Error(), localVarBody)
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr = internal.NewGenericOpenAPIErrorWithBodyAndModel(localVarHTTPResponse.Status, localVarBody, v)
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.Client.Decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := internal.NewGenericOpenAPIErrorWithBody(err.Error(), localVarBody)
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAccessCodesDeleteAccessCodesRequest struct {
	ctx        context.Context
	ApiService AccessCodesAPI
	body       *AtcfwAccessCodeDeleteRequest
}

func (r ApiAccessCodesDeleteAccessCodesRequest) Body(body AtcfwAccessCodeDeleteRequest) ApiAccessCodesDeleteAccessCodesRequest {
	r.body = &body
	return r
}

func (r ApiAccessCodesDeleteAccessCodesRequest) Execute() (*http.Response, error) {
	return r.ApiService.AccessCodesDeleteAccessCodesExecute(r)
}

/*
AccessCodesDeleteAccessCodes Delete Access Codes

Use this method to delete Bypass Code objects. Deletion of
multiple bypass codes is an all-or-nothing operation (if any of
the specified bypass codes cannot be deleted then none of the
specified bypass codes will be deleted).

Required:
- ids

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiAccessCodesDeleteAccessCodesRequest
*/
func (a *AccessCodesAPIService) AccessCodesDeleteAccessCodes(ctx context.Context) ApiAccessCodesDeleteAccessCodesRequest {
	return ApiAccessCodesDeleteAccessCodesRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *AccessCodesAPIService) AccessCodesDeleteAccessCodesExecute(r ApiAccessCodesDeleteAccessCodesRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []internal.FormFile
	)

	localBasePath, err := a.Client.Cfg.ServerURLWithContext(r.ctx, "AccessCodesAPIService.AccessCodesDeleteAccessCodes")
	if err != nil {
		return nil, internal.NewGenericOpenAPIError(err.Error())
	}

	localVarPath := localBasePath + "/access_codes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, internal.ReportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := internal.SelectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := internal.SelectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.Client.PrepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.Client.CallAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := internal.NewGenericOpenAPIErrorWithBody(localVarHTTPResponse.Status, localVarBody)
		if localVarHTTPResponse.StatusCode == 400 {
			var v AccessCodesDeleteAccessCodes400Response
			err = a.Client.Decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr = internal.NewGenericOpenAPIErrorWithBody(err.Error(), localVarBody)
				return localVarHTTPResponse, newErr
			}
			newErr = internal.NewGenericOpenAPIErrorWithBodyAndModel(localVarHTTPResponse.Status, localVarBody, v)
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v AccessCodesListAccessCodes500Response
			err = a.Client.Decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr = internal.NewGenericOpenAPIErrorWithBody(err.Error(), localVarBody)
				return localVarHTTPResponse, newErr
			}
			newErr = internal.NewGenericOpenAPIErrorWithBodyAndModel(localVarHTTPResponse.Status, localVarBody, v)
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAccessCodesDeleteSingleAccessCodesRequest struct {
	ctx        context.Context
	ApiService AccessCodesAPI
	accessKey  string
}

func (r ApiAccessCodesDeleteSingleAccessCodesRequest) Execute() (*http.Response, error) {
	return r.ApiService.AccessCodesDeleteSingleAccessCodesExecute(r)
}

/*
AccessCodesDeleteSingleAccessCodes Delete Access Code By ID

Use this method to delete Bypass Code object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param accessKey The Bypass Code identifier.
	@return ApiAccessCodesDeleteSingleAccessCodesRequest
*/
func (a *AccessCodesAPIService) AccessCodesDeleteSingleAccessCodes(ctx context.Context, accessKey string) ApiAccessCodesDeleteSingleAccessCodesRequest {
	return ApiAccessCodesDeleteSingleAccessCodesRequest{
		ApiService: a,
		ctx:        ctx,
		accessKey:  accessKey,
	}
}

// Execute executes the request
func (a *AccessCodesAPIService) AccessCodesDeleteSingleAccessCodesExecute(r ApiAccessCodesDeleteSingleAccessCodesRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []internal.FormFile
	)

	localBasePath, err := a.Client.Cfg.ServerURLWithContext(r.ctx, "AccessCodesAPIService.AccessCodesDeleteSingleAccessCodes")
	if err != nil {
		return nil, internal.NewGenericOpenAPIError(err.Error())
	}

	localVarPath := localBasePath + "/access_codes/{access_key}"
	localVarPath = strings.Replace(localVarPath, "{"+"access_key"+"}", url.PathEscape(internal.ParameterValueToString(r.accessKey, "accessKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := internal.SelectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := internal.SelectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.Client.PrepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.Client.CallAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := internal.NewGenericOpenAPIErrorWithBody(localVarHTTPResponse.Status, localVarBody)
		if localVarHTTPResponse.StatusCode == 400 {
			var v AccessCodesDeleteSingleAccessCodes400Response
			err = a.Client.Decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr = internal.NewGenericOpenAPIErrorWithBody(err.Error(), localVarBody)
				return localVarHTTPResponse, newErr
			}
			newErr = internal.NewGenericOpenAPIErrorWithBodyAndModel(localVarHTTPResponse.Status, localVarBody, v)
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v AccessCodesListAccessCodes500Response
			err = a.Client.Decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr = internal.NewGenericOpenAPIErrorWithBody(err.Error(), localVarBody)
				return localVarHTTPResponse, newErr
			}
			newErr = internal.NewGenericOpenAPIErrorWithBodyAndModel(localVarHTTPResponse.Status, localVarBody, v)
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAccessCodesListAccessCodesRequest struct {
	ctx        context.Context
	ApiService AccessCodesAPI
	filter     *string
	offset     *int32
	limit      *int32
	pageToken  *string
}

// A collection of response resources can be filtered by a logical expression string that includes JSON tag references to values in each resource, literal values, and logical operators. If a resource does not have the specified tag, its value is assumed to be null.  Literal values include numbers (integer and floating-point), and quoted (both single- or double-quoted) literal strings, and &#39;null&#39;.  You can filter by following fields:  | Name               | type   | Supported Op                | | ------------------ | ------ | --------------------------- | | access_key         | string | !&#x3D;, &#x3D;&#x3D;, ~, !~, &gt;, &lt;, &lt;&#x3D;, &gt;&#x3D; | | name               | string | !&#x3D;, &#x3D;&#x3D;, ~, !~, &gt;, &lt;, &lt;&#x3D;, &gt;&#x3D; | | description        | string | !&#x3D;, &#x3D;&#x3D;, ~, !~, &gt;, &lt;, &lt;&#x3D;, &gt;&#x3D; | | security_policy_id | int32  | !&#x3D;, &#x3D;&#x3D;, &gt;, &lt;, &lt;&#x3D;, &gt;&#x3D;        |  In addition, grouping operators are supported:  | Op  | Description          | | --- | -------------------- | | and | Logical AND          | | or  | Logical OR           | | not | Logical NOT          | | ()  | Groupping Operators  |  Example: &#x60;&#x60;&#x60; ?_filter&#x3D;\&quot;((name&#x3D;&#x3D;&#39;acc_code&#39;)or(name~&#39;key&#39;))and(security_policy_id!&#x3D;32)\&quot; &#x60;&#x60;&#x60;
func (r ApiAccessCodesListAccessCodesRequest) Filter(filter string) ApiAccessCodesListAccessCodesRequest {
	r.filter = &filter
	return r
}

// The integer index (zero-origin) of the offset into a collection of resources. If omitted or null the value is assumed to be &#39;0&#39;.
func (r ApiAccessCodesListAccessCodesRequest) Offset(offset int32) ApiAccessCodesListAccessCodesRequest {
	r.offset = &offset
	return r
}

// The integer number of resources to be returned in the response. The service may impose maximum value. If omitted the service may impose a default value.
func (r ApiAccessCodesListAccessCodesRequest) Limit(limit int32) ApiAccessCodesListAccessCodesRequest {
	r.limit = &limit
	return r
}

// The service-defined string used to identify a page of resources. A null value indicates the first page.
func (r ApiAccessCodesListAccessCodesRequest) PageToken(pageToken string) ApiAccessCodesListAccessCodesRequest {
	r.pageToken = &pageToken
	return r
}

func (r ApiAccessCodesListAccessCodesRequest) Execute() (*AtcfwAccessCodeMultiResponse, *http.Response, error) {
	return r.ApiService.AccessCodesListAccessCodesExecute(r)
}

/*
AccessCodesListAccessCodes List Access Codes

Use this method to retrieve a collection of Bypass Code objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiAccessCodesListAccessCodesRequest
*/
func (a *AccessCodesAPIService) AccessCodesListAccessCodes(ctx context.Context) ApiAccessCodesListAccessCodesRequest {
	return ApiAccessCodesListAccessCodesRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return AtcfwAccessCodeMultiResponse
func (a *AccessCodesAPIService) AccessCodesListAccessCodesExecute(r ApiAccessCodesListAccessCodesRequest) (*AtcfwAccessCodeMultiResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []internal.FormFile
		localVarReturnValue *AtcfwAccessCodeMultiResponse
	)

	localBasePath, err := a.Client.Cfg.ServerURLWithContext(r.ctx, "AccessCodesAPIService.AccessCodesListAccessCodes")
	if err != nil {
		return localVarReturnValue, nil, internal.NewGenericOpenAPIError(err.Error())
	}

	localVarPath := localBasePath + "/access_codes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filter != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "_filter", r.filter, "")
	}
	if r.offset != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "_offset", r.offset, "")
	}
	if r.limit != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "_limit", r.limit, "")
	}
	if r.pageToken != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "_page_token", r.pageToken, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := internal.SelectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := internal.SelectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.Client.PrepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.Client.CallAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := internal.NewGenericOpenAPIErrorWithBody(localVarHTTPResponse.Status, localVarBody)
		if localVarHTTPResponse.StatusCode == 500 {
			var v AccessCodesListAccessCodes500Response
			err = a.Client.Decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr = internal.NewGenericOpenAPIErrorWithBody(err.Error(), localVarBody)
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr = internal.NewGenericOpenAPIErrorWithBodyAndModel(localVarHTTPResponse.Status, localVarBody, v)
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.Client.Decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := internal.NewGenericOpenAPIErrorWithBody(err.Error(), localVarBody)
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAccessCodesReadAccessCodeRequest struct {
	ctx        context.Context
	ApiService AccessCodesAPI
	accessKey  string
	name       *string
}

// The Bypass Code name.
func (r ApiAccessCodesReadAccessCodeRequest) Name(name string) ApiAccessCodesReadAccessCodeRequest {
	r.name = &name
	return r
}

func (r ApiAccessCodesReadAccessCodeRequest) Execute() (*AtcfwAccessCodeReadResponse, *http.Response, error) {
	return r.ApiService.AccessCodesReadAccessCodeExecute(r)
}

/*
AccessCodesReadAccessCode Read Access Codes

Use this method to retrieve the Bypass Code by key.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param accessKey The Bypass Code identifier.
	@return ApiAccessCodesReadAccessCodeRequest
*/
func (a *AccessCodesAPIService) AccessCodesReadAccessCode(ctx context.Context, accessKey string) ApiAccessCodesReadAccessCodeRequest {
	return ApiAccessCodesReadAccessCodeRequest{
		ApiService: a,
		ctx:        ctx,
		accessKey:  accessKey,
	}
}

// Execute executes the request
//
//	@return AtcfwAccessCodeReadResponse
func (a *AccessCodesAPIService) AccessCodesReadAccessCodeExecute(r ApiAccessCodesReadAccessCodeRequest) (*AtcfwAccessCodeReadResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []internal.FormFile
		localVarReturnValue *AtcfwAccessCodeReadResponse
	)

	localBasePath, err := a.Client.Cfg.ServerURLWithContext(r.ctx, "AccessCodesAPIService.AccessCodesReadAccessCode")
	if err != nil {
		return localVarReturnValue, nil, internal.NewGenericOpenAPIError(err.Error())
	}

	localVarPath := localBasePath + "/access_codes/{access_key}"
	localVarPath = strings.Replace(localVarPath, "{"+"access_key"+"}", url.PathEscape(internal.ParameterValueToString(r.accessKey, "accessKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.name != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := internal.SelectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := internal.SelectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.Client.PrepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.Client.CallAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := internal.NewGenericOpenAPIErrorWithBody(localVarHTTPResponse.Status, localVarBody)
		if localVarHTTPResponse.StatusCode == 404 {
			var v AccessCodesReadAccessCode404Response
			err = a.Client.Decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr = internal.NewGenericOpenAPIErrorWithBody(err.Error(), localVarBody)
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr = internal.NewGenericOpenAPIErrorWithBodyAndModel(localVarHTTPResponse.Status, localVarBody, v)
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v AccessCodesListAccessCodes500Response
			err = a.Client.Decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr = internal.NewGenericOpenAPIErrorWithBody(err.Error(), localVarBody)
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr = internal.NewGenericOpenAPIErrorWithBodyAndModel(localVarHTTPResponse.Status, localVarBody, v)
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.Client.Decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := internal.NewGenericOpenAPIErrorWithBody(err.Error(), localVarBody)
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAccessCodesUpdateAccessCodeRequest struct {
	ctx              context.Context
	ApiService       AccessCodesAPI
	payloadAccessKey string
	body             *AtcfwAccessCode
}

// The Bypass Code object.
func (r ApiAccessCodesUpdateAccessCodeRequest) Body(body AtcfwAccessCode) ApiAccessCodesUpdateAccessCodeRequest {
	r.body = &body
	return r
}

func (r ApiAccessCodesUpdateAccessCodeRequest) Execute() (*AtcfwAccessCodeUpdateResponse, *http.Response, error) {
	return r.ApiService.AccessCodesUpdateAccessCodeExecute(r)
}

/*
AccessCodesUpdateAccessCode Update Access Codes

Use this method to update the Bypass Code corresponding to the security rules passed.
It's an atomic operation. It should delete existing security rules and
create all the new security rules for the bypass code,
or do nothing if any of them fails.

Required:
- name
- rules
- dfps
- network_lists
- roaming_device_groups

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param payloadAccessKey Auto generated unique Bypass Code value
	@return ApiAccessCodesUpdateAccessCodeRequest
*/
func (a *AccessCodesAPIService) AccessCodesUpdateAccessCode(ctx context.Context, payloadAccessKey string) ApiAccessCodesUpdateAccessCodeRequest {
	return ApiAccessCodesUpdateAccessCodeRequest{
		ApiService:       a,
		ctx:              ctx,
		payloadAccessKey: payloadAccessKey,
	}
}

// Execute executes the request
//
//	@return AtcfwAccessCodeUpdateResponse
func (a *AccessCodesAPIService) AccessCodesUpdateAccessCodeExecute(r ApiAccessCodesUpdateAccessCodeRequest) (*AtcfwAccessCodeUpdateResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []internal.FormFile
		localVarReturnValue *AtcfwAccessCodeUpdateResponse
	)

	localBasePath, err := a.Client.Cfg.ServerURLWithContext(r.ctx, "AccessCodesAPIService.AccessCodesUpdateAccessCode")
	if err != nil {
		return localVarReturnValue, nil, internal.NewGenericOpenAPIError(err.Error())
	}

	localVarPath := localBasePath + "/access_codes/{payload.access_key}"
	localVarPath = strings.Replace(localVarPath, "{"+"payload.access_key"+"}", url.PathEscape(internal.ParameterValueToString(r.payloadAccessKey, "payloadAccessKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, internal.ReportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := internal.SelectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := internal.SelectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.Client.PrepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.Client.CallAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := internal.NewGenericOpenAPIErrorWithBody(localVarHTTPResponse.Status, localVarBody)
		if localVarHTTPResponse.StatusCode == 400 {
			var v AccessCodesCreateAccessCode400Response
			err = a.Client.Decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr = internal.NewGenericOpenAPIErrorWithBody(err.Error(), localVarBody)
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr = internal.NewGenericOpenAPIErrorWithBodyAndModel(localVarHTTPResponse.Status, localVarBody, v)
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v AccessCodesCreateAccessCode404Response
			err = a.Client.Decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr = internal.NewGenericOpenAPIErrorWithBody(err.Error(), localVarBody)
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr = internal.NewGenericOpenAPIErrorWithBodyAndModel(localVarHTTPResponse.Status, localVarBody, v)
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v AccessCodesCreateAccessCode409Response
			err = a.Client.Decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr = internal.NewGenericOpenAPIErrorWithBody(err.Error(), localVarBody)
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr = internal.NewGenericOpenAPIErrorWithBodyAndModel(localVarHTTPResponse.Status, localVarBody, v)
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v AccessCodesListAccessCodes500Response
			err = a.Client.Decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr = internal.NewGenericOpenAPIErrorWithBody(err.Error(), localVarBody)
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr = internal.NewGenericOpenAPIErrorWithBodyAndModel(localVarHTTPResponse.Status, localVarBody, v)
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.Client.Decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := internal.NewGenericOpenAPIErrorWithBody(err.Error(), localVarBody)
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	return localVarReturnValue, localVarHTTPResponse, nil
}
