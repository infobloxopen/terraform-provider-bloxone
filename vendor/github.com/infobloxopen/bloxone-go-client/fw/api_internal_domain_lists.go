/*
BloxOne FW API

BloxOne Threat Defense Cloud is an extension of the BloxOne Suite that provides visibility into infected and compromised off-premises devices, roaming users, remote sites, and branch offices. You can subscribe to BloxOne Cloud and use its functionality to mitigate and control malware as well as provide unprecedented insight into your network security posture and enable timely action. BloxOne Cloud also offers unified policy management, reporting, and threat analytics across the entire spectrum. Using automated and high-quality threat intelligence feeds and unique behavioral analytics, it automatically stops device communications with C&Cs/botnets and prevents DNS based data exfiltration.  The mission-critical DNS infrastructure can become a vulnerable component in your network when it is inadequately protected by traditional security solutions and consequently used as an attack surface. Compromised DNS services can result in catastrophic network and system failures. To fully protect your network in today’s cyber security threat environment, Infoblox sets a new DNS security standard by offering scalable, enterprise-grade, and integrated protection for your DNS infrastructure.  Through the Infoblox Cloud Services Portal, you can view the status of your subscription and threat intelligence feeds, manage your network scope and roaming end users, and learn more about threats on your networks through the Infoblox Threat Lookup tool and predefined reports.

API version: v1
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package fw

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/infobloxopen/bloxone-go-client/internal"
)

type InternalDomainListsAPI interface {
	/*
			InternalDomainListsCreateInternalDomains Create Internal Domains.

			Use this method to create Internal Domains objects for the account.

		The internal domain list is a transport object for reporting gathering internal domains. This feature allows users to configure internal domains lists for specific DFP and ATEP groups. This lists provides the users to create ‘Internal Domains List’ objects with a name, description, and a list of domains/ip/cidr. These lists are referenced by and attached to DFP, and ATEP groups.
		Once attached to DFP, dfp configuration endpoints will return the values under all associated domain lists as domains.

		Once attached to ATEP, atep login endpoint will return the values under all associated lists as internal_domain_lists.


		Required:
		- name
		- internal_domains



			@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			@return ApiInternalDomainListsCreateInternalDomainsRequest
	*/
	InternalDomainListsCreateInternalDomains(ctx context.Context) ApiInternalDomainListsCreateInternalDomainsRequest

	// InternalDomainListsCreateInternalDomainsExecute executes the request
	//  @return AtcfwInternalDomainsCreateResponse
	InternalDomainListsCreateInternalDomainsExecute(r ApiInternalDomainListsCreateInternalDomainsRequest) (*AtcfwInternalDomainsCreateResponse, *http.Response, error)
	/*
			InternalDomainListsDeleteInternalDomains Delete Internal Domains.

			Use this method to delete Internal Domains objects for the account by a given list of internal domain list ids.

		The internal domain list is a transport object for reporting gathering internal domains. This feature allows users to configure internal domains lists for specific DFP and ATEP groups. This lists provides the users to create ‘Internal Domains List’ objects with a name, description, and a list of domains/ip/cidr. These lists are referenced by and attached to DFP, and ATEP groups.
		Once attached to DFP, dfp configuration endpoints will return the values under all associated domain lists as domains.

		Once attached to ATEP, atep login endpoint will return the values under all associated lists as internal_domain_lists.

		Required:
		- ids


			@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			@return ApiInternalDomainListsDeleteInternalDomainsRequest
	*/
	InternalDomainListsDeleteInternalDomains(ctx context.Context) ApiInternalDomainListsDeleteInternalDomainsRequest

	// InternalDomainListsDeleteInternalDomainsExecute executes the request
	InternalDomainListsDeleteInternalDomainsExecute(r ApiInternalDomainListsDeleteInternalDomainsRequest) (*http.Response, error)
	/*
			InternalDomainListsDeleteSingleInternalDomains Delete Internal Domains.

			Use this method to delete Internal Domains objects for the account by a given internal domain list id.

		The internal domain list is a transport object for reporting gathering internal domains. This feature allows users to configure internal domains lists for specific DFP and ATEP groups. This lists provides the users to create ‘Internal Domains List’ objects with a name, description, and a list of domains/ip/cidr. These lists are referenced by and attached to DFP, and ATEP groups.
		Once attached to DFP, dfp configuration endpoints will return the values under all associated domain lists as domains.

		Once attached to ATEP, atep login endpoint will return the values under all associated lists as internal_domain_lists.




			@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			@param id The Internal Domains object identifiers.
			@return ApiInternalDomainListsDeleteSingleInternalDomainsRequest
	*/
	InternalDomainListsDeleteSingleInternalDomains(ctx context.Context, id int32) ApiInternalDomainListsDeleteSingleInternalDomainsRequest

	// InternalDomainListsDeleteSingleInternalDomainsExecute executes the request
	InternalDomainListsDeleteSingleInternalDomainsExecute(r ApiInternalDomainListsDeleteSingleInternalDomainsRequest) (*http.Response, error)
	/*
			InternalDomainListsInternalDomainsItemsPartialUpdate Patch Internal Domains.

			Use this method to insert ot delete items  for a specified Named List object. Note that duplicated items are silently skipped and only new items are appended to the named list.
		Note that DNSM, TI, Fast Flux, custom lists and DGA lists cannot be updated. Only Internal Domains items can be updated.

		The Internal Domains Items represent the list of the FQDN or IPv4 addresses to define whitelists for additional protection.


			@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			@param id The Internal Domain List object identifier.
			@return ApiInternalDomainListsInternalDomainsItemsPartialUpdateRequest
	*/
	InternalDomainListsInternalDomainsItemsPartialUpdate(ctx context.Context, id int32) ApiInternalDomainListsInternalDomainsItemsPartialUpdateRequest

	// InternalDomainListsInternalDomainsItemsPartialUpdateExecute executes the request
	//  @return map[string]interface{}
	InternalDomainListsInternalDomainsItemsPartialUpdateExecute(r ApiInternalDomainListsInternalDomainsItemsPartialUpdateRequest) (map[string]interface{}, *http.Response, error)
	/*
			InternalDomainListsListInternalDomains List Internal Domains.

			Use this method to retrieve information on all Internal Domains objects for the account.

		The internal domain list is a transport object for reporting gathering internal domains. This feature allows users to configure internal domains lists for specific DFP and ATEP groups. This lists provides the users to create ‘Internal Domains List’ objects with a name, description, and a list of domains/ip/cidr. These lists are referenced by and attached to DFP, and ATEP groups.
		Once attached to DFP, dfp configuration endpoints will return the values under all associated domain lists as domains.

		Once attached to ATEP, atep login endpoint will return the values under all associated lists as internal_domain_lists.



			@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			@return ApiInternalDomainListsListInternalDomainsRequest
	*/
	InternalDomainListsListInternalDomains(ctx context.Context) ApiInternalDomainListsListInternalDomainsRequest

	// InternalDomainListsListInternalDomainsExecute executes the request
	//  @return AtcfwInternalDomainsMultiResponse
	InternalDomainListsListInternalDomainsExecute(r ApiInternalDomainListsListInternalDomainsRequest) (*AtcfwInternalDomainsMultiResponse, *http.Response, error)
	/*
			InternalDomainListsReadInternalDomains Read Internal Domains.

			Use this method to read Internal Domains objects for the account by a internal domain list id.

		The internal domain list is a transport object for reporting gathering internal domains. This feature allows users to configure internal domains lists for specific DFP and ATEP groups. This lists provides the users to create ‘Internal Domains List’ objects with a name, description, and a list of domains/ip/cidr. These lists are referenced by and attached to DFP, and ATEP groups.
		Once attached to DFP, dfp configuration endpoints will return the values under all associated domain lists as domains.

		Once attached to ATEP, atep login endpoint will return the values under all associated lists as internal_domain_lists.


			@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			@param id The Internal Domains object identifier.
			@return ApiInternalDomainListsReadInternalDomainsRequest
	*/
	InternalDomainListsReadInternalDomains(ctx context.Context, id int32) ApiInternalDomainListsReadInternalDomainsRequest

	// InternalDomainListsReadInternalDomainsExecute executes the request
	//  @return AtcfwInternalDomainsReadResponse
	InternalDomainListsReadInternalDomainsExecute(r ApiInternalDomainListsReadInternalDomainsRequest) (*AtcfwInternalDomainsReadResponse, *http.Response, error)
	/*
			InternalDomainListsUpdateInternalDomains Update Internal Domains.

			Use this method to update Internal Domains objects for the account by a internal domain list id.

		The internal domain list is a transport object for reporting gathering internal domains. This feature allows users to configure internal domains lists for specific DFP and ATEP groups. This lists provides the users to create ‘Internal Domains List’ objects with a name, description, and a list of domains/ip/cidr. These lists are referenced by and attached to DFP, and ATEP groups.
		Once attached to DFP, dfp configuration endpoints will return the values under all associated domain lists as domains.

		Once attached to ATEP, atep login endpoint will return the values under all associated lists as internal_domain_lists.

		Required:
		- name
		- internal_domains


			@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			@param id The Internal Domain object identifier.
			@return ApiInternalDomainListsUpdateInternalDomainsRequest
	*/
	InternalDomainListsUpdateInternalDomains(ctx context.Context, id int32) ApiInternalDomainListsUpdateInternalDomainsRequest

	// InternalDomainListsUpdateInternalDomainsExecute executes the request
	//  @return AtcfwInternalDomainsUpdateResponse
	InternalDomainListsUpdateInternalDomainsExecute(r ApiInternalDomainListsUpdateInternalDomainsRequest) (*AtcfwInternalDomainsUpdateResponse, *http.Response, error)
}

// InternalDomainListsAPIService InternalDomainListsAPI service
type InternalDomainListsAPIService internal.Service

type ApiInternalDomainListsCreateInternalDomainsRequest struct {
	ctx        context.Context
	ApiService InternalDomainListsAPI
	body       *AtcfwInternalDomains
}

// The Internal Domains object.
func (r ApiInternalDomainListsCreateInternalDomainsRequest) Body(body AtcfwInternalDomains) ApiInternalDomainListsCreateInternalDomainsRequest {
	r.body = &body
	return r
}

func (r ApiInternalDomainListsCreateInternalDomainsRequest) Execute() (*AtcfwInternalDomainsCreateResponse, *http.Response, error) {
	return r.ApiService.InternalDomainListsCreateInternalDomainsExecute(r)
}

/*
InternalDomainListsCreateInternalDomains Create Internal Domains.

Use this method to create Internal Domains objects for the account.

The internal domain list is a transport object for reporting gathering internal domains. This feature allows users to configure internal domains lists for specific DFP and ATEP groups. This lists provides the users to create ‘Internal Domains List’ objects with a name, description, and a list of domains/ip/cidr. These lists are referenced by and attached to DFP, and ATEP groups.
Once attached to DFP, dfp configuration endpoints will return the values under all associated domain lists as domains.

Once attached to ATEP, atep login endpoint will return the values under all associated lists as internal_domain_lists.

Required:
- name
- internal_domains

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiInternalDomainListsCreateInternalDomainsRequest
*/
func (a *InternalDomainListsAPIService) InternalDomainListsCreateInternalDomains(ctx context.Context) ApiInternalDomainListsCreateInternalDomainsRequest {
	return ApiInternalDomainListsCreateInternalDomainsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return AtcfwInternalDomainsCreateResponse
func (a *InternalDomainListsAPIService) InternalDomainListsCreateInternalDomainsExecute(r ApiInternalDomainListsCreateInternalDomainsRequest) (*AtcfwInternalDomainsCreateResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []internal.FormFile
		localVarReturnValue *AtcfwInternalDomainsCreateResponse
	)

	localBasePath, err := a.Client.Cfg.ServerURLWithContext(r.ctx, "InternalDomainListsAPIService.InternalDomainListsCreateInternalDomains")
	if err != nil {
		return localVarReturnValue, nil, internal.NewGenericOpenAPIError(err.Error())
	}

	localVarPath := localBasePath + "/internal_domain_lists"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, internal.ReportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := internal.SelectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := internal.SelectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.Client.PrepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.Client.CallAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := internal.NewGenericOpenAPIErrorWithBody(localVarHTTPResponse.Status, localVarBody)
		if localVarHTTPResponse.StatusCode == 400 {
			var v InternalDomainListsCreateInternalDomains400Response
			err = a.Client.Decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr = internal.NewGenericOpenAPIErrorWithBody(err.Error(), localVarBody)
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr = internal.NewGenericOpenAPIErrorWithBodyAndModel(localVarHTTPResponse.Status, localVarBody, v)
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v InternalDomainListsCreateInternalDomains409Response
			err = a.Client.Decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr = internal.NewGenericOpenAPIErrorWithBody(err.Error(), localVarBody)
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr = internal.NewGenericOpenAPIErrorWithBodyAndModel(localVarHTTPResponse.Status, localVarBody, v)
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v AccessCodesListAccessCodes500Response
			err = a.Client.Decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr = internal.NewGenericOpenAPIErrorWithBody(err.Error(), localVarBody)
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr = internal.NewGenericOpenAPIErrorWithBodyAndModel(localVarHTTPResponse.Status, localVarBody, v)
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.Client.Decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := internal.NewGenericOpenAPIErrorWithBody(err.Error(), localVarBody)
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiInternalDomainListsDeleteInternalDomainsRequest struct {
	ctx        context.Context
	ApiService InternalDomainListsAPI
	body       *AtcfwInternalDomainsDeleteRequest
}

func (r ApiInternalDomainListsDeleteInternalDomainsRequest) Body(body AtcfwInternalDomainsDeleteRequest) ApiInternalDomainListsDeleteInternalDomainsRequest {
	r.body = &body
	return r
}

func (r ApiInternalDomainListsDeleteInternalDomainsRequest) Execute() (*http.Response, error) {
	return r.ApiService.InternalDomainListsDeleteInternalDomainsExecute(r)
}

/*
InternalDomainListsDeleteInternalDomains Delete Internal Domains.

Use this method to delete Internal Domains objects for the account by a given list of internal domain list ids.

The internal domain list is a transport object for reporting gathering internal domains. This feature allows users to configure internal domains lists for specific DFP and ATEP groups. This lists provides the users to create ‘Internal Domains List’ objects with a name, description, and a list of domains/ip/cidr. These lists are referenced by and attached to DFP, and ATEP groups.
Once attached to DFP, dfp configuration endpoints will return the values under all associated domain lists as domains.

Once attached to ATEP, atep login endpoint will return the values under all associated lists as internal_domain_lists.

Required:
- ids

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiInternalDomainListsDeleteInternalDomainsRequest
*/
func (a *InternalDomainListsAPIService) InternalDomainListsDeleteInternalDomains(ctx context.Context) ApiInternalDomainListsDeleteInternalDomainsRequest {
	return ApiInternalDomainListsDeleteInternalDomainsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *InternalDomainListsAPIService) InternalDomainListsDeleteInternalDomainsExecute(r ApiInternalDomainListsDeleteInternalDomainsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []internal.FormFile
	)

	localBasePath, err := a.Client.Cfg.ServerURLWithContext(r.ctx, "InternalDomainListsAPIService.InternalDomainListsDeleteInternalDomains")
	if err != nil {
		return nil, internal.NewGenericOpenAPIError(err.Error())
	}

	localVarPath := localBasePath + "/internal_domain_lists"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, internal.ReportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := internal.SelectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := internal.SelectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.Client.PrepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.Client.CallAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := internal.NewGenericOpenAPIErrorWithBody(localVarHTTPResponse.Status, localVarBody)
		if localVarHTTPResponse.StatusCode == 400 {
			var v InternalDomainListsDeleteInternalDomains400Response
			err = a.Client.Decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr = internal.NewGenericOpenAPIErrorWithBody(err.Error(), localVarBody)
				return localVarHTTPResponse, newErr
			}
			newErr = internal.NewGenericOpenAPIErrorWithBodyAndModel(localVarHTTPResponse.Status, localVarBody, v)
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v InternalDomainListsDeleteInternalDomains404Response
			err = a.Client.Decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr = internal.NewGenericOpenAPIErrorWithBody(err.Error(), localVarBody)
				return localVarHTTPResponse, newErr
			}
			newErr = internal.NewGenericOpenAPIErrorWithBodyAndModel(localVarHTTPResponse.Status, localVarBody, v)
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v AccessCodesListAccessCodes500Response
			err = a.Client.Decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr = internal.NewGenericOpenAPIErrorWithBody(err.Error(), localVarBody)
				return localVarHTTPResponse, newErr
			}
			newErr = internal.NewGenericOpenAPIErrorWithBodyAndModel(localVarHTTPResponse.Status, localVarBody, v)
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiInternalDomainListsDeleteSingleInternalDomainsRequest struct {
	ctx        context.Context
	ApiService InternalDomainListsAPI
	id         int32
}

func (r ApiInternalDomainListsDeleteSingleInternalDomainsRequest) Execute() (*http.Response, error) {
	return r.ApiService.InternalDomainListsDeleteSingleInternalDomainsExecute(r)
}

/*
InternalDomainListsDeleteSingleInternalDomains Delete Internal Domains.

Use this method to delete Internal Domains objects for the account by a given internal domain list id.

The internal domain list is a transport object for reporting gathering internal domains. This feature allows users to configure internal domains lists for specific DFP and ATEP groups. This lists provides the users to create ‘Internal Domains List’ objects with a name, description, and a list of domains/ip/cidr. These lists are referenced by and attached to DFP, and ATEP groups.
Once attached to DFP, dfp configuration endpoints will return the values under all associated domain lists as domains.

Once attached to ATEP, atep login endpoint will return the values under all associated lists as internal_domain_lists.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The Internal Domains object identifiers.
	@return ApiInternalDomainListsDeleteSingleInternalDomainsRequest
*/
func (a *InternalDomainListsAPIService) InternalDomainListsDeleteSingleInternalDomains(ctx context.Context, id int32) ApiInternalDomainListsDeleteSingleInternalDomainsRequest {
	return ApiInternalDomainListsDeleteSingleInternalDomainsRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
func (a *InternalDomainListsAPIService) InternalDomainListsDeleteSingleInternalDomainsExecute(r ApiInternalDomainListsDeleteSingleInternalDomainsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []internal.FormFile
	)

	localBasePath, err := a.Client.Cfg.ServerURLWithContext(r.ctx, "InternalDomainListsAPIService.InternalDomainListsDeleteSingleInternalDomains")
	if err != nil {
		return nil, internal.NewGenericOpenAPIError(err.Error())
	}

	localVarPath := localBasePath + "/internal_domain_lists/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(internal.ParameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := internal.SelectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := internal.SelectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.Client.PrepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.Client.CallAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := internal.NewGenericOpenAPIErrorWithBody(localVarHTTPResponse.Status, localVarBody)
		if localVarHTTPResponse.StatusCode == 400 {
			var v InternalDomainListsDeleteSingleInternalDomains400Response
			err = a.Client.Decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr = internal.NewGenericOpenAPIErrorWithBody(err.Error(), localVarBody)
				return localVarHTTPResponse, newErr
			}
			newErr = internal.NewGenericOpenAPIErrorWithBodyAndModel(localVarHTTPResponse.Status, localVarBody, v)
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v InternalDomainListsDeleteInternalDomains404Response
			err = a.Client.Decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr = internal.NewGenericOpenAPIErrorWithBody(err.Error(), localVarBody)
				return localVarHTTPResponse, newErr
			}
			newErr = internal.NewGenericOpenAPIErrorWithBodyAndModel(localVarHTTPResponse.Status, localVarBody, v)
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v AccessCodesListAccessCodes500Response
			err = a.Client.Decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr = internal.NewGenericOpenAPIErrorWithBody(err.Error(), localVarBody)
				return localVarHTTPResponse, newErr
			}
			newErr = internal.NewGenericOpenAPIErrorWithBodyAndModel(localVarHTTPResponse.Status, localVarBody, v)
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiInternalDomainListsInternalDomainsItemsPartialUpdateRequest struct {
	ctx        context.Context
	ApiService InternalDomainListsAPI
	id         int32
	body       *AtcfwInternalDomainsItems
}

// The Internal Domains Items Patch object.
func (r ApiInternalDomainListsInternalDomainsItemsPartialUpdateRequest) Body(body AtcfwInternalDomainsItems) ApiInternalDomainListsInternalDomainsItemsPartialUpdateRequest {
	r.body = &body
	return r
}

func (r ApiInternalDomainListsInternalDomainsItemsPartialUpdateRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.InternalDomainListsInternalDomainsItemsPartialUpdateExecute(r)
}

/*
InternalDomainListsInternalDomainsItemsPartialUpdate Patch Internal Domains.

Use this method to insert ot delete items  for a specified Named List object. Note that duplicated items are silently skipped and only new items are appended to the named list.
Note that DNSM, TI, Fast Flux, custom lists and DGA lists cannot be updated. Only Internal Domains items can be updated.

The Internal Domains Items represent the list of the FQDN or IPv4 addresses to define whitelists for additional protection.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The Internal Domain List object identifier.
	@return ApiInternalDomainListsInternalDomainsItemsPartialUpdateRequest
*/
func (a *InternalDomainListsAPIService) InternalDomainListsInternalDomainsItemsPartialUpdate(ctx context.Context, id int32) ApiInternalDomainListsInternalDomainsItemsPartialUpdateRequest {
	return ApiInternalDomainListsInternalDomainsItemsPartialUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *InternalDomainListsAPIService) InternalDomainListsInternalDomainsItemsPartialUpdateExecute(r ApiInternalDomainListsInternalDomainsItemsPartialUpdateRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []internal.FormFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.Client.Cfg.ServerURLWithContext(r.ctx, "InternalDomainListsAPIService.InternalDomainListsInternalDomainsItemsPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, internal.NewGenericOpenAPIError(err.Error())
	}

	localVarPath := localBasePath + "/internal_domain_lists/{id}/items"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(internal.ParameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, internal.ReportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := internal.SelectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := internal.SelectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.Client.PrepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.Client.CallAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := internal.NewGenericOpenAPIErrorWithBody(localVarHTTPResponse.Status, localVarBody)
		if localVarHTTPResponse.StatusCode == 400 {
			var v InternalDomainListsInternalDomainsItemsPartialUpdate400Response
			err = a.Client.Decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr = internal.NewGenericOpenAPIErrorWithBody(err.Error(), localVarBody)
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr = internal.NewGenericOpenAPIErrorWithBodyAndModel(localVarHTTPResponse.Status, localVarBody, v)
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v InternalDomainListsInternalDomainsItemsPartialUpdate404Response
			err = a.Client.Decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr = internal.NewGenericOpenAPIErrorWithBody(err.Error(), localVarBody)
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr = internal.NewGenericOpenAPIErrorWithBodyAndModel(localVarHTTPResponse.Status, localVarBody, v)
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v AccessCodesListAccessCodes500Response
			err = a.Client.Decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr = internal.NewGenericOpenAPIErrorWithBody(err.Error(), localVarBody)
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr = internal.NewGenericOpenAPIErrorWithBodyAndModel(localVarHTTPResponse.Status, localVarBody, v)
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.Client.Decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := internal.NewGenericOpenAPIErrorWithBody(err.Error(), localVarBody)
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiInternalDomainListsListInternalDomainsRequest struct {
	ctx        context.Context
	ApiService InternalDomainListsAPI
	filter     *string
	fields     *string
	offset     *int32
	limit      *int32
	pageToken  *string
	tfilter    *string
	torderBy   *string
}

// A collection of response resources can be filtered by a logical expression string that includes JSON tag references to values in each resource, literal values, and logical operators. If a resource does not have the specified tag, its value is assumed to be null.  Literal values include numbers (integer and floating-point), and quoted (both single- or double-quoted) literal strings, and &#39;null&#39;.  You can filter by following fields:  | Name               | type   | Supported Op                | | ------------------ | ------ | --------------------------- | | id                 | int32  | !&#x3D;, &#x3D;&#x3D;, &gt;, &lt;, &lt;&#x3D;, &gt;&#x3D;        | | name               | string | !&#x3D;, &#x3D;&#x3D;, ~, !~, &gt;, &lt;, &lt;&#x3D;, &gt;&#x3D; | | description        | string | !&#x3D;, &#x3D;&#x3D;, ~, !~, &gt;, &lt;, &lt;&#x3D;, &gt;&#x3D; | | items              | string | ~, !~                       | | is_default         | bool   | !&#x3D;, &#x3D;&#x3D;                      |  In addition grouping operators are supported:  | Op  | Description          | | --- | -------------------- | | and | Logical AND          | | or  | Logical OR           | | not | Logical NOT          | | ()  | Grouping Operators  |  Example: &#x60;&#x60;&#x60; ?_filter&#x3D;\&quot;((name&#x3D;&#x3D;&#39;internal_dom_a&#39;)or(name~&#39;internal_dom_b&#39;))\&quot; &#x60;&#x60;&#x60;
func (r ApiInternalDomainListsListInternalDomainsRequest) Filter(filter string) ApiInternalDomainListsListInternalDomainsRequest {
	r.filter = &filter
	return r
}

// A collection of response resources can be transformed by specifying a set of JSON tags to be returned. For a “flat” resource, the tag name is straightforward. If field selection is allowed on non-flat hierarchical resources, the service should implement a qualified naming scheme such as dot-qualification to reference data down the hierarchy. If a resource does not have the specified tag, the tag does not appear in the output resource.  Specify this parameter as a comma-separated list of JSON tag names.
func (r ApiInternalDomainListsListInternalDomainsRequest) Fields(fields string) ApiInternalDomainListsListInternalDomainsRequest {
	r.fields = &fields
	return r
}

// The integer index (zero-origin) of the offset into a collection of resources. If omitted or null the value is assumed to be &#39;0&#39;.
func (r ApiInternalDomainListsListInternalDomainsRequest) Offset(offset int32) ApiInternalDomainListsListInternalDomainsRequest {
	r.offset = &offset
	return r
}

// The integer number of resources to be returned in the response. The service may impose maximum value. If omitted the service may impose a default value.
func (r ApiInternalDomainListsListInternalDomainsRequest) Limit(limit int32) ApiInternalDomainListsListInternalDomainsRequest {
	r.limit = &limit
	return r
}

// The service-defined string used to identify a page of resources. A null value indicates the first page.
func (r ApiInternalDomainListsListInternalDomainsRequest) PageToken(pageToken string) ApiInternalDomainListsListInternalDomainsRequest {
	r.pageToken = &pageToken
	return r
}

// Filtering by tags.
func (r ApiInternalDomainListsListInternalDomainsRequest) Tfilter(tfilter string) ApiInternalDomainListsListInternalDomainsRequest {
	r.tfilter = &tfilter
	return r
}

// Sorting by tags.
func (r ApiInternalDomainListsListInternalDomainsRequest) TorderBy(torderBy string) ApiInternalDomainListsListInternalDomainsRequest {
	r.torderBy = &torderBy
	return r
}

func (r ApiInternalDomainListsListInternalDomainsRequest) Execute() (*AtcfwInternalDomainsMultiResponse, *http.Response, error) {
	return r.ApiService.InternalDomainListsListInternalDomainsExecute(r)
}

/*
InternalDomainListsListInternalDomains List Internal Domains.

Use this method to retrieve information on all Internal Domains objects for the account.

The internal domain list is a transport object for reporting gathering internal domains. This feature allows users to configure internal domains lists for specific DFP and ATEP groups. This lists provides the users to create ‘Internal Domains List’ objects with a name, description, and a list of domains/ip/cidr. These lists are referenced by and attached to DFP, and ATEP groups.
Once attached to DFP, dfp configuration endpoints will return the values under all associated domain lists as domains.

Once attached to ATEP, atep login endpoint will return the values under all associated lists as internal_domain_lists.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiInternalDomainListsListInternalDomainsRequest
*/
func (a *InternalDomainListsAPIService) InternalDomainListsListInternalDomains(ctx context.Context) ApiInternalDomainListsListInternalDomainsRequest {
	return ApiInternalDomainListsListInternalDomainsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return AtcfwInternalDomainsMultiResponse
func (a *InternalDomainListsAPIService) InternalDomainListsListInternalDomainsExecute(r ApiInternalDomainListsListInternalDomainsRequest) (*AtcfwInternalDomainsMultiResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []internal.FormFile
		localVarReturnValue *AtcfwInternalDomainsMultiResponse
	)

	localBasePath, err := a.Client.Cfg.ServerURLWithContext(r.ctx, "InternalDomainListsAPIService.InternalDomainListsListInternalDomains")
	if err != nil {
		return localVarReturnValue, nil, internal.NewGenericOpenAPIError(err.Error())
	}

	localVarPath := localBasePath + "/internal_domain_lists"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filter != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "_filter", r.filter, "")
	}
	if r.fields != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "_fields", r.fields, "")
	}
	if r.offset != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "_offset", r.offset, "")
	}
	if r.limit != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "_limit", r.limit, "")
	}
	if r.pageToken != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "_page_token", r.pageToken, "")
	}
	if r.tfilter != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "_tfilter", r.tfilter, "")
	}
	if r.torderBy != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "_torder_by", r.torderBy, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := internal.SelectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := internal.SelectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.Client.PrepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.Client.CallAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := internal.NewGenericOpenAPIErrorWithBody(localVarHTTPResponse.Status, localVarBody)
		if localVarHTTPResponse.StatusCode == 500 {
			var v AccessCodesListAccessCodes500Response
			err = a.Client.Decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr = internal.NewGenericOpenAPIErrorWithBody(err.Error(), localVarBody)
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr = internal.NewGenericOpenAPIErrorWithBodyAndModel(localVarHTTPResponse.Status, localVarBody, v)
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.Client.Decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := internal.NewGenericOpenAPIErrorWithBody(err.Error(), localVarBody)
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiInternalDomainListsReadInternalDomainsRequest struct {
	ctx        context.Context
	ApiService InternalDomainListsAPI
	id         int32
	fields     *string
	name       *string
	offset     *int32
	limit      *int32
	pageToken  *string
}

// A collection of response resources can be transformed by specifying a set of JSON tags to be returned. For a “flat” resource, the tag name is straightforward. If field selection is allowed on non-flat hierarchical resources, the service should implement a qualified naming scheme such as dot-qualification to reference data down the hierarchy. If a resource does not have the specified tag, the tag does not appear in the output resource.  Specify this parameter as a comma-separated list of JSON tag names.
func (r ApiInternalDomainListsReadInternalDomainsRequest) Fields(fields string) ApiInternalDomainListsReadInternalDomainsRequest {
	r.fields = &fields
	return r
}

// The name of InternalDomains object. Used if id&#x3D;&#x3D;0.
func (r ApiInternalDomainListsReadInternalDomainsRequest) Name(name string) ApiInternalDomainListsReadInternalDomainsRequest {
	r.name = &name
	return r
}

// The integer index (zero-origin) of the offset into a collection of resources. If omitted or null the value is assumed to be &#39;0&#39;.
func (r ApiInternalDomainListsReadInternalDomainsRequest) Offset(offset int32) ApiInternalDomainListsReadInternalDomainsRequest {
	r.offset = &offset
	return r
}

// The integer number of resources to be returned in the response. The service may impose maximum value. If omitted the service may impose a default value.
func (r ApiInternalDomainListsReadInternalDomainsRequest) Limit(limit int32) ApiInternalDomainListsReadInternalDomainsRequest {
	r.limit = &limit
	return r
}

// The service-defined string used to identify a page of resources. A null value indicates the first page.
func (r ApiInternalDomainListsReadInternalDomainsRequest) PageToken(pageToken string) ApiInternalDomainListsReadInternalDomainsRequest {
	r.pageToken = &pageToken
	return r
}

func (r ApiInternalDomainListsReadInternalDomainsRequest) Execute() (*AtcfwInternalDomainsReadResponse, *http.Response, error) {
	return r.ApiService.InternalDomainListsReadInternalDomainsExecute(r)
}

/*
InternalDomainListsReadInternalDomains Read Internal Domains.

Use this method to read Internal Domains objects for the account by a internal domain list id.

The internal domain list is a transport object for reporting gathering internal domains. This feature allows users to configure internal domains lists for specific DFP and ATEP groups. This lists provides the users to create ‘Internal Domains List’ objects with a name, description, and a list of domains/ip/cidr. These lists are referenced by and attached to DFP, and ATEP groups.
Once attached to DFP, dfp configuration endpoints will return the values under all associated domain lists as domains.

Once attached to ATEP, atep login endpoint will return the values under all associated lists as internal_domain_lists.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The Internal Domains object identifier.
	@return ApiInternalDomainListsReadInternalDomainsRequest
*/
func (a *InternalDomainListsAPIService) InternalDomainListsReadInternalDomains(ctx context.Context, id int32) ApiInternalDomainListsReadInternalDomainsRequest {
	return ApiInternalDomainListsReadInternalDomainsRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return AtcfwInternalDomainsReadResponse
func (a *InternalDomainListsAPIService) InternalDomainListsReadInternalDomainsExecute(r ApiInternalDomainListsReadInternalDomainsRequest) (*AtcfwInternalDomainsReadResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []internal.FormFile
		localVarReturnValue *AtcfwInternalDomainsReadResponse
	)

	localBasePath, err := a.Client.Cfg.ServerURLWithContext(r.ctx, "InternalDomainListsAPIService.InternalDomainListsReadInternalDomains")
	if err != nil {
		return localVarReturnValue, nil, internal.NewGenericOpenAPIError(err.Error())
	}

	localVarPath := localBasePath + "/internal_domain_lists/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(internal.ParameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "_fields", r.fields, "")
	}
	if r.name != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "")
	}
	if r.offset != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "_offset", r.offset, "")
	}
	if r.limit != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "_limit", r.limit, "")
	}
	if r.pageToken != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "_page_token", r.pageToken, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := internal.SelectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := internal.SelectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.Client.PrepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.Client.CallAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := internal.NewGenericOpenAPIErrorWithBody(localVarHTTPResponse.Status, localVarBody)
		if localVarHTTPResponse.StatusCode == 404 {
			var v InternalDomainListsReadInternalDomains404Response
			err = a.Client.Decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr = internal.NewGenericOpenAPIErrorWithBody(err.Error(), localVarBody)
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr = internal.NewGenericOpenAPIErrorWithBodyAndModel(localVarHTTPResponse.Status, localVarBody, v)
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v AccessCodesListAccessCodes500Response
			err = a.Client.Decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr = internal.NewGenericOpenAPIErrorWithBody(err.Error(), localVarBody)
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr = internal.NewGenericOpenAPIErrorWithBodyAndModel(localVarHTTPResponse.Status, localVarBody, v)
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.Client.Decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := internal.NewGenericOpenAPIErrorWithBody(err.Error(), localVarBody)
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiInternalDomainListsUpdateInternalDomainsRequest struct {
	ctx        context.Context
	ApiService InternalDomainListsAPI
	id         int32
	body       *AtcfwInternalDomains
}

// The Internal Domains object.
func (r ApiInternalDomainListsUpdateInternalDomainsRequest) Body(body AtcfwInternalDomains) ApiInternalDomainListsUpdateInternalDomainsRequest {
	r.body = &body
	return r
}

func (r ApiInternalDomainListsUpdateInternalDomainsRequest) Execute() (*AtcfwInternalDomainsUpdateResponse, *http.Response, error) {
	return r.ApiService.InternalDomainListsUpdateInternalDomainsExecute(r)
}

/*
InternalDomainListsUpdateInternalDomains Update Internal Domains.

Use this method to update Internal Domains objects for the account by a internal domain list id.

The internal domain list is a transport object for reporting gathering internal domains. This feature allows users to configure internal domains lists for specific DFP and ATEP groups. This lists provides the users to create ‘Internal Domains List’ objects with a name, description, and a list of domains/ip/cidr. These lists are referenced by and attached to DFP, and ATEP groups.
Once attached to DFP, dfp configuration endpoints will return the values under all associated domain lists as domains.

Once attached to ATEP, atep login endpoint will return the values under all associated lists as internal_domain_lists.

Required:
- name
- internal_domains

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The Internal Domain object identifier.
	@return ApiInternalDomainListsUpdateInternalDomainsRequest
*/
func (a *InternalDomainListsAPIService) InternalDomainListsUpdateInternalDomains(ctx context.Context, id int32) ApiInternalDomainListsUpdateInternalDomainsRequest {
	return ApiInternalDomainListsUpdateInternalDomainsRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return AtcfwInternalDomainsUpdateResponse
func (a *InternalDomainListsAPIService) InternalDomainListsUpdateInternalDomainsExecute(r ApiInternalDomainListsUpdateInternalDomainsRequest) (*AtcfwInternalDomainsUpdateResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []internal.FormFile
		localVarReturnValue *AtcfwInternalDomainsUpdateResponse
	)

	localBasePath, err := a.Client.Cfg.ServerURLWithContext(r.ctx, "InternalDomainListsAPIService.InternalDomainListsUpdateInternalDomains")
	if err != nil {
		return localVarReturnValue, nil, internal.NewGenericOpenAPIError(err.Error())
	}

	localVarPath := localBasePath + "/internal_domain_lists/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(internal.ParameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, internal.ReportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := internal.SelectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := internal.SelectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.Client.PrepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.Client.CallAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := internal.NewGenericOpenAPIErrorWithBody(localVarHTTPResponse.Status, localVarBody)
		if localVarHTTPResponse.StatusCode == 400 {
			var v InternalDomainListsUpdateInternalDomains400Response
			err = a.Client.Decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr = internal.NewGenericOpenAPIErrorWithBody(err.Error(), localVarBody)
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr = internal.NewGenericOpenAPIErrorWithBodyAndModel(localVarHTTPResponse.Status, localVarBody, v)
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v InternalDomainListsUpdateInternalDomains404Response
			err = a.Client.Decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr = internal.NewGenericOpenAPIErrorWithBody(err.Error(), localVarBody)
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr = internal.NewGenericOpenAPIErrorWithBodyAndModel(localVarHTTPResponse.Status, localVarBody, v)
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v InternalDomainListsCreateInternalDomains409Response
			err = a.Client.Decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr = internal.NewGenericOpenAPIErrorWithBody(err.Error(), localVarBody)
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr = internal.NewGenericOpenAPIErrorWithBodyAndModel(localVarHTTPResponse.Status, localVarBody, v)
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v AccessCodesListAccessCodes500Response
			err = a.Client.Decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr = internal.NewGenericOpenAPIErrorWithBody(err.Error(), localVarBody)
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr = internal.NewGenericOpenAPIErrorWithBodyAndModel(localVarHTTPResponse.Status, localVarBody, v)
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.Client.Decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := internal.NewGenericOpenAPIErrorWithBody(err.Error(), localVarBody)
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	return localVarReturnValue, localVarHTTPResponse, nil
}
