/*
BloxOne Anycast API

Anycast capability enables HA (High Availability) configuration of BloxOne applications that run on equipment located on customer's premises (on-prem hosts). Anycast supports DNS, as well as DNS-forwarding services.  Anycast-enabled application setups use multiple on-premises installations for one particular application type. Multiple application instances are configured to use the same endpoint address. Anycast capability is collocated with such application instance, monitoring the local application instance and advertising to the upstream router (a customer equipment) a per-instance, local route to the common application endpoint address, as long as the local application instance is available. Depending on the type of the upstream router, the customer may configure local route advertisement via either BGP (Boarder Gateway Protocol) or OSPF (Open Shortest Path First) routing protocols. Both protocols may be enabled as well. Multiple routes to the common application service address provide redundancy without the need to reconfigure application clients.  Should an application instance become unavailable, the local route advertisements stop, resulting in withdrawal of the route (in the upstream router) to the application instance that has gone out of service and ensuring that subsequent application requests thus get routed to the remaining available application instances.

API version: v1
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package anycast

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/infobloxopen/bloxone-go-client/internal"
)

type OnPremAnycastManagerAPI interface {
	/*
			CreateAnycastConfig Create Anycast Configuration

			Use this method to create anycast configuration, as per the specified payload.
		@responses.400._error {"code": "INVALID_ARGUMENT", "message": "", "status": 400}
		@responses.500._error {"code": "INTERNAL", "message": "Internal Server Error", "status": 500}

			@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			@return OnPremAnycastManagerAPICreateAnycastConfigRequest
	*/
	CreateAnycastConfig(ctx context.Context) OnPremAnycastManagerAPICreateAnycastConfigRequest

	// CreateAnycastConfigExecute executes the request
	//  @return AnycastConfigResponse
	CreateAnycastConfigExecute(r OnPremAnycastManagerAPICreateAnycastConfigRequest) (*AnycastConfigResponse, *http.Response, error)
	/*
			CreateAnycastVersion Create Anycast Version

			Use this method to create anycast 2.0 version for the account ID
		@responses.500._error {"code": "INTERNAL", "message": "Internal Server Error", "status": 500}

			@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			@param id
			@return OnPremAnycastManagerAPICreateAnycastVersionRequest
	*/
	CreateAnycastVersion(ctx context.Context, id int64) OnPremAnycastManagerAPICreateAnycastVersionRequest

	// CreateAnycastVersionExecute executes the request
	//  @return map[string]interface{}
	CreateAnycastVersionExecute(r OnPremAnycastManagerAPICreateAnycastVersionRequest) (map[string]interface{}, *http.Response, error)
	/*
			DeleteAnycastConfig Delete Anycast Configuration

			Use this method to delete the addressed anycast configuration.
		@responses.400._error {"code": "INVALID_ARGUMENT", "message": "", "status": 400}
		@responses.500._error {"code": "INTERNAL", "message": "Internal Server Error", "status": 500}

			@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			@param id
			@return OnPremAnycastManagerAPIDeleteAnycastConfigRequest
	*/
	DeleteAnycastConfig(ctx context.Context, id int64) OnPremAnycastManagerAPIDeleteAnycastConfigRequest

	// DeleteAnycastConfigExecute executes the request
	//  @return map[string]interface{}
	DeleteAnycastConfigExecute(r OnPremAnycastManagerAPIDeleteAnycastConfigRequest) (map[string]interface{}, *http.Response, error)
	/*
			DeleteAnycastVersion Delete anycast version

			Use this method to delete anycast 2.0 version associated with the given account id
		@responses.404._error {"code": "NOT_FOUND", "message": "", "status": 404}
		@responses.500._error {"code": "INTERNAL", "message": "Internal Server Error", "status": 500}

			@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			@param id
			@return OnPremAnycastManagerAPIDeleteAnycastVersionRequest
	*/
	DeleteAnycastVersion(ctx context.Context, id int64) OnPremAnycastManagerAPIDeleteAnycastVersionRequest

	// DeleteAnycastVersionExecute executes the request
	//  @return map[string]interface{}
	DeleteAnycastVersionExecute(r OnPremAnycastManagerAPIDeleteAnycastVersionRequest) (map[string]interface{}, *http.Response, error)
	/*
			DeleteOnpremHost Delete On-Prem Host

			Use this method to delete the addressed on-prem host.
		@responses.400._error {"code": "INVALID_ARGUMENT", "message": "", "status": 400}
		@responses.404._error {"code": "NOT_FOUND", "message": "", "status": 404}
		@responses.500._error {"code": "INTERNAL", "message": "Internal Server Error", "status": 500}

			@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			@param id
			@return OnPremAnycastManagerAPIDeleteOnpremHostRequest
	*/
	DeleteOnpremHost(ctx context.Context, id int64) OnPremAnycastManagerAPIDeleteOnpremHostRequest

	// DeleteOnpremHostExecute executes the request
	//  @return map[string]interface{}
	DeleteOnpremHostExecute(r OnPremAnycastManagerAPIDeleteOnpremHostRequest) (map[string]interface{}, *http.Response, error)
	/*
			GetAnycastConfig Retrieve Anycast Configuration

			Use this method to retrieve the specified anycast configuration, together with the list of member hosts.
		@responses.400._error {"code": "INVALID_ARGUMENT", "message": "", "status": 400}
		@responses.404._error {"code": "NOT_FOUND", "message": "", "status": 404}
		@responses.500._error {"code": "INTERNAL", "message": "Internal Server Error", "status": 500}

			@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			@param id
			@return OnPremAnycastManagerAPIGetAnycastConfigRequest
	*/
	GetAnycastConfig(ctx context.Context, id int64) OnPremAnycastManagerAPIGetAnycastConfigRequest

	// GetAnycastConfigExecute executes the request
	//  @return AnycastConfigResponse
	GetAnycastConfigExecute(r OnPremAnycastManagerAPIGetAnycastConfigRequest) (*AnycastConfigResponse, *http.Response, error)
	/*
			GetAnycastConfigList Retrieve Multiple Anycast Configurations

			Without any filtering, use this method to retrieve all named anycast configurations for the account of authorization. Anycast configuration comprises common anycast configuration data that is defined in support of one service on a set of on-prem hosts. The anycast configurations resulting from this call will not include the list(s) of member hosts. Retrieving the list of member hosts requires the GET operation on single anycast configuration resource. If the account has no anycast configurations defined, the result of this call will be an empty list.
		@responses.500._error {"code": "INTERNAL", "message": "Internal Server Error", "status": 500}

			@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			@return OnPremAnycastManagerAPIGetAnycastConfigListRequest
	*/
	GetAnycastConfigList(ctx context.Context) OnPremAnycastManagerAPIGetAnycastConfigListRequest

	// GetAnycastConfigListExecute executes the request
	//  @return GetAnycastConfigListResponse
	GetAnycastConfigListExecute(r OnPremAnycastManagerAPIGetAnycastConfigListRequest) (*GetAnycastConfigListResponse, *http.Response, error)
	/*
			GetAnycastVersion Retrieve Anycast Version

			Use this method to retrieve the anycast version for the given account id
		@responses.404._error {"code": "NOT_FOUND", "message": "", "status": 404}
		@responses.500._error {"code": "INTERNAL", "message": "Internal Server Error", "status": 500}

			@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			@param id
			@return OnPremAnycastManagerAPIGetAnycastVersionRequest
	*/
	GetAnycastVersion(ctx context.Context, id int64) OnPremAnycastManagerAPIGetAnycastVersionRequest

	// GetAnycastVersionExecute executes the request
	//  @return AnycastVersion
	GetAnycastVersionExecute(r OnPremAnycastManagerAPIGetAnycastVersionRequest) (*AnycastVersion, *http.Response, error)
	/*
			GetOnpremConfig Retrieve Generated, Per-Host Anycast Configuration

			Use this method to retrieve generated anycast configuration for anycast-enabled on-prem host. Retrieved configuration includes both interface and routing configuration. See common config manager documentation for the description of the returned payload. "ophid" is the system-assigned unique character-string identifier of the host. "version" can be either the timestamp of the configuration version that is sought after, or the word "latest". "latest" signifies the most recent generated configuration for this host.
		@responses.400._error {"code": "INVALID_ARGUMENT", "message": "", "status": 400}
		@responses.404._error {"code": "NOT_FOUND", "message": "", "status": 404}
		@responses.500._error {"code": "INTERNAL", "message": "Internal Server Error", "status": 500}

			@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			@param ophid
			@param version
			@return OnPremAnycastManagerAPIGetOnpremConfigRequest
	*/
	GetOnpremConfig(ctx context.Context, ophid string, version string) OnPremAnycastManagerAPIGetOnpremConfigRequest

	// GetOnpremConfigExecute executes the request
	//  @return ServiceConfig
	GetOnpremConfigExecute(r OnPremAnycastManagerAPIGetOnpremConfigRequest) (*ServiceConfig, *http.Response, error)
	/*
			GetOnpremConfig2 Retrieve Generated, Per-Host Anycast Configuration

			Use this method to retrieve generated anycast configuration for anycast-enabled on-prem host. Retrieved configuration includes both interface and routing configuration. See common config manager documentation for the description of the returned payload. "ophid" is the system-assigned unique character-string identifier of the host. "version" can be either the timestamp of the configuration version that is sought after, or the word "latest". "latest" signifies the most recent generated configuration for this host.
		@responses.400._error {"code": "INVALID_ARGUMENT", "message": "", "status": 400}
		@responses.404._error {"code": "NOT_FOUND", "message": "", "status": 404}
		@responses.500._error {"code": "INTERNAL", "message": "Internal Server Error", "status": 500}

			@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			@param ophid
			@param version
			@return OnPremAnycastManagerAPIGetOnpremConfig2Request
	*/
	GetOnpremConfig2(ctx context.Context, ophid string, version string) OnPremAnycastManagerAPIGetOnpremConfig2Request

	// GetOnpremConfig2Execute executes the request
	//  @return ServiceConfig
	GetOnpremConfig2Execute(r OnPremAnycastManagerAPIGetOnpremConfig2Request) (*ServiceConfig, *http.Response, error)
	/*
			GetOnpremHost Retrieve On-Prem Host

			Use this method to retrieve the specified on-prem host from the anycast database.
		@responses.400._error {"code": "INVALID_ARGUMENT", "message": "", "status": 400}
		@responses.404._error {"code": "NOT_FOUND", "message": "", "status": 404}
		@responses.500._error {"code": "INTERNAL", "message": "Internal Server Error", "status": 500}

			@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			@param id
			@return OnPremAnycastManagerAPIGetOnpremHostRequest
	*/
	GetOnpremHost(ctx context.Context, id int64) OnPremAnycastManagerAPIGetOnpremHostRequest

	// GetOnpremHostExecute executes the request
	//  @return OnpremHostResponse
	GetOnpremHostExecute(r OnPremAnycastManagerAPIGetOnpremHostRequest) (*OnpremHostResponse, *http.Response, error)
	/*
			GetStatus Retrieve Configuration Status

			Use this method to retrieve configuration status for the specified host. The configuration status is retrieved from the anycast service database.  "ophid" is the system-assigned unique character-string identifier of the host. "version" parameter can be either the timestamp of the configuration version that is sought after, or the word "latest". "latest' signifies the most recent generated configuration for this host.
		@responses.400._error {"code": "INVALID_ARGUMENT", "message": "", "status": 400}
		@responses.404._error {"code": "NOT_FOUND", "message": "", "status": 404}
		@responses.500._error {"code": "INTERNAL", "message": "Internal Server Error", "status": 500}

			@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			@param ophid
			@return OnPremAnycastManagerAPIGetStatusRequest
	*/
	GetStatus(ctx context.Context, ophid string) OnPremAnycastManagerAPIGetStatusRequest

	// GetStatusExecute executes the request
	//  @return ServiceStatusUpdateRequest
	GetStatusExecute(r OnPremAnycastManagerAPIGetStatusRequest) (*ServiceStatusUpdateRequest, *http.Response, error)
	/*
			GetStatus2 Retrieve Configuration Status

			Use this method to retrieve configuration status for the specified host. The configuration status is retrieved from the anycast service database.  "ophid" is the system-assigned unique character-string identifier of the host. "version" parameter can be either the timestamp of the configuration version that is sought after, or the word "latest". "latest' signifies the most recent generated configuration for this host.
		@responses.400._error {"code": "INVALID_ARGUMENT", "message": "", "status": 400}
		@responses.404._error {"code": "NOT_FOUND", "message": "", "status": 404}
		@responses.500._error {"code": "INTERNAL", "message": "Internal Server Error", "status": 500}

			@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			@param ophid
			@return OnPremAnycastManagerAPIGetStatus2Request
	*/
	GetStatus2(ctx context.Context, ophid string) OnPremAnycastManagerAPIGetStatus2Request

	// GetStatus2Execute executes the request
	//  @return ServiceStatusUpdateRequest
	GetStatus2Execute(r OnPremAnycastManagerAPIGetStatus2Request) (*ServiceStatusUpdateRequest, *http.Response, error)
	/*
			ListAnycastConfigsWithRuntimeStatus Read list of Anycast Configurations

			Without any filtering, use this method to retrieve all named anycast configurations for the account of authorization. Anycast configuration comprises common anycast configuration data that is defined in support of one service on a set of on-prem hosts. The anycast configurations resulting from this call will not include the list(s) of member hosts. Retrieving the list of member hosts requires the GET operation on single anycast configuration resource. If the account has no anycast configurations defined, the result of this call will be an empty list.
		@responses.500._error {"code": "INTERNAL", "message": "Internal Server Error", "status": 500}

			@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			@return OnPremAnycastManagerAPIListAnycastConfigsWithRuntimeStatusRequest
	*/
	ListAnycastConfigsWithRuntimeStatus(ctx context.Context) OnPremAnycastManagerAPIListAnycastConfigsWithRuntimeStatusRequest

	// ListAnycastConfigsWithRuntimeStatusExecute executes the request
	//  @return GetAnycastConfigListResponse
	ListAnycastConfigsWithRuntimeStatusExecute(r OnPremAnycastManagerAPIListAnycastConfigsWithRuntimeStatusRequest) (*GetAnycastConfigListResponse, *http.Response, error)
	/*
			ReadAnycastConfigWithRuntimeStatus Read Anycast Configuration

			Use this method to retrieve the specified anycast configuration, together with the list of member hosts.
		@responses.400._error {"code": "INVALID_ARGUMENT", "message": "", "status": 400}
		@responses.404._error {"code": "NOT_FOUND", "message": "", "status": 404}
		@responses.500._error {"code": "INTERNAL", "message": "Internal Server Error", "status": 500}

			@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			@param id
			@return OnPremAnycastManagerAPIReadAnycastConfigWithRuntimeStatusRequest
	*/
	ReadAnycastConfigWithRuntimeStatus(ctx context.Context, id int64) OnPremAnycastManagerAPIReadAnycastConfigWithRuntimeStatusRequest

	// ReadAnycastConfigWithRuntimeStatusExecute executes the request
	//  @return AnycastConfigResponse
	ReadAnycastConfigWithRuntimeStatusExecute(r OnPremAnycastManagerAPIReadAnycastConfigWithRuntimeStatusRequest) (*AnycastConfigResponse, *http.Response, error)
	/*
			UpdateAnycastConfig Create or Update Anycast Configuration

			Use this method to replace the addressed anycast configuration with configuration from the payload. If the addressed configuration does not exist, it will be created. Anycast configuration specified in the payload may contain the list of on-prem hosts that are supposed to be established as members of the specified configuration. If the anycast service has no information about one or more hosts from this list, such hosts will be created in the anycast service database. Note that the anycast service includes a background capability that verifies the validity of host data entered this way. This capability will delete any hosts created in this way that are determined to be invalid.
		@responses.400._error {"code": "INVALID_ARGUMENT", "message": "", "status": 400}
		@responses.500._error {"code": "INTERNAL", "message": "Internal Server Error", "status": 500}

			@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			@param id
			@return OnPremAnycastManagerAPIUpdateAnycastConfigRequest
	*/
	UpdateAnycastConfig(ctx context.Context, id int64) OnPremAnycastManagerAPIUpdateAnycastConfigRequest

	// UpdateAnycastConfigExecute executes the request
	//  @return AnycastConfigResponse
	UpdateAnycastConfigExecute(r OnPremAnycastManagerAPIUpdateAnycastConfigRequest) (*AnycastConfigResponse, *http.Response, error)
	/*
			UpdateOnpremHost Create or Update On-Prem Host

			Use this method to create or update the addressed host as per the specified payload. The payload is supposed to provide complete replacement for the host data. If the addressed host does not exist, it will be created.
		@responses.400._error {"code": "INVALID_ARGUMENT", "message": "", "status": 400}
		@responses.500._error {"code": "INTERNAL", "message": "Internal Server Error", "status": 500}

			@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			@param id Numeric host identifier
			@return OnPremAnycastManagerAPIUpdateOnpremHostRequest
	*/
	UpdateOnpremHost(ctx context.Context, id int64) OnPremAnycastManagerAPIUpdateOnpremHostRequest

	// UpdateOnpremHostExecute executes the request
	//  @return OnpremHostResponse
	UpdateOnpremHostExecute(r OnPremAnycastManagerAPIUpdateOnpremHostRequest) (*OnpremHostResponse, *http.Response, error)
}

// OnPremAnycastManagerAPIService OnPremAnycastManagerAPI service
type OnPremAnycastManagerAPIService internal.Service

type OnPremAnycastManagerAPICreateAnycastConfigRequest struct {
	ctx        context.Context
	ApiService OnPremAnycastManagerAPI
	body       *AnycastConfig
}

func (r OnPremAnycastManagerAPICreateAnycastConfigRequest) Body(body AnycastConfig) OnPremAnycastManagerAPICreateAnycastConfigRequest {
	r.body = &body
	return r
}

func (r OnPremAnycastManagerAPICreateAnycastConfigRequest) Execute() (*AnycastConfigResponse, *http.Response, error) {
	return r.ApiService.CreateAnycastConfigExecute(r)
}

/*
CreateAnycastConfig Create Anycast Configuration

Use this method to create anycast configuration, as per the specified payload.
@responses.400._error {"code": "INVALID_ARGUMENT", "message": "", "status": 400}
@responses.500._error {"code": "INTERNAL", "message": "Internal Server Error", "status": 500}

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return OnPremAnycastManagerAPICreateAnycastConfigRequest
*/
func (a *OnPremAnycastManagerAPIService) CreateAnycastConfig(ctx context.Context) OnPremAnycastManagerAPICreateAnycastConfigRequest {
	return OnPremAnycastManagerAPICreateAnycastConfigRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return AnycastConfigResponse
func (a *OnPremAnycastManagerAPIService) CreateAnycastConfigExecute(r OnPremAnycastManagerAPICreateAnycastConfigRequest) (*AnycastConfigResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []internal.FormFile
		localVarReturnValue *AnycastConfigResponse
	)

	localBasePath, err := a.Client.Cfg.ServerURLWithContext(r.ctx, "OnPremAnycastManagerAPIService.CreateAnycastConfig")
	if err != nil {
		return localVarReturnValue, nil, internal.NewGenericOpenAPIError(err.Error())
	}

	localVarPath := localBasePath + "/accm/ac_configs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, internal.ReportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := internal.SelectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := internal.SelectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.Client.PrepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.Client.CallAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := internal.NewGenericOpenAPIErrorWithBody(localVarHTTPResponse.Status, localVarBody)
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.Client.Decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := internal.NewGenericOpenAPIErrorWithBody(err.Error(), localVarBody)
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	return localVarReturnValue, localVarHTTPResponse, nil
}

type OnPremAnycastManagerAPICreateAnycastVersionRequest struct {
	ctx        context.Context
	ApiService OnPremAnycastManagerAPI
	id         int64
}

func (r OnPremAnycastManagerAPICreateAnycastVersionRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.CreateAnycastVersionExecute(r)
}

/*
CreateAnycastVersion Create Anycast Version

Use this method to create anycast 2.0 version for the account ID
@responses.500._error {"code": "INTERNAL", "message": "Internal Server Error", "status": 500}

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@return OnPremAnycastManagerAPICreateAnycastVersionRequest
*/
func (a *OnPremAnycastManagerAPIService) CreateAnycastVersion(ctx context.Context, id int64) OnPremAnycastManagerAPICreateAnycastVersionRequest {
	return OnPremAnycastManagerAPICreateAnycastVersionRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *OnPremAnycastManagerAPIService) CreateAnycastVersionExecute(r OnPremAnycastManagerAPICreateAnycastVersionRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []internal.FormFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.Client.Cfg.ServerURLWithContext(r.ctx, "OnPremAnycastManagerAPIService.CreateAnycastVersion")
	if err != nil {
		return localVarReturnValue, nil, internal.NewGenericOpenAPIError(err.Error())
	}

	localVarPath := localBasePath + "/accm/ac_version/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(internal.ParameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := internal.SelectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := internal.SelectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.Client.PrepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.Client.CallAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := internal.NewGenericOpenAPIErrorWithBody(localVarHTTPResponse.Status, localVarBody)
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.Client.Decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := internal.NewGenericOpenAPIErrorWithBody(err.Error(), localVarBody)
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	return localVarReturnValue, localVarHTTPResponse, nil
}

type OnPremAnycastManagerAPIDeleteAnycastConfigRequest struct {
	ctx        context.Context
	ApiService OnPremAnycastManagerAPI
	id         int64
}

func (r OnPremAnycastManagerAPIDeleteAnycastConfigRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.DeleteAnycastConfigExecute(r)
}

/*
DeleteAnycastConfig Delete Anycast Configuration

Use this method to delete the addressed anycast configuration.
@responses.400._error {"code": "INVALID_ARGUMENT", "message": "", "status": 400}
@responses.500._error {"code": "INTERNAL", "message": "Internal Server Error", "status": 500}

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@return OnPremAnycastManagerAPIDeleteAnycastConfigRequest
*/
func (a *OnPremAnycastManagerAPIService) DeleteAnycastConfig(ctx context.Context, id int64) OnPremAnycastManagerAPIDeleteAnycastConfigRequest {
	return OnPremAnycastManagerAPIDeleteAnycastConfigRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *OnPremAnycastManagerAPIService) DeleteAnycastConfigExecute(r OnPremAnycastManagerAPIDeleteAnycastConfigRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []internal.FormFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.Client.Cfg.ServerURLWithContext(r.ctx, "OnPremAnycastManagerAPIService.DeleteAnycastConfig")
	if err != nil {
		return localVarReturnValue, nil, internal.NewGenericOpenAPIError(err.Error())
	}

	localVarPath := localBasePath + "/accm/ac_configs/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(internal.ParameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := internal.SelectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := internal.SelectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.Client.PrepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.Client.CallAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := internal.NewGenericOpenAPIErrorWithBody(localVarHTTPResponse.Status, localVarBody)
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.Client.Decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := internal.NewGenericOpenAPIErrorWithBody(err.Error(), localVarBody)
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	return localVarReturnValue, localVarHTTPResponse, nil
}

type OnPremAnycastManagerAPIDeleteAnycastVersionRequest struct {
	ctx        context.Context
	ApiService OnPremAnycastManagerAPI
	id         int64
}

func (r OnPremAnycastManagerAPIDeleteAnycastVersionRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.DeleteAnycastVersionExecute(r)
}

/*
DeleteAnycastVersion Delete anycast version

Use this method to delete anycast 2.0 version associated with the given account id
@responses.404._error {"code": "NOT_FOUND", "message": "", "status": 404}
@responses.500._error {"code": "INTERNAL", "message": "Internal Server Error", "status": 500}

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@return OnPremAnycastManagerAPIDeleteAnycastVersionRequest
*/
func (a *OnPremAnycastManagerAPIService) DeleteAnycastVersion(ctx context.Context, id int64) OnPremAnycastManagerAPIDeleteAnycastVersionRequest {
	return OnPremAnycastManagerAPIDeleteAnycastVersionRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *OnPremAnycastManagerAPIService) DeleteAnycastVersionExecute(r OnPremAnycastManagerAPIDeleteAnycastVersionRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []internal.FormFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.Client.Cfg.ServerURLWithContext(r.ctx, "OnPremAnycastManagerAPIService.DeleteAnycastVersion")
	if err != nil {
		return localVarReturnValue, nil, internal.NewGenericOpenAPIError(err.Error())
	}

	localVarPath := localBasePath + "/accm/ac_version/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(internal.ParameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := internal.SelectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := internal.SelectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.Client.PrepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.Client.CallAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := internal.NewGenericOpenAPIErrorWithBody(localVarHTTPResponse.Status, localVarBody)
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.Client.Decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := internal.NewGenericOpenAPIErrorWithBody(err.Error(), localVarBody)
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	return localVarReturnValue, localVarHTTPResponse, nil
}

type OnPremAnycastManagerAPIDeleteOnpremHostRequest struct {
	ctx        context.Context
	ApiService OnPremAnycastManagerAPI
	id         int64
}

func (r OnPremAnycastManagerAPIDeleteOnpremHostRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.DeleteOnpremHostExecute(r)
}

/*
DeleteOnpremHost Delete On-Prem Host

Use this method to delete the addressed on-prem host.
@responses.400._error {"code": "INVALID_ARGUMENT", "message": "", "status": 400}
@responses.404._error {"code": "NOT_FOUND", "message": "", "status": 404}
@responses.500._error {"code": "INTERNAL", "message": "Internal Server Error", "status": 500}

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@return OnPremAnycastManagerAPIDeleteOnpremHostRequest
*/
func (a *OnPremAnycastManagerAPIService) DeleteOnpremHost(ctx context.Context, id int64) OnPremAnycastManagerAPIDeleteOnpremHostRequest {
	return OnPremAnycastManagerAPIDeleteOnpremHostRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *OnPremAnycastManagerAPIService) DeleteOnpremHostExecute(r OnPremAnycastManagerAPIDeleteOnpremHostRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []internal.FormFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.Client.Cfg.ServerURLWithContext(r.ctx, "OnPremAnycastManagerAPIService.DeleteOnpremHost")
	if err != nil {
		return localVarReturnValue, nil, internal.NewGenericOpenAPIError(err.Error())
	}

	localVarPath := localBasePath + "/accm/op_hosts/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(internal.ParameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := internal.SelectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := internal.SelectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.Client.PrepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.Client.CallAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := internal.NewGenericOpenAPIErrorWithBody(localVarHTTPResponse.Status, localVarBody)
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.Client.Decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := internal.NewGenericOpenAPIErrorWithBody(err.Error(), localVarBody)
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	return localVarReturnValue, localVarHTTPResponse, nil
}

type OnPremAnycastManagerAPIGetAnycastConfigRequest struct {
	ctx        context.Context
	ApiService OnPremAnycastManagerAPI
	id         int64
}

func (r OnPremAnycastManagerAPIGetAnycastConfigRequest) Execute() (*AnycastConfigResponse, *http.Response, error) {
	return r.ApiService.GetAnycastConfigExecute(r)
}

/*
GetAnycastConfig Retrieve Anycast Configuration

Use this method to retrieve the specified anycast configuration, together with the list of member hosts.
@responses.400._error {"code": "INVALID_ARGUMENT", "message": "", "status": 400}
@responses.404._error {"code": "NOT_FOUND", "message": "", "status": 404}
@responses.500._error {"code": "INTERNAL", "message": "Internal Server Error", "status": 500}

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@return OnPremAnycastManagerAPIGetAnycastConfigRequest
*/
func (a *OnPremAnycastManagerAPIService) GetAnycastConfig(ctx context.Context, id int64) OnPremAnycastManagerAPIGetAnycastConfigRequest {
	return OnPremAnycastManagerAPIGetAnycastConfigRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return AnycastConfigResponse
func (a *OnPremAnycastManagerAPIService) GetAnycastConfigExecute(r OnPremAnycastManagerAPIGetAnycastConfigRequest) (*AnycastConfigResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []internal.FormFile
		localVarReturnValue *AnycastConfigResponse
	)

	localBasePath, err := a.Client.Cfg.ServerURLWithContext(r.ctx, "OnPremAnycastManagerAPIService.GetAnycastConfig")
	if err != nil {
		return localVarReturnValue, nil, internal.NewGenericOpenAPIError(err.Error())
	}

	localVarPath := localBasePath + "/accm/ac_configs/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(internal.ParameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := internal.SelectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := internal.SelectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.Client.PrepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.Client.CallAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := internal.NewGenericOpenAPIErrorWithBody(localVarHTTPResponse.Status, localVarBody)
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.Client.Decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := internal.NewGenericOpenAPIErrorWithBody(err.Error(), localVarBody)
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	return localVarReturnValue, localVarHTTPResponse, nil
}

type OnPremAnycastManagerAPIGetAnycastConfigListRequest struct {
	ctx          context.Context
	ApiService   OnPremAnycastManagerAPI
	accountId    *int64
	service      *string
	hostId       *int64
	ophid        *string
	isConfigured *bool
	tfilter      *string
	torderBy     *string
}

func (r OnPremAnycastManagerAPIGetAnycastConfigListRequest) AccountId(accountId int64) OnPremAnycastManagerAPIGetAnycastConfigListRequest {
	r.accountId = &accountId
	return r
}

func (r OnPremAnycastManagerAPIGetAnycastConfigListRequest) Service(service string) OnPremAnycastManagerAPIGetAnycastConfigListRequest {
	r.service = &service
	return r
}

func (r OnPremAnycastManagerAPIGetAnycastConfigListRequest) HostId(hostId int64) OnPremAnycastManagerAPIGetAnycastConfigListRequest {
	r.hostId = &hostId
	return r
}

func (r OnPremAnycastManagerAPIGetAnycastConfigListRequest) Ophid(ophid string) OnPremAnycastManagerAPIGetAnycastConfigListRequest {
	r.ophid = &ophid
	return r
}

func (r OnPremAnycastManagerAPIGetAnycastConfigListRequest) IsConfigured(isConfigured bool) OnPremAnycastManagerAPIGetAnycastConfigListRequest {
	r.isConfigured = &isConfigured
	return r
}

func (r OnPremAnycastManagerAPIGetAnycastConfigListRequest) Tfilter(tfilter string) OnPremAnycastManagerAPIGetAnycastConfigListRequest {
	r.tfilter = &tfilter
	return r
}

func (r OnPremAnycastManagerAPIGetAnycastConfigListRequest) TorderBy(torderBy string) OnPremAnycastManagerAPIGetAnycastConfigListRequest {
	r.torderBy = &torderBy
	return r
}

func (r OnPremAnycastManagerAPIGetAnycastConfigListRequest) Execute() (*GetAnycastConfigListResponse, *http.Response, error) {
	return r.ApiService.GetAnycastConfigListExecute(r)
}

/*
GetAnycastConfigList Retrieve Multiple Anycast Configurations

Without any filtering, use this method to retrieve all named anycast configurations for the account of authorization. Anycast configuration comprises common anycast configuration data that is defined in support of one service on a set of on-prem hosts. The anycast configurations resulting from this call will not include the list(s) of member hosts. Retrieving the list of member hosts requires the GET operation on single anycast configuration resource. If the account has no anycast configurations defined, the result of this call will be an empty list.
@responses.500._error {"code": "INTERNAL", "message": "Internal Server Error", "status": 500}

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return OnPremAnycastManagerAPIGetAnycastConfigListRequest
*/
func (a *OnPremAnycastManagerAPIService) GetAnycastConfigList(ctx context.Context) OnPremAnycastManagerAPIGetAnycastConfigListRequest {
	return OnPremAnycastManagerAPIGetAnycastConfigListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return GetAnycastConfigListResponse
func (a *OnPremAnycastManagerAPIService) GetAnycastConfigListExecute(r OnPremAnycastManagerAPIGetAnycastConfigListRequest) (*GetAnycastConfigListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []internal.FormFile
		localVarReturnValue *GetAnycastConfigListResponse
	)

	localBasePath, err := a.Client.Cfg.ServerURLWithContext(r.ctx, "OnPremAnycastManagerAPIService.GetAnycastConfigList")
	if err != nil {
		return localVarReturnValue, nil, internal.NewGenericOpenAPIError(err.Error())
	}

	localVarPath := localBasePath + "/accm/ac_configs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.accountId != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "account_id", r.accountId, "")
	}
	if r.service != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "service", r.service, "")
	}
	if r.hostId != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "host_id", r.hostId, "")
	}
	if r.ophid != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "ophid", r.ophid, "")
	}
	if r.isConfigured != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "is_configured", r.isConfigured, "")
	}
	if r.tfilter != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "_tfilter", r.tfilter, "")
	}
	if r.torderBy != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "_torder_by", r.torderBy, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := internal.SelectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := internal.SelectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.Client.PrepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.Client.CallAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := internal.NewGenericOpenAPIErrorWithBody(localVarHTTPResponse.Status, localVarBody)
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.Client.Decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := internal.NewGenericOpenAPIErrorWithBody(err.Error(), localVarBody)
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	return localVarReturnValue, localVarHTTPResponse, nil
}

type OnPremAnycastManagerAPIGetAnycastVersionRequest struct {
	ctx        context.Context
	ApiService OnPremAnycastManagerAPI
	id         int64
}

func (r OnPremAnycastManagerAPIGetAnycastVersionRequest) Execute() (*AnycastVersion, *http.Response, error) {
	return r.ApiService.GetAnycastVersionExecute(r)
}

/*
GetAnycastVersion Retrieve Anycast Version

Use this method to retrieve the anycast version for the given account id
@responses.404._error {"code": "NOT_FOUND", "message": "", "status": 404}
@responses.500._error {"code": "INTERNAL", "message": "Internal Server Error", "status": 500}

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@return OnPremAnycastManagerAPIGetAnycastVersionRequest
*/
func (a *OnPremAnycastManagerAPIService) GetAnycastVersion(ctx context.Context, id int64) OnPremAnycastManagerAPIGetAnycastVersionRequest {
	return OnPremAnycastManagerAPIGetAnycastVersionRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return AnycastVersion
func (a *OnPremAnycastManagerAPIService) GetAnycastVersionExecute(r OnPremAnycastManagerAPIGetAnycastVersionRequest) (*AnycastVersion, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []internal.FormFile
		localVarReturnValue *AnycastVersion
	)

	localBasePath, err := a.Client.Cfg.ServerURLWithContext(r.ctx, "OnPremAnycastManagerAPIService.GetAnycastVersion")
	if err != nil {
		return localVarReturnValue, nil, internal.NewGenericOpenAPIError(err.Error())
	}

	localVarPath := localBasePath + "/accm/ac_version/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(internal.ParameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := internal.SelectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := internal.SelectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.Client.PrepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.Client.CallAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := internal.NewGenericOpenAPIErrorWithBody(localVarHTTPResponse.Status, localVarBody)
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.Client.Decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := internal.NewGenericOpenAPIErrorWithBody(err.Error(), localVarBody)
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	return localVarReturnValue, localVarHTTPResponse, nil
}

type OnPremAnycastManagerAPIGetOnpremConfigRequest struct {
	ctx        context.Context
	ApiService OnPremAnycastManagerAPI
	ophid      string
	version    string
	appName    *string
	appVersion *string
}

func (r OnPremAnycastManagerAPIGetOnpremConfigRequest) AppName(appName string) OnPremAnycastManagerAPIGetOnpremConfigRequest {
	r.appName = &appName
	return r
}

func (r OnPremAnycastManagerAPIGetOnpremConfigRequest) AppVersion(appVersion string) OnPremAnycastManagerAPIGetOnpremConfigRequest {
	r.appVersion = &appVersion
	return r
}

func (r OnPremAnycastManagerAPIGetOnpremConfigRequest) Execute() (*ServiceConfig, *http.Response, error) {
	return r.ApiService.GetOnpremConfigExecute(r)
}

/*
GetOnpremConfig Retrieve Generated, Per-Host Anycast Configuration

Use this method to retrieve generated anycast configuration for anycast-enabled on-prem host. Retrieved configuration includes both interface and routing configuration. See common config manager documentation for the description of the returned payload. "ophid" is the system-assigned unique character-string identifier of the host. "version" can be either the timestamp of the configuration version that is sought after, or the word "latest". "latest" signifies the most recent generated configuration for this host.
@responses.400._error {"code": "INVALID_ARGUMENT", "message": "", "status": 400}
@responses.404._error {"code": "NOT_FOUND", "message": "", "status": 404}
@responses.500._error {"code": "INTERNAL", "message": "Internal Server Error", "status": 500}

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param ophid
	@param version
	@return OnPremAnycastManagerAPIGetOnpremConfigRequest
*/
func (a *OnPremAnycastManagerAPIService) GetOnpremConfig(ctx context.Context, ophid string, version string) OnPremAnycastManagerAPIGetOnpremConfigRequest {
	return OnPremAnycastManagerAPIGetOnpremConfigRequest{
		ApiService: a,
		ctx:        ctx,
		ophid:      ophid,
		version:    version,
	}
}

// Execute executes the request
//
//	@return ServiceConfig
func (a *OnPremAnycastManagerAPIService) GetOnpremConfigExecute(r OnPremAnycastManagerAPIGetOnpremConfigRequest) (*ServiceConfig, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []internal.FormFile
		localVarReturnValue *ServiceConfig
	)

	localBasePath, err := a.Client.Cfg.ServerURLWithContext(r.ctx, "OnPremAnycastManagerAPIService.GetOnpremConfig")
	if err != nil {
		return localVarReturnValue, nil, internal.NewGenericOpenAPIError(err.Error())
	}

	localVarPath := localBasePath + "/accm/oph_configs/{ophid}/{version}"
	localVarPath = strings.Replace(localVarPath, "{"+"ophid"+"}", url.PathEscape(internal.ParameterValueToString(r.ophid, "ophid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(internal.ParameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.appName != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "appName", r.appName, "")
	}
	if r.appVersion != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "appVersion", r.appVersion, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := internal.SelectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := internal.SelectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.Client.PrepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.Client.CallAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := internal.NewGenericOpenAPIErrorWithBody(localVarHTTPResponse.Status, localVarBody)
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.Client.Decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := internal.NewGenericOpenAPIErrorWithBody(err.Error(), localVarBody)
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	return localVarReturnValue, localVarHTTPResponse, nil
}

type OnPremAnycastManagerAPIGetOnpremConfig2Request struct {
	ctx        context.Context
	ApiService OnPremAnycastManagerAPI
	ophid      string
	version    string
	appName    *string
	appVersion *string
}

func (r OnPremAnycastManagerAPIGetOnpremConfig2Request) AppName(appName string) OnPremAnycastManagerAPIGetOnpremConfig2Request {
	r.appName = &appName
	return r
}

func (r OnPremAnycastManagerAPIGetOnpremConfig2Request) AppVersion(appVersion string) OnPremAnycastManagerAPIGetOnpremConfig2Request {
	r.appVersion = &appVersion
	return r
}

func (r OnPremAnycastManagerAPIGetOnpremConfig2Request) Execute() (*ServiceConfig, *http.Response, error) {
	return r.ApiService.GetOnpremConfig2Execute(r)
}

/*
GetOnpremConfig2 Retrieve Generated, Per-Host Anycast Configuration

Use this method to retrieve generated anycast configuration for anycast-enabled on-prem host. Retrieved configuration includes both interface and routing configuration. See common config manager documentation for the description of the returned payload. "ophid" is the system-assigned unique character-string identifier of the host. "version" can be either the timestamp of the configuration version that is sought after, or the word "latest". "latest" signifies the most recent generated configuration for this host.
@responses.400._error {"code": "INVALID_ARGUMENT", "message": "", "status": 400}
@responses.404._error {"code": "NOT_FOUND", "message": "", "status": 404}
@responses.500._error {"code": "INTERNAL", "message": "Internal Server Error", "status": 500}

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param ophid
	@param version
	@return OnPremAnycastManagerAPIGetOnpremConfig2Request
*/
func (a *OnPremAnycastManagerAPIService) GetOnpremConfig2(ctx context.Context, ophid string, version string) OnPremAnycastManagerAPIGetOnpremConfig2Request {
	return OnPremAnycastManagerAPIGetOnpremConfig2Request{
		ApiService: a,
		ctx:        ctx,
		ophid:      ophid,
		version:    version,
	}
}

// Execute executes the request
//
//	@return ServiceConfig
func (a *OnPremAnycastManagerAPIService) GetOnpremConfig2Execute(r OnPremAnycastManagerAPIGetOnpremConfig2Request) (*ServiceConfig, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []internal.FormFile
		localVarReturnValue *ServiceConfig
	)

	localBasePath, err := a.Client.Cfg.ServerURLWithContext(r.ctx, "OnPremAnycastManagerAPIService.GetOnpremConfig2")
	if err != nil {
		return localVarReturnValue, nil, internal.NewGenericOpenAPIError(err.Error())
	}

	localVarPath := localBasePath + "/onprem_config/{ophid}/{version}"
	localVarPath = strings.Replace(localVarPath, "{"+"ophid"+"}", url.PathEscape(internal.ParameterValueToString(r.ophid, "ophid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(internal.ParameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.appName != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "appName", r.appName, "")
	}
	if r.appVersion != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "appVersion", r.appVersion, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := internal.SelectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := internal.SelectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.Client.PrepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.Client.CallAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := internal.NewGenericOpenAPIErrorWithBody(localVarHTTPResponse.Status, localVarBody)
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.Client.Decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := internal.NewGenericOpenAPIErrorWithBody(err.Error(), localVarBody)
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	return localVarReturnValue, localVarHTTPResponse, nil
}

type OnPremAnycastManagerAPIGetOnpremHostRequest struct {
	ctx        context.Context
	ApiService OnPremAnycastManagerAPI
	id         int64
}

func (r OnPremAnycastManagerAPIGetOnpremHostRequest) Execute() (*OnpremHostResponse, *http.Response, error) {
	return r.ApiService.GetOnpremHostExecute(r)
}

/*
GetOnpremHost Retrieve On-Prem Host

Use this method to retrieve the specified on-prem host from the anycast database.
@responses.400._error {"code": "INVALID_ARGUMENT", "message": "", "status": 400}
@responses.404._error {"code": "NOT_FOUND", "message": "", "status": 404}
@responses.500._error {"code": "INTERNAL", "message": "Internal Server Error", "status": 500}

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@return OnPremAnycastManagerAPIGetOnpremHostRequest
*/
func (a *OnPremAnycastManagerAPIService) GetOnpremHost(ctx context.Context, id int64) OnPremAnycastManagerAPIGetOnpremHostRequest {
	return OnPremAnycastManagerAPIGetOnpremHostRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return OnpremHostResponse
func (a *OnPremAnycastManagerAPIService) GetOnpremHostExecute(r OnPremAnycastManagerAPIGetOnpremHostRequest) (*OnpremHostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []internal.FormFile
		localVarReturnValue *OnpremHostResponse
	)

	localBasePath, err := a.Client.Cfg.ServerURLWithContext(r.ctx, "OnPremAnycastManagerAPIService.GetOnpremHost")
	if err != nil {
		return localVarReturnValue, nil, internal.NewGenericOpenAPIError(err.Error())
	}

	localVarPath := localBasePath + "/accm/op_hosts/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(internal.ParameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := internal.SelectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := internal.SelectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.Client.PrepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.Client.CallAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := internal.NewGenericOpenAPIErrorWithBody(localVarHTTPResponse.Status, localVarBody)
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.Client.Decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := internal.NewGenericOpenAPIErrorWithBody(err.Error(), localVarBody)
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	return localVarReturnValue, localVarHTTPResponse, nil
}

type OnPremAnycastManagerAPIGetStatusRequest struct {
	ctx        context.Context
	ApiService OnPremAnycastManagerAPI
	ophid      string
}

func (r OnPremAnycastManagerAPIGetStatusRequest) Execute() (*ServiceStatusUpdateRequest, *http.Response, error) {
	return r.ApiService.GetStatusExecute(r)
}

/*
GetStatus Retrieve Configuration Status

Use this method to retrieve configuration status for the specified host. The configuration status is retrieved from the anycast service database.  "ophid" is the system-assigned unique character-string identifier of the host. "version" parameter can be either the timestamp of the configuration version that is sought after, or the word "latest". "latest' signifies the most recent generated configuration for this host.
@responses.400._error {"code": "INVALID_ARGUMENT", "message": "", "status": 400}
@responses.404._error {"code": "NOT_FOUND", "message": "", "status": 404}
@responses.500._error {"code": "INTERNAL", "message": "Internal Server Error", "status": 500}

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param ophid
	@return OnPremAnycastManagerAPIGetStatusRequest
*/
func (a *OnPremAnycastManagerAPIService) GetStatus(ctx context.Context, ophid string) OnPremAnycastManagerAPIGetStatusRequest {
	return OnPremAnycastManagerAPIGetStatusRequest{
		ApiService: a,
		ctx:        ctx,
		ophid:      ophid,
	}
}

// Execute executes the request
//
//	@return ServiceStatusUpdateRequest
func (a *OnPremAnycastManagerAPIService) GetStatusExecute(r OnPremAnycastManagerAPIGetStatusRequest) (*ServiceStatusUpdateRequest, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []internal.FormFile
		localVarReturnValue *ServiceStatusUpdateRequest
	)

	localBasePath, err := a.Client.Cfg.ServerURLWithContext(r.ctx, "OnPremAnycastManagerAPIService.GetStatus")
	if err != nil {
		return localVarReturnValue, nil, internal.NewGenericOpenAPIError(err.Error())
	}

	localVarPath := localBasePath + "/accm/oph_config_statuses/{ophid}/latest"
	localVarPath = strings.Replace(localVarPath, "{"+"ophid"+"}", url.PathEscape(internal.ParameterValueToString(r.ophid, "ophid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := internal.SelectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := internal.SelectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.Client.PrepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.Client.CallAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := internal.NewGenericOpenAPIErrorWithBody(localVarHTTPResponse.Status, localVarBody)
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.Client.Decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := internal.NewGenericOpenAPIErrorWithBody(err.Error(), localVarBody)
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	return localVarReturnValue, localVarHTTPResponse, nil
}

type OnPremAnycastManagerAPIGetStatus2Request struct {
	ctx        context.Context
	ApiService OnPremAnycastManagerAPI
	ophid      string
}

func (r OnPremAnycastManagerAPIGetStatus2Request) Execute() (*ServiceStatusUpdateRequest, *http.Response, error) {
	return r.ApiService.GetStatus2Execute(r)
}

/*
GetStatus2 Retrieve Configuration Status

Use this method to retrieve configuration status for the specified host. The configuration status is retrieved from the anycast service database.  "ophid" is the system-assigned unique character-string identifier of the host. "version" parameter can be either the timestamp of the configuration version that is sought after, or the word "latest". "latest' signifies the most recent generated configuration for this host.
@responses.400._error {"code": "INVALID_ARGUMENT", "message": "", "status": 400}
@responses.404._error {"code": "NOT_FOUND", "message": "", "status": 404}
@responses.500._error {"code": "INTERNAL", "message": "Internal Server Error", "status": 500}

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param ophid
	@return OnPremAnycastManagerAPIGetStatus2Request
*/
func (a *OnPremAnycastManagerAPIService) GetStatus2(ctx context.Context, ophid string) OnPremAnycastManagerAPIGetStatus2Request {
	return OnPremAnycastManagerAPIGetStatus2Request{
		ApiService: a,
		ctx:        ctx,
		ophid:      ophid,
	}
}

// Execute executes the request
//
//	@return ServiceStatusUpdateRequest
func (a *OnPremAnycastManagerAPIService) GetStatus2Execute(r OnPremAnycastManagerAPIGetStatus2Request) (*ServiceStatusUpdateRequest, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []internal.FormFile
		localVarReturnValue *ServiceStatusUpdateRequest
	)

	localBasePath, err := a.Client.Cfg.ServerURLWithContext(r.ctx, "OnPremAnycastManagerAPIService.GetStatus2")
	if err != nil {
		return localVarReturnValue, nil, internal.NewGenericOpenAPIError(err.Error())
	}

	localVarPath := localBasePath + "/onprem_config_statuses/{ophid}/latest"
	localVarPath = strings.Replace(localVarPath, "{"+"ophid"+"}", url.PathEscape(internal.ParameterValueToString(r.ophid, "ophid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := internal.SelectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := internal.SelectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.Client.PrepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.Client.CallAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := internal.NewGenericOpenAPIErrorWithBody(localVarHTTPResponse.Status, localVarBody)
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.Client.Decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := internal.NewGenericOpenAPIErrorWithBody(err.Error(), localVarBody)
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	return localVarReturnValue, localVarHTTPResponse, nil
}

type OnPremAnycastManagerAPIListAnycastConfigsWithRuntimeStatusRequest struct {
	ctx          context.Context
	ApiService   OnPremAnycastManagerAPI
	accountId    *int64
	service      *string
	hostId       *int64
	ophid        *string
	isConfigured *bool
	tfilter      *string
	torderBy     *string
}

func (r OnPremAnycastManagerAPIListAnycastConfigsWithRuntimeStatusRequest) AccountId(accountId int64) OnPremAnycastManagerAPIListAnycastConfigsWithRuntimeStatusRequest {
	r.accountId = &accountId
	return r
}

func (r OnPremAnycastManagerAPIListAnycastConfigsWithRuntimeStatusRequest) Service(service string) OnPremAnycastManagerAPIListAnycastConfigsWithRuntimeStatusRequest {
	r.service = &service
	return r
}

func (r OnPremAnycastManagerAPIListAnycastConfigsWithRuntimeStatusRequest) HostId(hostId int64) OnPremAnycastManagerAPIListAnycastConfigsWithRuntimeStatusRequest {
	r.hostId = &hostId
	return r
}

func (r OnPremAnycastManagerAPIListAnycastConfigsWithRuntimeStatusRequest) Ophid(ophid string) OnPremAnycastManagerAPIListAnycastConfigsWithRuntimeStatusRequest {
	r.ophid = &ophid
	return r
}

func (r OnPremAnycastManagerAPIListAnycastConfigsWithRuntimeStatusRequest) IsConfigured(isConfigured bool) OnPremAnycastManagerAPIListAnycastConfigsWithRuntimeStatusRequest {
	r.isConfigured = &isConfigured
	return r
}

func (r OnPremAnycastManagerAPIListAnycastConfigsWithRuntimeStatusRequest) Tfilter(tfilter string) OnPremAnycastManagerAPIListAnycastConfigsWithRuntimeStatusRequest {
	r.tfilter = &tfilter
	return r
}

func (r OnPremAnycastManagerAPIListAnycastConfigsWithRuntimeStatusRequest) TorderBy(torderBy string) OnPremAnycastManagerAPIListAnycastConfigsWithRuntimeStatusRequest {
	r.torderBy = &torderBy
	return r
}

func (r OnPremAnycastManagerAPIListAnycastConfigsWithRuntimeStatusRequest) Execute() (*GetAnycastConfigListResponse, *http.Response, error) {
	return r.ApiService.ListAnycastConfigsWithRuntimeStatusExecute(r)
}

/*
ListAnycastConfigsWithRuntimeStatus Read list of Anycast Configurations

Without any filtering, use this method to retrieve all named anycast configurations for the account of authorization. Anycast configuration comprises common anycast configuration data that is defined in support of one service on a set of on-prem hosts. The anycast configurations resulting from this call will not include the list(s) of member hosts. Retrieving the list of member hosts requires the GET operation on single anycast configuration resource. If the account has no anycast configurations defined, the result of this call will be an empty list.
@responses.500._error {"code": "INTERNAL", "message": "Internal Server Error", "status": 500}

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return OnPremAnycastManagerAPIListAnycastConfigsWithRuntimeStatusRequest
*/
func (a *OnPremAnycastManagerAPIService) ListAnycastConfigsWithRuntimeStatus(ctx context.Context) OnPremAnycastManagerAPIListAnycastConfigsWithRuntimeStatusRequest {
	return OnPremAnycastManagerAPIListAnycastConfigsWithRuntimeStatusRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return GetAnycastConfigListResponse
func (a *OnPremAnycastManagerAPIService) ListAnycastConfigsWithRuntimeStatusExecute(r OnPremAnycastManagerAPIListAnycastConfigsWithRuntimeStatusRequest) (*GetAnycastConfigListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []internal.FormFile
		localVarReturnValue *GetAnycastConfigListResponse
	)

	localBasePath, err := a.Client.Cfg.ServerURLWithContext(r.ctx, "OnPremAnycastManagerAPIService.ListAnycastConfigsWithRuntimeStatus")
	if err != nil {
		return localVarReturnValue, nil, internal.NewGenericOpenAPIError(err.Error())
	}

	localVarPath := localBasePath + "/accm/ac_runtime_statuses"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.accountId != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "account_id", r.accountId, "")
	}
	if r.service != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "service", r.service, "")
	}
	if r.hostId != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "host_id", r.hostId, "")
	}
	if r.ophid != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "ophid", r.ophid, "")
	}
	if r.isConfigured != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "is_configured", r.isConfigured, "")
	}
	if r.tfilter != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "_tfilter", r.tfilter, "")
	}
	if r.torderBy != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "_torder_by", r.torderBy, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := internal.SelectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := internal.SelectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.Client.PrepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.Client.CallAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := internal.NewGenericOpenAPIErrorWithBody(localVarHTTPResponse.Status, localVarBody)
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.Client.Decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := internal.NewGenericOpenAPIErrorWithBody(err.Error(), localVarBody)
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	return localVarReturnValue, localVarHTTPResponse, nil
}

type OnPremAnycastManagerAPIReadAnycastConfigWithRuntimeStatusRequest struct {
	ctx        context.Context
	ApiService OnPremAnycastManagerAPI
	id         int64
}

func (r OnPremAnycastManagerAPIReadAnycastConfigWithRuntimeStatusRequest) Execute() (*AnycastConfigResponse, *http.Response, error) {
	return r.ApiService.ReadAnycastConfigWithRuntimeStatusExecute(r)
}

/*
ReadAnycastConfigWithRuntimeStatus Read Anycast Configuration

Use this method to retrieve the specified anycast configuration, together with the list of member hosts.
@responses.400._error {"code": "INVALID_ARGUMENT", "message": "", "status": 400}
@responses.404._error {"code": "NOT_FOUND", "message": "", "status": 404}
@responses.500._error {"code": "INTERNAL", "message": "Internal Server Error", "status": 500}

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@return OnPremAnycastManagerAPIReadAnycastConfigWithRuntimeStatusRequest
*/
func (a *OnPremAnycastManagerAPIService) ReadAnycastConfigWithRuntimeStatus(ctx context.Context, id int64) OnPremAnycastManagerAPIReadAnycastConfigWithRuntimeStatusRequest {
	return OnPremAnycastManagerAPIReadAnycastConfigWithRuntimeStatusRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return AnycastConfigResponse
func (a *OnPremAnycastManagerAPIService) ReadAnycastConfigWithRuntimeStatusExecute(r OnPremAnycastManagerAPIReadAnycastConfigWithRuntimeStatusRequest) (*AnycastConfigResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []internal.FormFile
		localVarReturnValue *AnycastConfigResponse
	)

	localBasePath, err := a.Client.Cfg.ServerURLWithContext(r.ctx, "OnPremAnycastManagerAPIService.ReadAnycastConfigWithRuntimeStatus")
	if err != nil {
		return localVarReturnValue, nil, internal.NewGenericOpenAPIError(err.Error())
	}

	localVarPath := localBasePath + "/accm/ac_runtime_statuses/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(internal.ParameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := internal.SelectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := internal.SelectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.Client.PrepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.Client.CallAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := internal.NewGenericOpenAPIErrorWithBody(localVarHTTPResponse.Status, localVarBody)
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.Client.Decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := internal.NewGenericOpenAPIErrorWithBody(err.Error(), localVarBody)
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	return localVarReturnValue, localVarHTTPResponse, nil
}

type OnPremAnycastManagerAPIUpdateAnycastConfigRequest struct {
	ctx        context.Context
	ApiService OnPremAnycastManagerAPI
	id         int64
	body       *AnycastConfig
}

func (r OnPremAnycastManagerAPIUpdateAnycastConfigRequest) Body(body AnycastConfig) OnPremAnycastManagerAPIUpdateAnycastConfigRequest {
	r.body = &body
	return r
}

func (r OnPremAnycastManagerAPIUpdateAnycastConfigRequest) Execute() (*AnycastConfigResponse, *http.Response, error) {
	return r.ApiService.UpdateAnycastConfigExecute(r)
}

/*
UpdateAnycastConfig Create or Update Anycast Configuration

Use this method to replace the addressed anycast configuration with configuration from the payload. If the addressed configuration does not exist, it will be created. Anycast configuration specified in the payload may contain the list of on-prem hosts that are supposed to be established as members of the specified configuration. If the anycast service has no information about one or more hosts from this list, such hosts will be created in the anycast service database. Note that the anycast service includes a background capability that verifies the validity of host data entered this way. This capability will delete any hosts created in this way that are determined to be invalid.
@responses.400._error {"code": "INVALID_ARGUMENT", "message": "", "status": 400}
@responses.500._error {"code": "INTERNAL", "message": "Internal Server Error", "status": 500}

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@return OnPremAnycastManagerAPIUpdateAnycastConfigRequest
*/
func (a *OnPremAnycastManagerAPIService) UpdateAnycastConfig(ctx context.Context, id int64) OnPremAnycastManagerAPIUpdateAnycastConfigRequest {
	return OnPremAnycastManagerAPIUpdateAnycastConfigRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return AnycastConfigResponse
func (a *OnPremAnycastManagerAPIService) UpdateAnycastConfigExecute(r OnPremAnycastManagerAPIUpdateAnycastConfigRequest) (*AnycastConfigResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []internal.FormFile
		localVarReturnValue *AnycastConfigResponse
	)

	localBasePath, err := a.Client.Cfg.ServerURLWithContext(r.ctx, "OnPremAnycastManagerAPIService.UpdateAnycastConfig")
	if err != nil {
		return localVarReturnValue, nil, internal.NewGenericOpenAPIError(err.Error())
	}

	localVarPath := localBasePath + "/accm/ac_configs/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(internal.ParameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, internal.ReportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := internal.SelectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := internal.SelectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.Client.PrepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.Client.CallAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := internal.NewGenericOpenAPIErrorWithBody(localVarHTTPResponse.Status, localVarBody)
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.Client.Decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := internal.NewGenericOpenAPIErrorWithBody(err.Error(), localVarBody)
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	return localVarReturnValue, localVarHTTPResponse, nil
}

type OnPremAnycastManagerAPIUpdateOnpremHostRequest struct {
	ctx        context.Context
	ApiService OnPremAnycastManagerAPI
	id         int64
	body       *OnpremHost
}

func (r OnPremAnycastManagerAPIUpdateOnpremHostRequest) Body(body OnpremHost) OnPremAnycastManagerAPIUpdateOnpremHostRequest {
	r.body = &body
	return r
}

func (r OnPremAnycastManagerAPIUpdateOnpremHostRequest) Execute() (*OnpremHostResponse, *http.Response, error) {
	return r.ApiService.UpdateOnpremHostExecute(r)
}

/*
UpdateOnpremHost Create or Update On-Prem Host

Use this method to create or update the addressed host as per the specified payload. The payload is supposed to provide complete replacement for the host data. If the addressed host does not exist, it will be created.
@responses.400._error {"code": "INVALID_ARGUMENT", "message": "", "status": 400}
@responses.500._error {"code": "INTERNAL", "message": "Internal Server Error", "status": 500}

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Numeric host identifier
	@return OnPremAnycastManagerAPIUpdateOnpremHostRequest
*/
func (a *OnPremAnycastManagerAPIService) UpdateOnpremHost(ctx context.Context, id int64) OnPremAnycastManagerAPIUpdateOnpremHostRequest {
	return OnPremAnycastManagerAPIUpdateOnpremHostRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return OnpremHostResponse
func (a *OnPremAnycastManagerAPIService) UpdateOnpremHostExecute(r OnPremAnycastManagerAPIUpdateOnpremHostRequest) (*OnpremHostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []internal.FormFile
		localVarReturnValue *OnpremHostResponse
	)

	localBasePath, err := a.Client.Cfg.ServerURLWithContext(r.ctx, "OnPremAnycastManagerAPIService.UpdateOnpremHost")
	if err != nil {
		return localVarReturnValue, nil, internal.NewGenericOpenAPIError(err.Error())
	}

	localVarPath := localBasePath + "/accm/op_hosts/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(internal.ParameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, internal.ReportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := internal.SelectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := internal.SelectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.Client.PrepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.Client.CallAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := internal.NewGenericOpenAPIErrorWithBody(localVarHTTPResponse.Status, localVarBody)
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.Client.Decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := internal.NewGenericOpenAPIErrorWithBody(err.Error(), localVarBody)
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	return localVarReturnValue, localVarHTTPResponse, nil
}
