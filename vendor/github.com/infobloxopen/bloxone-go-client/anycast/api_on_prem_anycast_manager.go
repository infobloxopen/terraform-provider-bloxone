/*
BloxOne Anycast API

Anycast capability enables HA (High Availability) configuration of BloxOne applications that run on equipment located on customer's premises (on-prem hosts). Anycast supports DNS, as well as DNS-forwarding services.  Anycast-enabled application setups use multiple on-premises installations for one particular application type. Multiple application instances are configured to use the same endpoint address. Anycast capability is collocated with such application instance, monitoring the local application instance and advertising to the upstream router (a customer equipment) a per-instance, local route to the common application endpoint address, as long as the local application instance is available. Depending on the type of the upstream router, the customer may configure local route advertisement via either BGP (Boarder Gateway Protocol) or OSPF (Open Shortest Path First) routing protocols. Both protocols may be enabled as well. Multiple routes to the common application service address provide redundancy without the need to reconfigure application clients.  Should an application instance become unavailable, the local route advertisements stop, resulting in withdrawal of the route (in the upstream router) to the application instance that has gone out of service and ensuring that subsequent application requests thus get routed to the remaining available application instances.

API version: v1
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package anycast

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/infobloxopen/bloxone-go-client/internal"
)

type OnPremAnycastManagerAPI interface {
	/*
			OnPremAnycastManagerCreateAnycastConfig Create Anycast Configuration

			Use this method to create anycast configuration, as per the specified payload.
		@responses.400._error {"code": "INVALID_ARGUMENT", "message": "", "status": 400}
		@responses.500._error {"code": "INTERNAL", "message": "Internal Server Error", "status": 500}

			@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			@return ApiOnPremAnycastManagerCreateAnycastConfigRequest
	*/
	OnPremAnycastManagerCreateAnycastConfig(ctx context.Context) ApiOnPremAnycastManagerCreateAnycastConfigRequest

	// OnPremAnycastManagerCreateAnycastConfigExecute executes the request
	//  @return ProtoAnycastConfigResponse
	OnPremAnycastManagerCreateAnycastConfigExecute(r ApiOnPremAnycastManagerCreateAnycastConfigRequest) (*ProtoAnycastConfigResponse, *http.Response, error)
	/*
			OnPremAnycastManagerCreateAnycastVersion Create Anycast Version

			Use this method to create anycast 2.0 version for the account ID
		@responses.500._error {"code": "INTERNAL", "message": "Internal Server Error", "status": 500}

			@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			@param id
			@return ApiOnPremAnycastManagerCreateAnycastVersionRequest
	*/
	OnPremAnycastManagerCreateAnycastVersion(ctx context.Context, id int64) ApiOnPremAnycastManagerCreateAnycastVersionRequest

	// OnPremAnycastManagerCreateAnycastVersionExecute executes the request
	//  @return map[string]interface{}
	OnPremAnycastManagerCreateAnycastVersionExecute(r ApiOnPremAnycastManagerCreateAnycastVersionRequest) (map[string]interface{}, *http.Response, error)
	/*
			OnPremAnycastManagerDeleteAnycastConfig Delete Anycast Configuration

			Use this method to delete the addressed anycast configuration.
		@responses.400._error {"code": "INVALID_ARGUMENT", "message": "", "status": 400}
		@responses.500._error {"code": "INTERNAL", "message": "Internal Server Error", "status": 500}

			@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			@param id
			@return ApiOnPremAnycastManagerDeleteAnycastConfigRequest
	*/
	OnPremAnycastManagerDeleteAnycastConfig(ctx context.Context, id int64) ApiOnPremAnycastManagerDeleteAnycastConfigRequest

	// OnPremAnycastManagerDeleteAnycastConfigExecute executes the request
	//  @return map[string]interface{}
	OnPremAnycastManagerDeleteAnycastConfigExecute(r ApiOnPremAnycastManagerDeleteAnycastConfigRequest) (map[string]interface{}, *http.Response, error)
	/*
			OnPremAnycastManagerDeleteAnycastVersion Delete anycast version

			Use this method to delete anycast 2.0 version associated with the given account id
		@responses.404._error {"code": "NOT_FOUND", "message": "", "status": 404}
		@responses.500._error {"code": "INTERNAL", "message": "Internal Server Error", "status": 500}

			@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			@param id
			@return ApiOnPremAnycastManagerDeleteAnycastVersionRequest
	*/
	OnPremAnycastManagerDeleteAnycastVersion(ctx context.Context, id int64) ApiOnPremAnycastManagerDeleteAnycastVersionRequest

	// OnPremAnycastManagerDeleteAnycastVersionExecute executes the request
	//  @return map[string]interface{}
	OnPremAnycastManagerDeleteAnycastVersionExecute(r ApiOnPremAnycastManagerDeleteAnycastVersionRequest) (map[string]interface{}, *http.Response, error)
	/*
			OnPremAnycastManagerDeleteOnpremHost Delete On-Prem Host

			Use this method to delete the addressed on-prem host.
		@responses.400._error {"code": "INVALID_ARGUMENT", "message": "", "status": 400}
		@responses.404._error {"code": "NOT_FOUND", "message": "", "status": 404}
		@responses.500._error {"code": "INTERNAL", "message": "Internal Server Error", "status": 500}

			@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			@param id
			@return ApiOnPremAnycastManagerDeleteOnpremHostRequest
	*/
	OnPremAnycastManagerDeleteOnpremHost(ctx context.Context, id int64) ApiOnPremAnycastManagerDeleteOnpremHostRequest

	// OnPremAnycastManagerDeleteOnpremHostExecute executes the request
	//  @return map[string]interface{}
	OnPremAnycastManagerDeleteOnpremHostExecute(r ApiOnPremAnycastManagerDeleteOnpremHostRequest) (map[string]interface{}, *http.Response, error)
	/*
			OnPremAnycastManagerGetAnycastConfig Retrieve Anycast Configuration

			Use this method to retrieve the specified anycast configuration, together with the list of member hosts.
		@responses.400._error {"code": "INVALID_ARGUMENT", "message": "", "status": 400}
		@responses.404._error {"code": "NOT_FOUND", "message": "", "status": 404}
		@responses.500._error {"code": "INTERNAL", "message": "Internal Server Error", "status": 500}

			@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			@param id
			@return ApiOnPremAnycastManagerGetAnycastConfigRequest
	*/
	OnPremAnycastManagerGetAnycastConfig(ctx context.Context, id int64) ApiOnPremAnycastManagerGetAnycastConfigRequest

	// OnPremAnycastManagerGetAnycastConfigExecute executes the request
	//  @return ProtoAnycastConfigResponse
	OnPremAnycastManagerGetAnycastConfigExecute(r ApiOnPremAnycastManagerGetAnycastConfigRequest) (*ProtoAnycastConfigResponse, *http.Response, error)
	/*
			OnPremAnycastManagerGetAnycastConfigList Retrieve Multiple Anycast Configurations

			Without any filtering, use this method to retrieve all named anycast configurations for the account of authorization. Anycast configuration comprises common anycast configuration data that is defined in support of one service on a set of on-prem hosts. The anycast configurations resulting from this call will not include the list(s) of member hosts. Retrieving the list of member hosts requires the GET operation on single anycast configuration resource. If the account has no anycast configurations defined, the result of this call will be an empty list.
		@responses.500._error {"code": "INTERNAL", "message": "Internal Server Error", "status": 500}

			@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			@return ApiOnPremAnycastManagerGetAnycastConfigListRequest
	*/
	OnPremAnycastManagerGetAnycastConfigList(ctx context.Context) ApiOnPremAnycastManagerGetAnycastConfigListRequest

	// OnPremAnycastManagerGetAnycastConfigListExecute executes the request
	//  @return ProtoGetAnycastConfigListResponse
	OnPremAnycastManagerGetAnycastConfigListExecute(r ApiOnPremAnycastManagerGetAnycastConfigListRequest) (*ProtoGetAnycastConfigListResponse, *http.Response, error)
	/*
			OnPremAnycastManagerGetAnycastVersion Retrieve Anycast Version

			Use this method to retrieve the anycast version for the given account id
		@responses.404._error {"code": "NOT_FOUND", "message": "", "status": 404}
		@responses.500._error {"code": "INTERNAL", "message": "Internal Server Error", "status": 500}

			@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			@param id
			@return ApiOnPremAnycastManagerGetAnycastVersionRequest
	*/
	OnPremAnycastManagerGetAnycastVersion(ctx context.Context, id int64) ApiOnPremAnycastManagerGetAnycastVersionRequest

	// OnPremAnycastManagerGetAnycastVersionExecute executes the request
	//  @return ProtoAnycastVersion
	OnPremAnycastManagerGetAnycastVersionExecute(r ApiOnPremAnycastManagerGetAnycastVersionRequest) (*ProtoAnycastVersion, *http.Response, error)
	/*
			OnPremAnycastManagerGetOnpremConfig Retrieve Generated, Per-Host Anycast Configuration

			Use this method to retrieve generated anycast configuration for anycast-enabled on-prem host. Retrieved configuration includes both interface and routing configuration. See common config manager documentation for the description of the returned payload. "ophid" is the system-assigned unique character-string identifier of the host. "version" can be either the timestamp of the configuration version that is sought after, or the word "latest". "latest" signifies the most recent generated configuration for this host.
		@responses.400._error {"code": "INVALID_ARGUMENT", "message": "", "status": 400}
		@responses.404._error {"code": "NOT_FOUND", "message": "", "status": 404}
		@responses.500._error {"code": "INTERNAL", "message": "Internal Server Error", "status": 500}

			@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			@param ophid
			@param version
			@return ApiOnPremAnycastManagerGetOnpremConfigRequest
	*/
	OnPremAnycastManagerGetOnpremConfig(ctx context.Context, ophid string, version string) ApiOnPremAnycastManagerGetOnpremConfigRequest

	// OnPremAnycastManagerGetOnpremConfigExecute executes the request
	//  @return ServiceConfig
	OnPremAnycastManagerGetOnpremConfigExecute(r ApiOnPremAnycastManagerGetOnpremConfigRequest) (*ServiceConfig, *http.Response, error)
	/*
			OnPremAnycastManagerGetOnpremConfig2 Retrieve Generated, Per-Host Anycast Configuration

			Use this method to retrieve generated anycast configuration for anycast-enabled on-prem host. Retrieved configuration includes both interface and routing configuration. See common config manager documentation for the description of the returned payload. "ophid" is the system-assigned unique character-string identifier of the host. "version" can be either the timestamp of the configuration version that is sought after, or the word "latest". "latest" signifies the most recent generated configuration for this host.
		@responses.400._error {"code": "INVALID_ARGUMENT", "message": "", "status": 400}
		@responses.404._error {"code": "NOT_FOUND", "message": "", "status": 404}
		@responses.500._error {"code": "INTERNAL", "message": "Internal Server Error", "status": 500}

			@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			@param ophid
			@param version
			@return ApiOnPremAnycastManagerGetOnpremConfig2Request
	*/
	OnPremAnycastManagerGetOnpremConfig2(ctx context.Context, ophid string, version string) ApiOnPremAnycastManagerGetOnpremConfig2Request

	// OnPremAnycastManagerGetOnpremConfig2Execute executes the request
	//  @return ServiceConfig
	OnPremAnycastManagerGetOnpremConfig2Execute(r ApiOnPremAnycastManagerGetOnpremConfig2Request) (*ServiceConfig, *http.Response, error)
	/*
			OnPremAnycastManagerGetOnpremHost Retrieve On-Prem Host

			Use this method to retrieve the specified on-prem host from the anycast database.
		@responses.400._error {"code": "INVALID_ARGUMENT", "message": "", "status": 400}
		@responses.404._error {"code": "NOT_FOUND", "message": "", "status": 404}
		@responses.500._error {"code": "INTERNAL", "message": "Internal Server Error", "status": 500}

			@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			@param id
			@return ApiOnPremAnycastManagerGetOnpremHostRequest
	*/
	OnPremAnycastManagerGetOnpremHost(ctx context.Context, id int64) ApiOnPremAnycastManagerGetOnpremHostRequest

	// OnPremAnycastManagerGetOnpremHostExecute executes the request
	//  @return ProtoOnpremHostResponse
	OnPremAnycastManagerGetOnpremHostExecute(r ApiOnPremAnycastManagerGetOnpremHostRequest) (*ProtoOnpremHostResponse, *http.Response, error)
	/*
			OnPremAnycastManagerGetStatus Retrieve Configuration Status

			Use this method to retrieve configuration status for the specified host. The configuration status is retrieved from the anycast service database.  "ophid" is the system-assigned unique character-string identifier of the host. "version" parameter can be either the timestamp of the configuration version that is sought after, or the word "latest". "latest' signifies the most recent generated configuration for this host.
		@responses.400._error {"code": "INVALID_ARGUMENT", "message": "", "status": 400}
		@responses.404._error {"code": "NOT_FOUND", "message": "", "status": 404}
		@responses.500._error {"code": "INTERNAL", "message": "Internal Server Error", "status": 500}

			@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			@param ophid
			@return ApiOnPremAnycastManagerGetStatusRequest
	*/
	OnPremAnycastManagerGetStatus(ctx context.Context, ophid string) ApiOnPremAnycastManagerGetStatusRequest

	// OnPremAnycastManagerGetStatusExecute executes the request
	//  @return ServiceStatusUpdateRequest
	OnPremAnycastManagerGetStatusExecute(r ApiOnPremAnycastManagerGetStatusRequest) (*ServiceStatusUpdateRequest, *http.Response, error)
	/*
			OnPremAnycastManagerGetStatus2 Retrieve Configuration Status

			Use this method to retrieve configuration status for the specified host. The configuration status is retrieved from the anycast service database.  "ophid" is the system-assigned unique character-string identifier of the host. "version" parameter can be either the timestamp of the configuration version that is sought after, or the word "latest". "latest' signifies the most recent generated configuration for this host.
		@responses.400._error {"code": "INVALID_ARGUMENT", "message": "", "status": 400}
		@responses.404._error {"code": "NOT_FOUND", "message": "", "status": 404}
		@responses.500._error {"code": "INTERNAL", "message": "Internal Server Error", "status": 500}

			@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			@param ophid
			@return ApiOnPremAnycastManagerGetStatus2Request
	*/
	OnPremAnycastManagerGetStatus2(ctx context.Context, ophid string) ApiOnPremAnycastManagerGetStatus2Request

	// OnPremAnycastManagerGetStatus2Execute executes the request
	//  @return ServiceStatusUpdateRequest
	OnPremAnycastManagerGetStatus2Execute(r ApiOnPremAnycastManagerGetStatus2Request) (*ServiceStatusUpdateRequest, *http.Response, error)
	/*
			OnPremAnycastManagerListAnycastConfigsWithRuntimeStatus Read list of Anycast Configurations

			Without any filtering, use this method to retrieve all named anycast configurations for the account of authorization. Anycast configuration comprises common anycast configuration data that is defined in support of one service on a set of on-prem hosts. The anycast configurations resulting from this call will not include the list(s) of member hosts. Retrieving the list of member hosts requires the GET operation on single anycast configuration resource. If the account has no anycast configurations defined, the result of this call will be an empty list.
		@responses.500._error {"code": "INTERNAL", "message": "Internal Server Error", "status": 500}

			@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			@return ApiOnPremAnycastManagerListAnycastConfigsWithRuntimeStatusRequest
	*/
	OnPremAnycastManagerListAnycastConfigsWithRuntimeStatus(ctx context.Context) ApiOnPremAnycastManagerListAnycastConfigsWithRuntimeStatusRequest

	// OnPremAnycastManagerListAnycastConfigsWithRuntimeStatusExecute executes the request
	//  @return ProtoGetAnycastConfigListResponse
	OnPremAnycastManagerListAnycastConfigsWithRuntimeStatusExecute(r ApiOnPremAnycastManagerListAnycastConfigsWithRuntimeStatusRequest) (*ProtoGetAnycastConfigListResponse, *http.Response, error)
	/*
			OnPremAnycastManagerReadAnycastConfigWithRuntimeStatus Read Anycast Configuration

			Use this method to retrieve the specified anycast configuration, together with the list of member hosts.
		@responses.400._error {"code": "INVALID_ARGUMENT", "message": "", "status": 400}
		@responses.404._error {"code": "NOT_FOUND", "message": "", "status": 404}
		@responses.500._error {"code": "INTERNAL", "message": "Internal Server Error", "status": 500}

			@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			@param id
			@return ApiOnPremAnycastManagerReadAnycastConfigWithRuntimeStatusRequest
	*/
	OnPremAnycastManagerReadAnycastConfigWithRuntimeStatus(ctx context.Context, id int64) ApiOnPremAnycastManagerReadAnycastConfigWithRuntimeStatusRequest

	// OnPremAnycastManagerReadAnycastConfigWithRuntimeStatusExecute executes the request
	//  @return ProtoAnycastConfigResponse
	OnPremAnycastManagerReadAnycastConfigWithRuntimeStatusExecute(r ApiOnPremAnycastManagerReadAnycastConfigWithRuntimeStatusRequest) (*ProtoAnycastConfigResponse, *http.Response, error)
	/*
			OnPremAnycastManagerUpdateAnycastConfig Create or Update Anycast Configuration

			Use this method to replace the addressed anycast configuration with configuration from the payload. If the addressed configuration does not exist, it will be created. Anycast configuration specified in the payload may contain the list of on-prem hosts that are supposed to be established as members of the specified configuration. If the anycast service has no information about one or more hosts from this list, such hosts will be created in the anycast service database. Note that the anycast service includes a background capability that verifies the validity of host data entered this way. This capability will delete any hosts created in this way that are determined to be invalid.
		@responses.400._error {"code": "INVALID_ARGUMENT", "message": "", "status": 400}
		@responses.500._error {"code": "INTERNAL", "message": "Internal Server Error", "status": 500}

			@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			@param id
			@return ApiOnPremAnycastManagerUpdateAnycastConfigRequest
	*/
	OnPremAnycastManagerUpdateAnycastConfig(ctx context.Context, id int64) ApiOnPremAnycastManagerUpdateAnycastConfigRequest

	// OnPremAnycastManagerUpdateAnycastConfigExecute executes the request
	//  @return ProtoAnycastConfigResponse
	OnPremAnycastManagerUpdateAnycastConfigExecute(r ApiOnPremAnycastManagerUpdateAnycastConfigRequest) (*ProtoAnycastConfigResponse, *http.Response, error)
	/*
			OnPremAnycastManagerUpdateOnpremHost Create or Update On-Prem Host

			Use this method to create or update the addressed host as per the specified payload. The payload is supposed to provide complete replacement for the host data. If the addressed host does not exist, it will be created.
		@responses.400._error {"code": "INVALID_ARGUMENT", "message": "", "status": 400}
		@responses.500._error {"code": "INTERNAL", "message": "Internal Server Error", "status": 500}

			@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			@param id Numeric host identifier
			@return ApiOnPremAnycastManagerUpdateOnpremHostRequest
	*/
	OnPremAnycastManagerUpdateOnpremHost(ctx context.Context, id int64) ApiOnPremAnycastManagerUpdateOnpremHostRequest

	// OnPremAnycastManagerUpdateOnpremHostExecute executes the request
	//  @return ProtoOnpremHostResponse
	OnPremAnycastManagerUpdateOnpremHostExecute(r ApiOnPremAnycastManagerUpdateOnpremHostRequest) (*ProtoOnpremHostResponse, *http.Response, error)
}

// OnPremAnycastManagerAPIService OnPremAnycastManagerAPI service
type OnPremAnycastManagerAPIService internal.Service

type ApiOnPremAnycastManagerCreateAnycastConfigRequest struct {
	ctx        context.Context
	ApiService OnPremAnycastManagerAPI
	body       *ProtoAnycastConfig
}

func (r ApiOnPremAnycastManagerCreateAnycastConfigRequest) Body(body ProtoAnycastConfig) ApiOnPremAnycastManagerCreateAnycastConfigRequest {
	r.body = &body
	return r
}

func (r ApiOnPremAnycastManagerCreateAnycastConfigRequest) Execute() (*ProtoAnycastConfigResponse, *http.Response, error) {
	return r.ApiService.OnPremAnycastManagerCreateAnycastConfigExecute(r)
}

/*
OnPremAnycastManagerCreateAnycastConfig Create Anycast Configuration

Use this method to create anycast configuration, as per the specified payload.
@responses.400._error {"code": "INVALID_ARGUMENT", "message": "", "status": 400}
@responses.500._error {"code": "INTERNAL", "message": "Internal Server Error", "status": 500}

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiOnPremAnycastManagerCreateAnycastConfigRequest
*/
func (a *OnPremAnycastManagerAPIService) OnPremAnycastManagerCreateAnycastConfig(ctx context.Context) ApiOnPremAnycastManagerCreateAnycastConfigRequest {
	return ApiOnPremAnycastManagerCreateAnycastConfigRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return ProtoAnycastConfigResponse
func (a *OnPremAnycastManagerAPIService) OnPremAnycastManagerCreateAnycastConfigExecute(r ApiOnPremAnycastManagerCreateAnycastConfigRequest) (*ProtoAnycastConfigResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []internal.FormFile
		localVarReturnValue *ProtoAnycastConfigResponse
	)

	localBasePath, err := a.Client.Cfg.ServerURLWithContext(r.ctx, "OnPremAnycastManagerAPIService.OnPremAnycastManagerCreateAnycastConfig")
	if err != nil {
		return localVarReturnValue, nil, internal.NewGenericOpenAPIError(err.Error())
	}

	localVarPath := localBasePath + "/accm/ac_configs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, internal.ReportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := internal.SelectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := internal.SelectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(internal.ContextAPIKeys).(map[string]internal.APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.Client.PrepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.Client.CallAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := internal.NewGenericOpenAPIErrorWithBody(localVarHTTPResponse.Status, localVarBody)
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.Client.Decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := internal.NewGenericOpenAPIErrorWithBody(err.Error(), localVarBody)
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOnPremAnycastManagerCreateAnycastVersionRequest struct {
	ctx        context.Context
	ApiService OnPremAnycastManagerAPI
	id         int64
}

func (r ApiOnPremAnycastManagerCreateAnycastVersionRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.OnPremAnycastManagerCreateAnycastVersionExecute(r)
}

/*
OnPremAnycastManagerCreateAnycastVersion Create Anycast Version

Use this method to create anycast 2.0 version for the account ID
@responses.500._error {"code": "INTERNAL", "message": "Internal Server Error", "status": 500}

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@return ApiOnPremAnycastManagerCreateAnycastVersionRequest
*/
func (a *OnPremAnycastManagerAPIService) OnPremAnycastManagerCreateAnycastVersion(ctx context.Context, id int64) ApiOnPremAnycastManagerCreateAnycastVersionRequest {
	return ApiOnPremAnycastManagerCreateAnycastVersionRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *OnPremAnycastManagerAPIService) OnPremAnycastManagerCreateAnycastVersionExecute(r ApiOnPremAnycastManagerCreateAnycastVersionRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []internal.FormFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.Client.Cfg.ServerURLWithContext(r.ctx, "OnPremAnycastManagerAPIService.OnPremAnycastManagerCreateAnycastVersion")
	if err != nil {
		return localVarReturnValue, nil, internal.NewGenericOpenAPIError(err.Error())
	}

	localVarPath := localBasePath + "/accm/ac_version/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(internal.ParameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := internal.SelectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := internal.SelectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(internal.ContextAPIKeys).(map[string]internal.APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.Client.PrepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.Client.CallAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := internal.NewGenericOpenAPIErrorWithBody(localVarHTTPResponse.Status, localVarBody)
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.Client.Decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := internal.NewGenericOpenAPIErrorWithBody(err.Error(), localVarBody)
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOnPremAnycastManagerDeleteAnycastConfigRequest struct {
	ctx        context.Context
	ApiService OnPremAnycastManagerAPI
	id         int64
}

func (r ApiOnPremAnycastManagerDeleteAnycastConfigRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.OnPremAnycastManagerDeleteAnycastConfigExecute(r)
}

/*
OnPremAnycastManagerDeleteAnycastConfig Delete Anycast Configuration

Use this method to delete the addressed anycast configuration.
@responses.400._error {"code": "INVALID_ARGUMENT", "message": "", "status": 400}
@responses.500._error {"code": "INTERNAL", "message": "Internal Server Error", "status": 500}

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@return ApiOnPremAnycastManagerDeleteAnycastConfigRequest
*/
func (a *OnPremAnycastManagerAPIService) OnPremAnycastManagerDeleteAnycastConfig(ctx context.Context, id int64) ApiOnPremAnycastManagerDeleteAnycastConfigRequest {
	return ApiOnPremAnycastManagerDeleteAnycastConfigRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *OnPremAnycastManagerAPIService) OnPremAnycastManagerDeleteAnycastConfigExecute(r ApiOnPremAnycastManagerDeleteAnycastConfigRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []internal.FormFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.Client.Cfg.ServerURLWithContext(r.ctx, "OnPremAnycastManagerAPIService.OnPremAnycastManagerDeleteAnycastConfig")
	if err != nil {
		return localVarReturnValue, nil, internal.NewGenericOpenAPIError(err.Error())
	}

	localVarPath := localBasePath + "/accm/ac_configs/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(internal.ParameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := internal.SelectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := internal.SelectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(internal.ContextAPIKeys).(map[string]internal.APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.Client.PrepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.Client.CallAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := internal.NewGenericOpenAPIErrorWithBody(localVarHTTPResponse.Status, localVarBody)
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.Client.Decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := internal.NewGenericOpenAPIErrorWithBody(err.Error(), localVarBody)
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOnPremAnycastManagerDeleteAnycastVersionRequest struct {
	ctx        context.Context
	ApiService OnPremAnycastManagerAPI
	id         int64
}

func (r ApiOnPremAnycastManagerDeleteAnycastVersionRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.OnPremAnycastManagerDeleteAnycastVersionExecute(r)
}

/*
OnPremAnycastManagerDeleteAnycastVersion Delete anycast version

Use this method to delete anycast 2.0 version associated with the given account id
@responses.404._error {"code": "NOT_FOUND", "message": "", "status": 404}
@responses.500._error {"code": "INTERNAL", "message": "Internal Server Error", "status": 500}

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@return ApiOnPremAnycastManagerDeleteAnycastVersionRequest
*/
func (a *OnPremAnycastManagerAPIService) OnPremAnycastManagerDeleteAnycastVersion(ctx context.Context, id int64) ApiOnPremAnycastManagerDeleteAnycastVersionRequest {
	return ApiOnPremAnycastManagerDeleteAnycastVersionRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *OnPremAnycastManagerAPIService) OnPremAnycastManagerDeleteAnycastVersionExecute(r ApiOnPremAnycastManagerDeleteAnycastVersionRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []internal.FormFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.Client.Cfg.ServerURLWithContext(r.ctx, "OnPremAnycastManagerAPIService.OnPremAnycastManagerDeleteAnycastVersion")
	if err != nil {
		return localVarReturnValue, nil, internal.NewGenericOpenAPIError(err.Error())
	}

	localVarPath := localBasePath + "/accm/ac_version/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(internal.ParameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := internal.SelectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := internal.SelectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(internal.ContextAPIKeys).(map[string]internal.APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.Client.PrepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.Client.CallAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := internal.NewGenericOpenAPIErrorWithBody(localVarHTTPResponse.Status, localVarBody)
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.Client.Decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := internal.NewGenericOpenAPIErrorWithBody(err.Error(), localVarBody)
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOnPremAnycastManagerDeleteOnpremHostRequest struct {
	ctx        context.Context
	ApiService OnPremAnycastManagerAPI
	id         int64
}

func (r ApiOnPremAnycastManagerDeleteOnpremHostRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.OnPremAnycastManagerDeleteOnpremHostExecute(r)
}

/*
OnPremAnycastManagerDeleteOnpremHost Delete On-Prem Host

Use this method to delete the addressed on-prem host.
@responses.400._error {"code": "INVALID_ARGUMENT", "message": "", "status": 400}
@responses.404._error {"code": "NOT_FOUND", "message": "", "status": 404}
@responses.500._error {"code": "INTERNAL", "message": "Internal Server Error", "status": 500}

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@return ApiOnPremAnycastManagerDeleteOnpremHostRequest
*/
func (a *OnPremAnycastManagerAPIService) OnPremAnycastManagerDeleteOnpremHost(ctx context.Context, id int64) ApiOnPremAnycastManagerDeleteOnpremHostRequest {
	return ApiOnPremAnycastManagerDeleteOnpremHostRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *OnPremAnycastManagerAPIService) OnPremAnycastManagerDeleteOnpremHostExecute(r ApiOnPremAnycastManagerDeleteOnpremHostRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []internal.FormFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.Client.Cfg.ServerURLWithContext(r.ctx, "OnPremAnycastManagerAPIService.OnPremAnycastManagerDeleteOnpremHost")
	if err != nil {
		return localVarReturnValue, nil, internal.NewGenericOpenAPIError(err.Error())
	}

	localVarPath := localBasePath + "/accm/op_hosts/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(internal.ParameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := internal.SelectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := internal.SelectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(internal.ContextAPIKeys).(map[string]internal.APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.Client.PrepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.Client.CallAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := internal.NewGenericOpenAPIErrorWithBody(localVarHTTPResponse.Status, localVarBody)
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.Client.Decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := internal.NewGenericOpenAPIErrorWithBody(err.Error(), localVarBody)
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOnPremAnycastManagerGetAnycastConfigRequest struct {
	ctx        context.Context
	ApiService OnPremAnycastManagerAPI
	id         int64
}

func (r ApiOnPremAnycastManagerGetAnycastConfigRequest) Execute() (*ProtoAnycastConfigResponse, *http.Response, error) {
	return r.ApiService.OnPremAnycastManagerGetAnycastConfigExecute(r)
}

/*
OnPremAnycastManagerGetAnycastConfig Retrieve Anycast Configuration

Use this method to retrieve the specified anycast configuration, together with the list of member hosts.
@responses.400._error {"code": "INVALID_ARGUMENT", "message": "", "status": 400}
@responses.404._error {"code": "NOT_FOUND", "message": "", "status": 404}
@responses.500._error {"code": "INTERNAL", "message": "Internal Server Error", "status": 500}

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@return ApiOnPremAnycastManagerGetAnycastConfigRequest
*/
func (a *OnPremAnycastManagerAPIService) OnPremAnycastManagerGetAnycastConfig(ctx context.Context, id int64) ApiOnPremAnycastManagerGetAnycastConfigRequest {
	return ApiOnPremAnycastManagerGetAnycastConfigRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return ProtoAnycastConfigResponse
func (a *OnPremAnycastManagerAPIService) OnPremAnycastManagerGetAnycastConfigExecute(r ApiOnPremAnycastManagerGetAnycastConfigRequest) (*ProtoAnycastConfigResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []internal.FormFile
		localVarReturnValue *ProtoAnycastConfigResponse
	)

	localBasePath, err := a.Client.Cfg.ServerURLWithContext(r.ctx, "OnPremAnycastManagerAPIService.OnPremAnycastManagerGetAnycastConfig")
	if err != nil {
		return localVarReturnValue, nil, internal.NewGenericOpenAPIError(err.Error())
	}

	localVarPath := localBasePath + "/accm/ac_configs/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(internal.ParameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := internal.SelectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := internal.SelectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(internal.ContextAPIKeys).(map[string]internal.APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.Client.PrepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.Client.CallAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := internal.NewGenericOpenAPIErrorWithBody(localVarHTTPResponse.Status, localVarBody)
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.Client.Decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := internal.NewGenericOpenAPIErrorWithBody(err.Error(), localVarBody)
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOnPremAnycastManagerGetAnycastConfigListRequest struct {
	ctx          context.Context
	ApiService   OnPremAnycastManagerAPI
	accountId    *int64
	service      *string
	hostId       *int64
	ophid        *string
	isConfigured *bool
	tfilter      *string
	torderBy     *string
}

func (r ApiOnPremAnycastManagerGetAnycastConfigListRequest) AccountId(accountId int64) ApiOnPremAnycastManagerGetAnycastConfigListRequest {
	r.accountId = &accountId
	return r
}

func (r ApiOnPremAnycastManagerGetAnycastConfigListRequest) Service(service string) ApiOnPremAnycastManagerGetAnycastConfigListRequest {
	r.service = &service
	return r
}

func (r ApiOnPremAnycastManagerGetAnycastConfigListRequest) HostId(hostId int64) ApiOnPremAnycastManagerGetAnycastConfigListRequest {
	r.hostId = &hostId
	return r
}

func (r ApiOnPremAnycastManagerGetAnycastConfigListRequest) Ophid(ophid string) ApiOnPremAnycastManagerGetAnycastConfigListRequest {
	r.ophid = &ophid
	return r
}

func (r ApiOnPremAnycastManagerGetAnycastConfigListRequest) IsConfigured(isConfigured bool) ApiOnPremAnycastManagerGetAnycastConfigListRequest {
	r.isConfigured = &isConfigured
	return r
}

func (r ApiOnPremAnycastManagerGetAnycastConfigListRequest) Tfilter(tfilter string) ApiOnPremAnycastManagerGetAnycastConfigListRequest {
	r.tfilter = &tfilter
	return r
}

func (r ApiOnPremAnycastManagerGetAnycastConfigListRequest) TorderBy(torderBy string) ApiOnPremAnycastManagerGetAnycastConfigListRequest {
	r.torderBy = &torderBy
	return r
}

func (r ApiOnPremAnycastManagerGetAnycastConfigListRequest) Execute() (*ProtoGetAnycastConfigListResponse, *http.Response, error) {
	return r.ApiService.OnPremAnycastManagerGetAnycastConfigListExecute(r)
}

/*
OnPremAnycastManagerGetAnycastConfigList Retrieve Multiple Anycast Configurations

Without any filtering, use this method to retrieve all named anycast configurations for the account of authorization. Anycast configuration comprises common anycast configuration data that is defined in support of one service on a set of on-prem hosts. The anycast configurations resulting from this call will not include the list(s) of member hosts. Retrieving the list of member hosts requires the GET operation on single anycast configuration resource. If the account has no anycast configurations defined, the result of this call will be an empty list.
@responses.500._error {"code": "INTERNAL", "message": "Internal Server Error", "status": 500}

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiOnPremAnycastManagerGetAnycastConfigListRequest
*/
func (a *OnPremAnycastManagerAPIService) OnPremAnycastManagerGetAnycastConfigList(ctx context.Context) ApiOnPremAnycastManagerGetAnycastConfigListRequest {
	return ApiOnPremAnycastManagerGetAnycastConfigListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return ProtoGetAnycastConfigListResponse
func (a *OnPremAnycastManagerAPIService) OnPremAnycastManagerGetAnycastConfigListExecute(r ApiOnPremAnycastManagerGetAnycastConfigListRequest) (*ProtoGetAnycastConfigListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []internal.FormFile
		localVarReturnValue *ProtoGetAnycastConfigListResponse
	)

	localBasePath, err := a.Client.Cfg.ServerURLWithContext(r.ctx, "OnPremAnycastManagerAPIService.OnPremAnycastManagerGetAnycastConfigList")
	if err != nil {
		return localVarReturnValue, nil, internal.NewGenericOpenAPIError(err.Error())
	}

	localVarPath := localBasePath + "/accm/ac_configs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.accountId != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "account_id", r.accountId, "")
	}
	if r.service != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "service", r.service, "")
	}
	if r.hostId != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "host_id", r.hostId, "")
	}
	if r.ophid != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "ophid", r.ophid, "")
	}
	if r.isConfigured != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "is_configured", r.isConfigured, "")
	}
	if r.tfilter != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "_tfilter", r.tfilter, "")
	}
	if r.torderBy != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "_torder_by", r.torderBy, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := internal.SelectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := internal.SelectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(internal.ContextAPIKeys).(map[string]internal.APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.Client.PrepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.Client.CallAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := internal.NewGenericOpenAPIErrorWithBody(localVarHTTPResponse.Status, localVarBody)
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.Client.Decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := internal.NewGenericOpenAPIErrorWithBody(err.Error(), localVarBody)
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOnPremAnycastManagerGetAnycastVersionRequest struct {
	ctx        context.Context
	ApiService OnPremAnycastManagerAPI
	id         int64
}

func (r ApiOnPremAnycastManagerGetAnycastVersionRequest) Execute() (*ProtoAnycastVersion, *http.Response, error) {
	return r.ApiService.OnPremAnycastManagerGetAnycastVersionExecute(r)
}

/*
OnPremAnycastManagerGetAnycastVersion Retrieve Anycast Version

Use this method to retrieve the anycast version for the given account id
@responses.404._error {"code": "NOT_FOUND", "message": "", "status": 404}
@responses.500._error {"code": "INTERNAL", "message": "Internal Server Error", "status": 500}

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@return ApiOnPremAnycastManagerGetAnycastVersionRequest
*/
func (a *OnPremAnycastManagerAPIService) OnPremAnycastManagerGetAnycastVersion(ctx context.Context, id int64) ApiOnPremAnycastManagerGetAnycastVersionRequest {
	return ApiOnPremAnycastManagerGetAnycastVersionRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return ProtoAnycastVersion
func (a *OnPremAnycastManagerAPIService) OnPremAnycastManagerGetAnycastVersionExecute(r ApiOnPremAnycastManagerGetAnycastVersionRequest) (*ProtoAnycastVersion, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []internal.FormFile
		localVarReturnValue *ProtoAnycastVersion
	)

	localBasePath, err := a.Client.Cfg.ServerURLWithContext(r.ctx, "OnPremAnycastManagerAPIService.OnPremAnycastManagerGetAnycastVersion")
	if err != nil {
		return localVarReturnValue, nil, internal.NewGenericOpenAPIError(err.Error())
	}

	localVarPath := localBasePath + "/accm/ac_version/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(internal.ParameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := internal.SelectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := internal.SelectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(internal.ContextAPIKeys).(map[string]internal.APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.Client.PrepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.Client.CallAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := internal.NewGenericOpenAPIErrorWithBody(localVarHTTPResponse.Status, localVarBody)
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.Client.Decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := internal.NewGenericOpenAPIErrorWithBody(err.Error(), localVarBody)
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOnPremAnycastManagerGetOnpremConfigRequest struct {
	ctx        context.Context
	ApiService OnPremAnycastManagerAPI
	ophid      string
	version    string
	appName    *string
	appVersion *string
}

func (r ApiOnPremAnycastManagerGetOnpremConfigRequest) AppName(appName string) ApiOnPremAnycastManagerGetOnpremConfigRequest {
	r.appName = &appName
	return r
}

func (r ApiOnPremAnycastManagerGetOnpremConfigRequest) AppVersion(appVersion string) ApiOnPremAnycastManagerGetOnpremConfigRequest {
	r.appVersion = &appVersion
	return r
}

func (r ApiOnPremAnycastManagerGetOnpremConfigRequest) Execute() (*ServiceConfig, *http.Response, error) {
	return r.ApiService.OnPremAnycastManagerGetOnpremConfigExecute(r)
}

/*
OnPremAnycastManagerGetOnpremConfig Retrieve Generated, Per-Host Anycast Configuration

Use this method to retrieve generated anycast configuration for anycast-enabled on-prem host. Retrieved configuration includes both interface and routing configuration. See common config manager documentation for the description of the returned payload. "ophid" is the system-assigned unique character-string identifier of the host. "version" can be either the timestamp of the configuration version that is sought after, or the word "latest". "latest" signifies the most recent generated configuration for this host.
@responses.400._error {"code": "INVALID_ARGUMENT", "message": "", "status": 400}
@responses.404._error {"code": "NOT_FOUND", "message": "", "status": 404}
@responses.500._error {"code": "INTERNAL", "message": "Internal Server Error", "status": 500}

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param ophid
	@param version
	@return ApiOnPremAnycastManagerGetOnpremConfigRequest
*/
func (a *OnPremAnycastManagerAPIService) OnPremAnycastManagerGetOnpremConfig(ctx context.Context, ophid string, version string) ApiOnPremAnycastManagerGetOnpremConfigRequest {
	return ApiOnPremAnycastManagerGetOnpremConfigRequest{
		ApiService: a,
		ctx:        ctx,
		ophid:      ophid,
		version:    version,
	}
}

// Execute executes the request
//
//	@return ServiceConfig
func (a *OnPremAnycastManagerAPIService) OnPremAnycastManagerGetOnpremConfigExecute(r ApiOnPremAnycastManagerGetOnpremConfigRequest) (*ServiceConfig, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []internal.FormFile
		localVarReturnValue *ServiceConfig
	)

	localBasePath, err := a.Client.Cfg.ServerURLWithContext(r.ctx, "OnPremAnycastManagerAPIService.OnPremAnycastManagerGetOnpremConfig")
	if err != nil {
		return localVarReturnValue, nil, internal.NewGenericOpenAPIError(err.Error())
	}

	localVarPath := localBasePath + "/accm/oph_configs/{ophid}/{version}"
	localVarPath = strings.Replace(localVarPath, "{"+"ophid"+"}", url.PathEscape(internal.ParameterValueToString(r.ophid, "ophid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(internal.ParameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.appName != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "appName", r.appName, "")
	}
	if r.appVersion != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "appVersion", r.appVersion, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := internal.SelectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := internal.SelectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(internal.ContextAPIKeys).(map[string]internal.APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.Client.PrepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.Client.CallAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := internal.NewGenericOpenAPIErrorWithBody(localVarHTTPResponse.Status, localVarBody)
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.Client.Decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := internal.NewGenericOpenAPIErrorWithBody(err.Error(), localVarBody)
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOnPremAnycastManagerGetOnpremConfig2Request struct {
	ctx        context.Context
	ApiService OnPremAnycastManagerAPI
	ophid      string
	version    string
	appName    *string
	appVersion *string
}

func (r ApiOnPremAnycastManagerGetOnpremConfig2Request) AppName(appName string) ApiOnPremAnycastManagerGetOnpremConfig2Request {
	r.appName = &appName
	return r
}

func (r ApiOnPremAnycastManagerGetOnpremConfig2Request) AppVersion(appVersion string) ApiOnPremAnycastManagerGetOnpremConfig2Request {
	r.appVersion = &appVersion
	return r
}

func (r ApiOnPremAnycastManagerGetOnpremConfig2Request) Execute() (*ServiceConfig, *http.Response, error) {
	return r.ApiService.OnPremAnycastManagerGetOnpremConfig2Execute(r)
}

/*
OnPremAnycastManagerGetOnpremConfig2 Retrieve Generated, Per-Host Anycast Configuration

Use this method to retrieve generated anycast configuration for anycast-enabled on-prem host. Retrieved configuration includes both interface and routing configuration. See common config manager documentation for the description of the returned payload. "ophid" is the system-assigned unique character-string identifier of the host. "version" can be either the timestamp of the configuration version that is sought after, or the word "latest". "latest" signifies the most recent generated configuration for this host.
@responses.400._error {"code": "INVALID_ARGUMENT", "message": "", "status": 400}
@responses.404._error {"code": "NOT_FOUND", "message": "", "status": 404}
@responses.500._error {"code": "INTERNAL", "message": "Internal Server Error", "status": 500}

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param ophid
	@param version
	@return ApiOnPremAnycastManagerGetOnpremConfig2Request
*/
func (a *OnPremAnycastManagerAPIService) OnPremAnycastManagerGetOnpremConfig2(ctx context.Context, ophid string, version string) ApiOnPremAnycastManagerGetOnpremConfig2Request {
	return ApiOnPremAnycastManagerGetOnpremConfig2Request{
		ApiService: a,
		ctx:        ctx,
		ophid:      ophid,
		version:    version,
	}
}

// Execute executes the request
//
//	@return ServiceConfig
func (a *OnPremAnycastManagerAPIService) OnPremAnycastManagerGetOnpremConfig2Execute(r ApiOnPremAnycastManagerGetOnpremConfig2Request) (*ServiceConfig, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []internal.FormFile
		localVarReturnValue *ServiceConfig
	)

	localBasePath, err := a.Client.Cfg.ServerURLWithContext(r.ctx, "OnPremAnycastManagerAPIService.OnPremAnycastManagerGetOnpremConfig2")
	if err != nil {
		return localVarReturnValue, nil, internal.NewGenericOpenAPIError(err.Error())
	}

	localVarPath := localBasePath + "/onprem_config/{ophid}/{version}"
	localVarPath = strings.Replace(localVarPath, "{"+"ophid"+"}", url.PathEscape(internal.ParameterValueToString(r.ophid, "ophid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(internal.ParameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.appName != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "appName", r.appName, "")
	}
	if r.appVersion != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "appVersion", r.appVersion, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := internal.SelectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := internal.SelectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(internal.ContextAPIKeys).(map[string]internal.APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.Client.PrepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.Client.CallAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := internal.NewGenericOpenAPIErrorWithBody(localVarHTTPResponse.Status, localVarBody)
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.Client.Decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := internal.NewGenericOpenAPIErrorWithBody(err.Error(), localVarBody)
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOnPremAnycastManagerGetOnpremHostRequest struct {
	ctx        context.Context
	ApiService OnPremAnycastManagerAPI
	id         int64
}

func (r ApiOnPremAnycastManagerGetOnpremHostRequest) Execute() (*ProtoOnpremHostResponse, *http.Response, error) {
	return r.ApiService.OnPremAnycastManagerGetOnpremHostExecute(r)
}

/*
OnPremAnycastManagerGetOnpremHost Retrieve On-Prem Host

Use this method to retrieve the specified on-prem host from the anycast database.
@responses.400._error {"code": "INVALID_ARGUMENT", "message": "", "status": 400}
@responses.404._error {"code": "NOT_FOUND", "message": "", "status": 404}
@responses.500._error {"code": "INTERNAL", "message": "Internal Server Error", "status": 500}

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@return ApiOnPremAnycastManagerGetOnpremHostRequest
*/
func (a *OnPremAnycastManagerAPIService) OnPremAnycastManagerGetOnpremHost(ctx context.Context, id int64) ApiOnPremAnycastManagerGetOnpremHostRequest {
	return ApiOnPremAnycastManagerGetOnpremHostRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return ProtoOnpremHostResponse
func (a *OnPremAnycastManagerAPIService) OnPremAnycastManagerGetOnpremHostExecute(r ApiOnPremAnycastManagerGetOnpremHostRequest) (*ProtoOnpremHostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []internal.FormFile
		localVarReturnValue *ProtoOnpremHostResponse
	)

	localBasePath, err := a.Client.Cfg.ServerURLWithContext(r.ctx, "OnPremAnycastManagerAPIService.OnPremAnycastManagerGetOnpremHost")
	if err != nil {
		return localVarReturnValue, nil, internal.NewGenericOpenAPIError(err.Error())
	}

	localVarPath := localBasePath + "/accm/op_hosts/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(internal.ParameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := internal.SelectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := internal.SelectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(internal.ContextAPIKeys).(map[string]internal.APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.Client.PrepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.Client.CallAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := internal.NewGenericOpenAPIErrorWithBody(localVarHTTPResponse.Status, localVarBody)
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.Client.Decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := internal.NewGenericOpenAPIErrorWithBody(err.Error(), localVarBody)
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOnPremAnycastManagerGetStatusRequest struct {
	ctx        context.Context
	ApiService OnPremAnycastManagerAPI
	ophid      string
}

func (r ApiOnPremAnycastManagerGetStatusRequest) Execute() (*ServiceStatusUpdateRequest, *http.Response, error) {
	return r.ApiService.OnPremAnycastManagerGetStatusExecute(r)
}

/*
OnPremAnycastManagerGetStatus Retrieve Configuration Status

Use this method to retrieve configuration status for the specified host. The configuration status is retrieved from the anycast service database.  "ophid" is the system-assigned unique character-string identifier of the host. "version" parameter can be either the timestamp of the configuration version that is sought after, or the word "latest". "latest' signifies the most recent generated configuration for this host.
@responses.400._error {"code": "INVALID_ARGUMENT", "message": "", "status": 400}
@responses.404._error {"code": "NOT_FOUND", "message": "", "status": 404}
@responses.500._error {"code": "INTERNAL", "message": "Internal Server Error", "status": 500}

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param ophid
	@return ApiOnPremAnycastManagerGetStatusRequest
*/
func (a *OnPremAnycastManagerAPIService) OnPremAnycastManagerGetStatus(ctx context.Context, ophid string) ApiOnPremAnycastManagerGetStatusRequest {
	return ApiOnPremAnycastManagerGetStatusRequest{
		ApiService: a,
		ctx:        ctx,
		ophid:      ophid,
	}
}

// Execute executes the request
//
//	@return ServiceStatusUpdateRequest
func (a *OnPremAnycastManagerAPIService) OnPremAnycastManagerGetStatusExecute(r ApiOnPremAnycastManagerGetStatusRequest) (*ServiceStatusUpdateRequest, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []internal.FormFile
		localVarReturnValue *ServiceStatusUpdateRequest
	)

	localBasePath, err := a.Client.Cfg.ServerURLWithContext(r.ctx, "OnPremAnycastManagerAPIService.OnPremAnycastManagerGetStatus")
	if err != nil {
		return localVarReturnValue, nil, internal.NewGenericOpenAPIError(err.Error())
	}

	localVarPath := localBasePath + "/accm/oph_config_statuses/{ophid}/latest"
	localVarPath = strings.Replace(localVarPath, "{"+"ophid"+"}", url.PathEscape(internal.ParameterValueToString(r.ophid, "ophid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := internal.SelectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := internal.SelectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(internal.ContextAPIKeys).(map[string]internal.APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.Client.PrepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.Client.CallAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := internal.NewGenericOpenAPIErrorWithBody(localVarHTTPResponse.Status, localVarBody)
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.Client.Decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := internal.NewGenericOpenAPIErrorWithBody(err.Error(), localVarBody)
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOnPremAnycastManagerGetStatus2Request struct {
	ctx        context.Context
	ApiService OnPremAnycastManagerAPI
	ophid      string
}

func (r ApiOnPremAnycastManagerGetStatus2Request) Execute() (*ServiceStatusUpdateRequest, *http.Response, error) {
	return r.ApiService.OnPremAnycastManagerGetStatus2Execute(r)
}

/*
OnPremAnycastManagerGetStatus2 Retrieve Configuration Status

Use this method to retrieve configuration status for the specified host. The configuration status is retrieved from the anycast service database.  "ophid" is the system-assigned unique character-string identifier of the host. "version" parameter can be either the timestamp of the configuration version that is sought after, or the word "latest". "latest' signifies the most recent generated configuration for this host.
@responses.400._error {"code": "INVALID_ARGUMENT", "message": "", "status": 400}
@responses.404._error {"code": "NOT_FOUND", "message": "", "status": 404}
@responses.500._error {"code": "INTERNAL", "message": "Internal Server Error", "status": 500}

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param ophid
	@return ApiOnPremAnycastManagerGetStatus2Request
*/
func (a *OnPremAnycastManagerAPIService) OnPremAnycastManagerGetStatus2(ctx context.Context, ophid string) ApiOnPremAnycastManagerGetStatus2Request {
	return ApiOnPremAnycastManagerGetStatus2Request{
		ApiService: a,
		ctx:        ctx,
		ophid:      ophid,
	}
}

// Execute executes the request
//
//	@return ServiceStatusUpdateRequest
func (a *OnPremAnycastManagerAPIService) OnPremAnycastManagerGetStatus2Execute(r ApiOnPremAnycastManagerGetStatus2Request) (*ServiceStatusUpdateRequest, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []internal.FormFile
		localVarReturnValue *ServiceStatusUpdateRequest
	)

	localBasePath, err := a.Client.Cfg.ServerURLWithContext(r.ctx, "OnPremAnycastManagerAPIService.OnPremAnycastManagerGetStatus2")
	if err != nil {
		return localVarReturnValue, nil, internal.NewGenericOpenAPIError(err.Error())
	}

	localVarPath := localBasePath + "/onprem_config_statuses/{ophid}/latest"
	localVarPath = strings.Replace(localVarPath, "{"+"ophid"+"}", url.PathEscape(internal.ParameterValueToString(r.ophid, "ophid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := internal.SelectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := internal.SelectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(internal.ContextAPIKeys).(map[string]internal.APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.Client.PrepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.Client.CallAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := internal.NewGenericOpenAPIErrorWithBody(localVarHTTPResponse.Status, localVarBody)
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.Client.Decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := internal.NewGenericOpenAPIErrorWithBody(err.Error(), localVarBody)
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOnPremAnycastManagerListAnycastConfigsWithRuntimeStatusRequest struct {
	ctx          context.Context
	ApiService   OnPremAnycastManagerAPI
	accountId    *int64
	service      *string
	hostId       *int64
	ophid        *string
	isConfigured *bool
	tfilter      *string
	torderBy     *string
}

func (r ApiOnPremAnycastManagerListAnycastConfigsWithRuntimeStatusRequest) AccountId(accountId int64) ApiOnPremAnycastManagerListAnycastConfigsWithRuntimeStatusRequest {
	r.accountId = &accountId
	return r
}

func (r ApiOnPremAnycastManagerListAnycastConfigsWithRuntimeStatusRequest) Service(service string) ApiOnPremAnycastManagerListAnycastConfigsWithRuntimeStatusRequest {
	r.service = &service
	return r
}

func (r ApiOnPremAnycastManagerListAnycastConfigsWithRuntimeStatusRequest) HostId(hostId int64) ApiOnPremAnycastManagerListAnycastConfigsWithRuntimeStatusRequest {
	r.hostId = &hostId
	return r
}

func (r ApiOnPremAnycastManagerListAnycastConfigsWithRuntimeStatusRequest) Ophid(ophid string) ApiOnPremAnycastManagerListAnycastConfigsWithRuntimeStatusRequest {
	r.ophid = &ophid
	return r
}

func (r ApiOnPremAnycastManagerListAnycastConfigsWithRuntimeStatusRequest) IsConfigured(isConfigured bool) ApiOnPremAnycastManagerListAnycastConfigsWithRuntimeStatusRequest {
	r.isConfigured = &isConfigured
	return r
}

func (r ApiOnPremAnycastManagerListAnycastConfigsWithRuntimeStatusRequest) Tfilter(tfilter string) ApiOnPremAnycastManagerListAnycastConfigsWithRuntimeStatusRequest {
	r.tfilter = &tfilter
	return r
}

func (r ApiOnPremAnycastManagerListAnycastConfigsWithRuntimeStatusRequest) TorderBy(torderBy string) ApiOnPremAnycastManagerListAnycastConfigsWithRuntimeStatusRequest {
	r.torderBy = &torderBy
	return r
}

func (r ApiOnPremAnycastManagerListAnycastConfigsWithRuntimeStatusRequest) Execute() (*ProtoGetAnycastConfigListResponse, *http.Response, error) {
	return r.ApiService.OnPremAnycastManagerListAnycastConfigsWithRuntimeStatusExecute(r)
}

/*
OnPremAnycastManagerListAnycastConfigsWithRuntimeStatus Read list of Anycast Configurations

Without any filtering, use this method to retrieve all named anycast configurations for the account of authorization. Anycast configuration comprises common anycast configuration data that is defined in support of one service on a set of on-prem hosts. The anycast configurations resulting from this call will not include the list(s) of member hosts. Retrieving the list of member hosts requires the GET operation on single anycast configuration resource. If the account has no anycast configurations defined, the result of this call will be an empty list.
@responses.500._error {"code": "INTERNAL", "message": "Internal Server Error", "status": 500}

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiOnPremAnycastManagerListAnycastConfigsWithRuntimeStatusRequest
*/
func (a *OnPremAnycastManagerAPIService) OnPremAnycastManagerListAnycastConfigsWithRuntimeStatus(ctx context.Context) ApiOnPremAnycastManagerListAnycastConfigsWithRuntimeStatusRequest {
	return ApiOnPremAnycastManagerListAnycastConfigsWithRuntimeStatusRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return ProtoGetAnycastConfigListResponse
func (a *OnPremAnycastManagerAPIService) OnPremAnycastManagerListAnycastConfigsWithRuntimeStatusExecute(r ApiOnPremAnycastManagerListAnycastConfigsWithRuntimeStatusRequest) (*ProtoGetAnycastConfigListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []internal.FormFile
		localVarReturnValue *ProtoGetAnycastConfigListResponse
	)

	localBasePath, err := a.Client.Cfg.ServerURLWithContext(r.ctx, "OnPremAnycastManagerAPIService.OnPremAnycastManagerListAnycastConfigsWithRuntimeStatus")
	if err != nil {
		return localVarReturnValue, nil, internal.NewGenericOpenAPIError(err.Error())
	}

	localVarPath := localBasePath + "/accm/ac_runtime_statuses"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.accountId != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "account_id", r.accountId, "")
	}
	if r.service != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "service", r.service, "")
	}
	if r.hostId != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "host_id", r.hostId, "")
	}
	if r.ophid != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "ophid", r.ophid, "")
	}
	if r.isConfigured != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "is_configured", r.isConfigured, "")
	}
	if r.tfilter != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "_tfilter", r.tfilter, "")
	}
	if r.torderBy != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "_torder_by", r.torderBy, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := internal.SelectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := internal.SelectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(internal.ContextAPIKeys).(map[string]internal.APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.Client.PrepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.Client.CallAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := internal.NewGenericOpenAPIErrorWithBody(localVarHTTPResponse.Status, localVarBody)
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.Client.Decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := internal.NewGenericOpenAPIErrorWithBody(err.Error(), localVarBody)
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOnPremAnycastManagerReadAnycastConfigWithRuntimeStatusRequest struct {
	ctx        context.Context
	ApiService OnPremAnycastManagerAPI
	id         int64
}

func (r ApiOnPremAnycastManagerReadAnycastConfigWithRuntimeStatusRequest) Execute() (*ProtoAnycastConfigResponse, *http.Response, error) {
	return r.ApiService.OnPremAnycastManagerReadAnycastConfigWithRuntimeStatusExecute(r)
}

/*
OnPremAnycastManagerReadAnycastConfigWithRuntimeStatus Read Anycast Configuration

Use this method to retrieve the specified anycast configuration, together with the list of member hosts.
@responses.400._error {"code": "INVALID_ARGUMENT", "message": "", "status": 400}
@responses.404._error {"code": "NOT_FOUND", "message": "", "status": 404}
@responses.500._error {"code": "INTERNAL", "message": "Internal Server Error", "status": 500}

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@return ApiOnPremAnycastManagerReadAnycastConfigWithRuntimeStatusRequest
*/
func (a *OnPremAnycastManagerAPIService) OnPremAnycastManagerReadAnycastConfigWithRuntimeStatus(ctx context.Context, id int64) ApiOnPremAnycastManagerReadAnycastConfigWithRuntimeStatusRequest {
	return ApiOnPremAnycastManagerReadAnycastConfigWithRuntimeStatusRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return ProtoAnycastConfigResponse
func (a *OnPremAnycastManagerAPIService) OnPremAnycastManagerReadAnycastConfigWithRuntimeStatusExecute(r ApiOnPremAnycastManagerReadAnycastConfigWithRuntimeStatusRequest) (*ProtoAnycastConfigResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []internal.FormFile
		localVarReturnValue *ProtoAnycastConfigResponse
	)

	localBasePath, err := a.Client.Cfg.ServerURLWithContext(r.ctx, "OnPremAnycastManagerAPIService.OnPremAnycastManagerReadAnycastConfigWithRuntimeStatus")
	if err != nil {
		return localVarReturnValue, nil, internal.NewGenericOpenAPIError(err.Error())
	}

	localVarPath := localBasePath + "/accm/ac_runtime_statuses/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(internal.ParameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := internal.SelectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := internal.SelectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(internal.ContextAPIKeys).(map[string]internal.APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.Client.PrepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.Client.CallAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := internal.NewGenericOpenAPIErrorWithBody(localVarHTTPResponse.Status, localVarBody)
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.Client.Decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := internal.NewGenericOpenAPIErrorWithBody(err.Error(), localVarBody)
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOnPremAnycastManagerUpdateAnycastConfigRequest struct {
	ctx        context.Context
	ApiService OnPremAnycastManagerAPI
	id         int64
	body       *ProtoAnycastConfig
}

func (r ApiOnPremAnycastManagerUpdateAnycastConfigRequest) Body(body ProtoAnycastConfig) ApiOnPremAnycastManagerUpdateAnycastConfigRequest {
	r.body = &body
	return r
}

func (r ApiOnPremAnycastManagerUpdateAnycastConfigRequest) Execute() (*ProtoAnycastConfigResponse, *http.Response, error) {
	return r.ApiService.OnPremAnycastManagerUpdateAnycastConfigExecute(r)
}

/*
OnPremAnycastManagerUpdateAnycastConfig Create or Update Anycast Configuration

Use this method to replace the addressed anycast configuration with configuration from the payload. If the addressed configuration does not exist, it will be created. Anycast configuration specified in the payload may contain the list of on-prem hosts that are supposed to be established as members of the specified configuration. If the anycast service has no information about one or more hosts from this list, such hosts will be created in the anycast service database. Note that the anycast service includes a background capability that verifies the validity of host data entered this way. This capability will delete any hosts created in this way that are determined to be invalid.
@responses.400._error {"code": "INVALID_ARGUMENT", "message": "", "status": 400}
@responses.500._error {"code": "INTERNAL", "message": "Internal Server Error", "status": 500}

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@return ApiOnPremAnycastManagerUpdateAnycastConfigRequest
*/
func (a *OnPremAnycastManagerAPIService) OnPremAnycastManagerUpdateAnycastConfig(ctx context.Context, id int64) ApiOnPremAnycastManagerUpdateAnycastConfigRequest {
	return ApiOnPremAnycastManagerUpdateAnycastConfigRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return ProtoAnycastConfigResponse
func (a *OnPremAnycastManagerAPIService) OnPremAnycastManagerUpdateAnycastConfigExecute(r ApiOnPremAnycastManagerUpdateAnycastConfigRequest) (*ProtoAnycastConfigResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []internal.FormFile
		localVarReturnValue *ProtoAnycastConfigResponse
	)

	localBasePath, err := a.Client.Cfg.ServerURLWithContext(r.ctx, "OnPremAnycastManagerAPIService.OnPremAnycastManagerUpdateAnycastConfig")
	if err != nil {
		return localVarReturnValue, nil, internal.NewGenericOpenAPIError(err.Error())
	}

	localVarPath := localBasePath + "/accm/ac_configs/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(internal.ParameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, internal.ReportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := internal.SelectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := internal.SelectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(internal.ContextAPIKeys).(map[string]internal.APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.Client.PrepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.Client.CallAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := internal.NewGenericOpenAPIErrorWithBody(localVarHTTPResponse.Status, localVarBody)
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.Client.Decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := internal.NewGenericOpenAPIErrorWithBody(err.Error(), localVarBody)
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOnPremAnycastManagerUpdateOnpremHostRequest struct {
	ctx        context.Context
	ApiService OnPremAnycastManagerAPI
	id         int64
	body       *ProtoOnpremHost
}

func (r ApiOnPremAnycastManagerUpdateOnpremHostRequest) Body(body ProtoOnpremHost) ApiOnPremAnycastManagerUpdateOnpremHostRequest {
	r.body = &body
	return r
}

func (r ApiOnPremAnycastManagerUpdateOnpremHostRequest) Execute() (*ProtoOnpremHostResponse, *http.Response, error) {
	return r.ApiService.OnPremAnycastManagerUpdateOnpremHostExecute(r)
}

/*
OnPremAnycastManagerUpdateOnpremHost Create or Update On-Prem Host

Use this method to create or update the addressed host as per the specified payload. The payload is supposed to provide complete replacement for the host data. If the addressed host does not exist, it will be created.
@responses.400._error {"code": "INVALID_ARGUMENT", "message": "", "status": 400}
@responses.500._error {"code": "INTERNAL", "message": "Internal Server Error", "status": 500}

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Numeric host identifier
	@return ApiOnPremAnycastManagerUpdateOnpremHostRequest
*/
func (a *OnPremAnycastManagerAPIService) OnPremAnycastManagerUpdateOnpremHost(ctx context.Context, id int64) ApiOnPremAnycastManagerUpdateOnpremHostRequest {
	return ApiOnPremAnycastManagerUpdateOnpremHostRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return ProtoOnpremHostResponse
func (a *OnPremAnycastManagerAPIService) OnPremAnycastManagerUpdateOnpremHostExecute(r ApiOnPremAnycastManagerUpdateOnpremHostRequest) (*ProtoOnpremHostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []internal.FormFile
		localVarReturnValue *ProtoOnpremHostResponse
	)

	localBasePath, err := a.Client.Cfg.ServerURLWithContext(r.ctx, "OnPremAnycastManagerAPIService.OnPremAnycastManagerUpdateOnpremHost")
	if err != nil {
		return localVarReturnValue, nil, internal.NewGenericOpenAPIError(err.Error())
	}

	localVarPath := localBasePath + "/accm/op_hosts/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(internal.ParameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, internal.ReportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := internal.SelectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := internal.SelectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(internal.ContextAPIKeys).(map[string]internal.APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.Client.PrepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.Client.CallAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := internal.NewGenericOpenAPIErrorWithBody(localVarHTTPResponse.Status, localVarBody)
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.Client.Decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := internal.NewGenericOpenAPIErrorWithBody(err.Error(), localVarBody)
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	return localVarReturnValue, localVarHTTPResponse, nil
}
