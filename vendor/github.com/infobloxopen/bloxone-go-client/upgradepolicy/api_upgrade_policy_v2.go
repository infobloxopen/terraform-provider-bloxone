/*
Schedule Software/Config Updates

Infoblox by default does automatic software updates when they become available. Updates are applied to all on-prem hosts, physical or virtual. However, you can override and schedule the software updates. You can also defer the updates to a later date and time. You can configure up to a total of 50 deferrals (scheduled and deferred software updates), which means you have the flexibility to create up to 50 update groups across different on-prem hosts by mapping with appropriate tags. Tags are be used to associate deferrals (scheduled or deferred) with a specific or group of onprem-hosts. Apart from software update deferrals, config update deferrals also can be configured using these overrides.

API version: v2
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package upgradepolicy

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/infobloxopen/bloxone-go-client/internal"
)

type UpgradePolicyV2API interface {
	/*
		ApplyConfigNow Immediately apply the config updates object to the list of hosts

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return UpgradePolicyV2APIApplyConfigNowRequest
	*/
	ApplyConfigNow(ctx context.Context) UpgradePolicyV2APIApplyConfigNowRequest

	// ApplyConfigNowExecute executes the request
	//  @return ApplyConfigNowResponse
	ApplyConfigNowExecute(r UpgradePolicyV2APIApplyConfigNowRequest) (*ApplyConfigNowResponse, *http.Response, error)
	/*
		Batch Create, update and/or delete multiple maintenance windows in a single request

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return UpgradePolicyV2APIBatchRequest
	*/
	Batch(ctx context.Context) UpgradePolicyV2APIBatchRequest

	// BatchExecute executes the request
	//  @return BatchMaintenanceWindowResponse
	BatchExecute(r UpgradePolicyV2APIBatchRequest) (*BatchMaintenanceWindowResponse, *http.Response, error)
	/*
		Create Create a maintenance window

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return UpgradePolicyV2APICreateRequest
	*/
	Create(ctx context.Context) UpgradePolicyV2APICreateRequest

	// CreateExecute executes the request
	//  @return CreateMaintenanceWindowResponse
	CreateExecute(r UpgradePolicyV2APICreateRequest) (*CreateMaintenanceWindowResponse, *http.Response, error)
	/*
		Delete Delete maintenance window

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param id uuid of a maintenance window record
		@return UpgradePolicyV2APIDeleteRequest
	*/
	Delete(ctx context.Context, id string) UpgradePolicyV2APIDeleteRequest

	// DeleteExecute executes the request
	//  @return DeleteMaintenanceWindowResponse
	DeleteExecute(r UpgradePolicyV2APIDeleteRequest) (*DeleteMaintenanceWindowResponse, *http.Response, error)
	/*
		Get Read a maintenance window

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param id uuid of a maintenance window record
		@return UpgradePolicyV2APIGetRequest
	*/
	Get(ctx context.Context, id string) UpgradePolicyV2APIGetRequest

	// GetExecute executes the request
	//  @return GetMaintenanceWindowResponse
	GetExecute(r UpgradePolicyV2APIGetRequest) (*GetMaintenanceWindowResponse, *http.Response, error)
	/*
		List List all the maintenance windows

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return UpgradePolicyV2APIListRequest
	*/
	List(ctx context.Context) UpgradePolicyV2APIListRequest

	// ListExecute executes the request
	//  @return ListMaintenanceWindowResponse
	ListExecute(r UpgradePolicyV2APIListRequest) (*ListMaintenanceWindowResponse, *http.Response, error)
	/*
		Update Update an existing maintenance window

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param id uuid of a maintenance window record
		@return UpgradePolicyV2APIUpdateRequest
	*/
	Update(ctx context.Context, id string) UpgradePolicyV2APIUpdateRequest

	// UpdateExecute executes the request
	//  @return UpdateMaintenanceWindowResponse
	UpdateExecute(r UpgradePolicyV2APIUpdateRequest) (*UpdateMaintenanceWindowResponse, *http.Response, error)
}

// UpgradePolicyV2APIService UpgradePolicyV2API service
type UpgradePolicyV2APIService internal.Service

type UpgradePolicyV2APIApplyConfigNowRequest struct {
	ctx        context.Context
	ApiService UpgradePolicyV2API
	body       *ApplyConfigNowRequest
}

func (r UpgradePolicyV2APIApplyConfigNowRequest) Body(body ApplyConfigNowRequest) UpgradePolicyV2APIApplyConfigNowRequest {
	r.body = &body
	return r
}

func (r UpgradePolicyV2APIApplyConfigNowRequest) Execute() (*ApplyConfigNowResponse, *http.Response, error) {
	return r.ApiService.ApplyConfigNowExecute(r)
}

/*
ApplyConfigNow Immediately apply the config updates object to the list of hosts

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return UpgradePolicyV2APIApplyConfigNowRequest
*/
func (a *UpgradePolicyV2APIService) ApplyConfigNow(ctx context.Context) UpgradePolicyV2APIApplyConfigNowRequest {
	return UpgradePolicyV2APIApplyConfigNowRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return ApplyConfigNowResponse
func (a *UpgradePolicyV2APIService) ApplyConfigNowExecute(r UpgradePolicyV2APIApplyConfigNowRequest) (*ApplyConfigNowResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []internal.FormFile
		localVarReturnValue *ApplyConfigNowResponse
	)

	localBasePath, err := a.Client.Cfg.ServerURLWithContext(r.ctx, "UpgradePolicyV2APIService.ApplyConfigNow")
	if err != nil {
		return localVarReturnValue, nil, internal.NewGenericOpenAPIError(err.Error())
	}

	localVarPath := localBasePath + "/v2/config/apply_now"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, internal.ReportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := internal.SelectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := internal.SelectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.Client.PrepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.Client.CallAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := internal.NewGenericOpenAPIErrorWithBody(localVarHTTPResponse.Status, localVarBody)
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.Client.Decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := internal.NewGenericOpenAPIErrorWithBody(err.Error(), localVarBody)
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	return localVarReturnValue, localVarHTTPResponse, nil
}

type UpgradePolicyV2APIBatchRequest struct {
	ctx        context.Context
	ApiService UpgradePolicyV2API
	body       *BatchMaintenanceWindowRequest
}

func (r UpgradePolicyV2APIBatchRequest) Body(body BatchMaintenanceWindowRequest) UpgradePolicyV2APIBatchRequest {
	r.body = &body
	return r
}

func (r UpgradePolicyV2APIBatchRequest) Execute() (*BatchMaintenanceWindowResponse, *http.Response, error) {
	return r.ApiService.BatchExecute(r)
}

/*
Batch Create, update and/or delete multiple maintenance windows in a single request

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return UpgradePolicyV2APIBatchRequest
*/
func (a *UpgradePolicyV2APIService) Batch(ctx context.Context) UpgradePolicyV2APIBatchRequest {
	return UpgradePolicyV2APIBatchRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return BatchMaintenanceWindowResponse
func (a *UpgradePolicyV2APIService) BatchExecute(r UpgradePolicyV2APIBatchRequest) (*BatchMaintenanceWindowResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []internal.FormFile
		localVarReturnValue *BatchMaintenanceWindowResponse
	)

	localBasePath, err := a.Client.Cfg.ServerURLWithContext(r.ctx, "UpgradePolicyV2APIService.Batch")
	if err != nil {
		return localVarReturnValue, nil, internal.NewGenericOpenAPIError(err.Error())
	}

	localVarPath := localBasePath + "/v2/maintenance_windows/batch"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, internal.ReportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := internal.SelectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := internal.SelectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.Client.PrepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.Client.CallAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := internal.NewGenericOpenAPIErrorWithBody(localVarHTTPResponse.Status, localVarBody)
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.Client.Decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := internal.NewGenericOpenAPIErrorWithBody(err.Error(), localVarBody)
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	return localVarReturnValue, localVarHTTPResponse, nil
}

type UpgradePolicyV2APICreateRequest struct {
	ctx        context.Context
	ApiService UpgradePolicyV2API
	body       *CreateMaintenanceWindowRequest
}

func (r UpgradePolicyV2APICreateRequest) Body(body CreateMaintenanceWindowRequest) UpgradePolicyV2APICreateRequest {
	r.body = &body
	return r
}

func (r UpgradePolicyV2APICreateRequest) Execute() (*CreateMaintenanceWindowResponse, *http.Response, error) {
	return r.ApiService.CreateExecute(r)
}

/*
Create Create a maintenance window

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return UpgradePolicyV2APICreateRequest
*/
func (a *UpgradePolicyV2APIService) Create(ctx context.Context) UpgradePolicyV2APICreateRequest {
	return UpgradePolicyV2APICreateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return CreateMaintenanceWindowResponse
func (a *UpgradePolicyV2APIService) CreateExecute(r UpgradePolicyV2APICreateRequest) (*CreateMaintenanceWindowResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []internal.FormFile
		localVarReturnValue *CreateMaintenanceWindowResponse
	)

	localBasePath, err := a.Client.Cfg.ServerURLWithContext(r.ctx, "UpgradePolicyV2APIService.Create")
	if err != nil {
		return localVarReturnValue, nil, internal.NewGenericOpenAPIError(err.Error())
	}

	localVarPath := localBasePath + "/v2/maintenance_windows"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, internal.ReportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := internal.SelectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := internal.SelectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.Client.PrepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.Client.CallAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := internal.NewGenericOpenAPIErrorWithBody(localVarHTTPResponse.Status, localVarBody)
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.Client.Decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := internal.NewGenericOpenAPIErrorWithBody(err.Error(), localVarBody)
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	return localVarReturnValue, localVarHTTPResponse, nil
}

type UpgradePolicyV2APIDeleteRequest struct {
	ctx        context.Context
	ApiService UpgradePolicyV2API
	id         string
}

func (r UpgradePolicyV2APIDeleteRequest) Execute() (*DeleteMaintenanceWindowResponse, *http.Response, error) {
	return r.ApiService.DeleteExecute(r)
}

/*
Delete Delete maintenance window

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id uuid of a maintenance window record
	@return UpgradePolicyV2APIDeleteRequest
*/
func (a *UpgradePolicyV2APIService) Delete(ctx context.Context, id string) UpgradePolicyV2APIDeleteRequest {
	return UpgradePolicyV2APIDeleteRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return DeleteMaintenanceWindowResponse
func (a *UpgradePolicyV2APIService) DeleteExecute(r UpgradePolicyV2APIDeleteRequest) (*DeleteMaintenanceWindowResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []internal.FormFile
		localVarReturnValue *DeleteMaintenanceWindowResponse
	)

	localBasePath, err := a.Client.Cfg.ServerURLWithContext(r.ctx, "UpgradePolicyV2APIService.Delete")
	if err != nil {
		return localVarReturnValue, nil, internal.NewGenericOpenAPIError(err.Error())
	}

	localVarPath := localBasePath + "/v2/maintenance_windows/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(internal.ParameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := internal.SelectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := internal.SelectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.Client.PrepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.Client.CallAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := internal.NewGenericOpenAPIErrorWithBody(localVarHTTPResponse.Status, localVarBody)
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.Client.Decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := internal.NewGenericOpenAPIErrorWithBody(err.Error(), localVarBody)
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	return localVarReturnValue, localVarHTTPResponse, nil
}

type UpgradePolicyV2APIGetRequest struct {
	ctx        context.Context
	ApiService UpgradePolicyV2API
	id         string
}

func (r UpgradePolicyV2APIGetRequest) Execute() (*GetMaintenanceWindowResponse, *http.Response, error) {
	return r.ApiService.GetExecute(r)
}

/*
Get Read a maintenance window

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id uuid of a maintenance window record
	@return UpgradePolicyV2APIGetRequest
*/
func (a *UpgradePolicyV2APIService) Get(ctx context.Context, id string) UpgradePolicyV2APIGetRequest {
	return UpgradePolicyV2APIGetRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return GetMaintenanceWindowResponse
func (a *UpgradePolicyV2APIService) GetExecute(r UpgradePolicyV2APIGetRequest) (*GetMaintenanceWindowResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []internal.FormFile
		localVarReturnValue *GetMaintenanceWindowResponse
	)

	localBasePath, err := a.Client.Cfg.ServerURLWithContext(r.ctx, "UpgradePolicyV2APIService.Get")
	if err != nil {
		return localVarReturnValue, nil, internal.NewGenericOpenAPIError(err.Error())
	}

	localVarPath := localBasePath + "/v2/maintenance_windows/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(internal.ParameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := internal.SelectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := internal.SelectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.Client.PrepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.Client.CallAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := internal.NewGenericOpenAPIErrorWithBody(localVarHTTPResponse.Status, localVarBody)
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.Client.Decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := internal.NewGenericOpenAPIErrorWithBody(err.Error(), localVarBody)
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	return localVarReturnValue, localVarHTTPResponse, nil
}

type UpgradePolicyV2APIListRequest struct {
	ctx        context.Context
	ApiService UpgradePolicyV2API
	windowType *string
}

// window type (software or config).
func (r UpgradePolicyV2APIListRequest) WindowType(windowType string) UpgradePolicyV2APIListRequest {
	r.windowType = &windowType
	return r
}

func (r UpgradePolicyV2APIListRequest) Execute() (*ListMaintenanceWindowResponse, *http.Response, error) {
	return r.ApiService.ListExecute(r)
}

/*
List List all the maintenance windows

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return UpgradePolicyV2APIListRequest
*/
func (a *UpgradePolicyV2APIService) List(ctx context.Context) UpgradePolicyV2APIListRequest {
	return UpgradePolicyV2APIListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return ListMaintenanceWindowResponse
func (a *UpgradePolicyV2APIService) ListExecute(r UpgradePolicyV2APIListRequest) (*ListMaintenanceWindowResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []internal.FormFile
		localVarReturnValue *ListMaintenanceWindowResponse
	)

	localBasePath, err := a.Client.Cfg.ServerURLWithContext(r.ctx, "UpgradePolicyV2APIService.List")
	if err != nil {
		return localVarReturnValue, nil, internal.NewGenericOpenAPIError(err.Error())
	}

	localVarPath := localBasePath + "/v2/maintenance_windows"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.windowType != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "window_type", r.windowType, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := internal.SelectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := internal.SelectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.Client.PrepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.Client.CallAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := internal.NewGenericOpenAPIErrorWithBody(localVarHTTPResponse.Status, localVarBody)
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.Client.Decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := internal.NewGenericOpenAPIErrorWithBody(err.Error(), localVarBody)
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	return localVarReturnValue, localVarHTTPResponse, nil
}

type UpgradePolicyV2APIUpdateRequest struct {
	ctx        context.Context
	ApiService UpgradePolicyV2API
	id         string
	body       *UpdateMaintenanceWindowRequest
}

func (r UpgradePolicyV2APIUpdateRequest) Body(body UpdateMaintenanceWindowRequest) UpgradePolicyV2APIUpdateRequest {
	r.body = &body
	return r
}

func (r UpgradePolicyV2APIUpdateRequest) Execute() (*UpdateMaintenanceWindowResponse, *http.Response, error) {
	return r.ApiService.UpdateExecute(r)
}

/*
Update Update an existing maintenance window

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id uuid of a maintenance window record
	@return UpgradePolicyV2APIUpdateRequest
*/
func (a *UpgradePolicyV2APIService) Update(ctx context.Context, id string) UpgradePolicyV2APIUpdateRequest {
	return UpgradePolicyV2APIUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return UpdateMaintenanceWindowResponse
func (a *UpgradePolicyV2APIService) UpdateExecute(r UpgradePolicyV2APIUpdateRequest) (*UpdateMaintenanceWindowResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []internal.FormFile
		localVarReturnValue *UpdateMaintenanceWindowResponse
	)

	localBasePath, err := a.Client.Cfg.ServerURLWithContext(r.ctx, "UpgradePolicyV2APIService.Update")
	if err != nil {
		return localVarReturnValue, nil, internal.NewGenericOpenAPIError(err.Error())
	}

	localVarPath := localBasePath + "/v2/maintenance_windows/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(internal.ParameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, internal.ReportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := internal.SelectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := internal.SelectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.Client.PrepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.Client.CallAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := internal.NewGenericOpenAPIErrorWithBody(localVarHTTPResponse.Status, localVarBody)
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.Client.Decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := internal.NewGenericOpenAPIErrorWithBody(err.Error(), localVarBody)
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	return localVarReturnValue, localVarHTTPResponse, nil
}
