/*
IP Address Management API

The IPAM/DHCP Application is a BloxOne DDI service providing IP address management and DHCP protocol features. The IPAM component provides visibility into and provisioning tools to manage networking spaces, monitoring and reporting of entire IP address infrastructures, and integration with DNS and DHCP protocols. The DHCP component provides DHCP protocol configuration service with on-prem host serving DHCP protocol. It is part of the full-featured, DDI cloud solution that enables customers to deploy large numbers of protocol servers to deliver DNS and DHCP throughout their enterprise network.

API version: v1
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package ipam

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/infobloxopen/bloxone-go-client/internal"
)

type AddressBlockAPI interface {
	/*
			Copy Copy the address block.

			Use this method to copy an __AddressBlock__ object.
		The __AddressBlock__ object allows a uniform representation of the address space segmentation, supporting functions such as administrative grouping, routing aggregation, delegation etc.

			@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			@param id An application specific resource identity of a resource
			@return AddressBlockAPICopyRequest
	*/
	Copy(ctx context.Context, id string) AddressBlockAPICopyRequest

	// CopyExecute executes the request
	//  @return CopyAddressBlockResponse
	CopyExecute(r AddressBlockAPICopyRequest) (*CopyAddressBlockResponse, *http.Response, error)
	/*
			Create Create the address block.

			Use this method to create an __AddressBlock__ object.
		The __AddressBlock__ object allows a uniform representation of the address space segmentation, supporting functions such as administrative grouping, routing aggregation, delegation etc.

			@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			@return AddressBlockAPICreateRequest
	*/
	Create(ctx context.Context) AddressBlockAPICreateRequest

	// CreateExecute executes the request
	//  @return CreateAddressBlockResponse
	CreateExecute(r AddressBlockAPICreateRequest) (*CreateAddressBlockResponse, *http.Response, error)
	/*
			CreateNextAvailableAB Create the Next Available Address Block object.

			Use this method to create a Next Available __AddressBlock__ object.
		The Next Available Address Block is a generator that allocates one or more _ipam/address_block_ resource from available address blocks when the network address is not known prior to allocation.

			@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			@param id An application specific resource identity of a resource
			@return AddressBlockAPICreateNextAvailableABRequest
	*/
	CreateNextAvailableAB(ctx context.Context, id string) AddressBlockAPICreateNextAvailableABRequest

	// CreateNextAvailableABExecute executes the request
	//  @return CreateNextAvailableABResponse
	CreateNextAvailableABExecute(r AddressBlockAPICreateNextAvailableABRequest) (*CreateNextAvailableABResponse, *http.Response, error)
	/*
			CreateNextAvailableIP Allocate the next available IP address.

			Use this method to allocate the next available IP address.
		This allocates one or more __Address__ (_ipam/address_) resource from available addresses, when the IP address is not known prior to allocation.

			@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			@param id An application specific resource identity of a resource
			@return AddressBlockAPICreateNextAvailableIPRequest
	*/
	CreateNextAvailableIP(ctx context.Context, id string) AddressBlockAPICreateNextAvailableIPRequest

	// CreateNextAvailableIPExecute executes the request
	//  @return CreateNextAvailableIPResponse
	CreateNextAvailableIPExecute(r AddressBlockAPICreateNextAvailableIPRequest) (*CreateNextAvailableIPResponse, *http.Response, error)
	/*
			CreateNextAvailableSubnet Create the Next Available Subnet object.

			Use this method to create a Next Available __Subnet__ object.
		The Next Available Subnet is a generator that allocates one or more _ipam/subnet_ resource from available subnets when the network address is not known prior to allocation.

			@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			@param id An application specific resource identity of a resource
			@return AddressBlockAPICreateNextAvailableSubnetRequest
	*/
	CreateNextAvailableSubnet(ctx context.Context, id string) AddressBlockAPICreateNextAvailableSubnetRequest

	// CreateNextAvailableSubnetExecute executes the request
	//  @return CreateNextAvailableSubnetResponse
	CreateNextAvailableSubnetExecute(r AddressBlockAPICreateNextAvailableSubnetRequest) (*CreateNextAvailableSubnetResponse, *http.Response, error)
	/*
			Delete Move the address block to the recycle bin.

			Use this method to move an __AddressBlock__ object to the recycle bin.
		The __AddressBlock__ object allows a uniform representation of the address space segmentation, supporting functions such as administrative grouping, routing aggregation, delegation etc.

			@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			@param id An application specific resource identity of a resource
			@return AddressBlockAPIDeleteRequest
	*/
	Delete(ctx context.Context, id string) AddressBlockAPIDeleteRequest

	// DeleteExecute executes the request
	DeleteExecute(r AddressBlockAPIDeleteRequest) (*http.Response, error)
	/*
			List Retrieve the address blocks.

			Use this method to retrieve __AddressBlock__ objects.
		The __AddressBlock__ object allows a uniform representation of the address space segmentation, supporting functions such as administrative grouping, routing aggregation, delegation etc.

			@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			@return AddressBlockAPIListRequest
	*/
	List(ctx context.Context) AddressBlockAPIListRequest

	// ListExecute executes the request
	//  @return ListAddressBlockResponse
	ListExecute(r AddressBlockAPIListRequest) (*ListAddressBlockResponse, *http.Response, error)
	/*
			ListNextAvailableAB List Next Available Address Block objects.

			Use this method to list Next Available __AddressBlock__ objects.
		The Next Available __AddressBlock__ is a generator that returns one or more _ipam/address_block_ resource from available address blocks when the network address is not known prior to allocation.

			@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			@param id An application specific resource identity of a resource
			@return AddressBlockAPIListNextAvailableABRequest
	*/
	ListNextAvailableAB(ctx context.Context, id string) AddressBlockAPIListNextAvailableABRequest

	// ListNextAvailableABExecute executes the request
	//  @return NextAvailableABResponse
	ListNextAvailableABExecute(r AddressBlockAPIListNextAvailableABRequest) (*NextAvailableABResponse, *http.Response, error)
	/*
			ListNextAvailableIP Retrieve the next available IP address.

			Use this method to retrieve the next available IP address.
		This returns one or more __Address__ (_ipam/address_) resource from available addresses, when IP address is not known prior to allocation.

			@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			@param id An application specific resource identity of a resource
			@return AddressBlockAPIListNextAvailableIPRequest
	*/
	ListNextAvailableIP(ctx context.Context, id string) AddressBlockAPIListNextAvailableIPRequest

	// ListNextAvailableIPExecute executes the request
	//  @return NextAvailableIPResponse
	ListNextAvailableIPExecute(r AddressBlockAPIListNextAvailableIPRequest) (*NextAvailableIPResponse, *http.Response, error)
	/*
			ListNextAvailableSubnet List Next Available Subnet objects.

			Use this method to list Next Available __Subnet__ objects.
		The Next Available Address Block is a generator that returns one or more _ipam/subnet_ resource from available subnets when the network address is not known prior to allocation.

			@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			@param id An application specific resource identity of a resource
			@return AddressBlockAPIListNextAvailableSubnetRequest
	*/
	ListNextAvailableSubnet(ctx context.Context, id string) AddressBlockAPIListNextAvailableSubnetRequest

	// ListNextAvailableSubnetExecute executes the request
	//  @return NextAvailableSubnetResponse
	ListNextAvailableSubnetExecute(r AddressBlockAPIListNextAvailableSubnetRequest) (*NextAvailableSubnetResponse, *http.Response, error)
	/*
			Read Retrieve the address block.

			Use this method to retrieve an __AddressBlock__ object.
		The __AddressBlock__ object allows a uniform representation of the address space segmentation, supporting functions such as administrative grouping, routing aggregation, delegation etc.

			@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			@param id An application specific resource identity of a resource
			@return AddressBlockAPIReadRequest
	*/
	Read(ctx context.Context, id string) AddressBlockAPIReadRequest

	// ReadExecute executes the request
	//  @return ReadAddressBlockResponse
	ReadExecute(r AddressBlockAPIReadRequest) (*ReadAddressBlockResponse, *http.Response, error)
	/*
			Update Update the address block.

			Use this method to update an __AddressBlock__ object.
		The __AddressBlock__ object allows a uniform representation of the address space segmentation, supporting functions such as administrative grouping, routing aggregation, delegation etc.

			@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			@param id An application specific resource identity of a resource
			@return AddressBlockAPIUpdateRequest
	*/
	Update(ctx context.Context, id string) AddressBlockAPIUpdateRequest

	// UpdateExecute executes the request
	//  @return UpdateAddressBlockResponse
	UpdateExecute(r AddressBlockAPIUpdateRequest) (*UpdateAddressBlockResponse, *http.Response, error)
}

// AddressBlockAPIService AddressBlockAPI service
type AddressBlockAPIService internal.Service

type AddressBlockAPICopyRequest struct {
	ctx        context.Context
	ApiService AddressBlockAPI
	id         string
	body       *CopyAddressBlock
}

func (r AddressBlockAPICopyRequest) Body(body CopyAddressBlock) AddressBlockAPICopyRequest {
	r.body = &body
	return r
}

func (r AddressBlockAPICopyRequest) Execute() (*CopyAddressBlockResponse, *http.Response, error) {
	return r.ApiService.CopyExecute(r)
}

/*
Copy Copy the address block.

Use this method to copy an __AddressBlock__ object.
The __AddressBlock__ object allows a uniform representation of the address space segmentation, supporting functions such as administrative grouping, routing aggregation, delegation etc.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id An application specific resource identity of a resource
	@return AddressBlockAPICopyRequest
*/
func (a *AddressBlockAPIService) Copy(ctx context.Context, id string) AddressBlockAPICopyRequest {
	return AddressBlockAPICopyRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return CopyAddressBlockResponse
func (a *AddressBlockAPIService) CopyExecute(r AddressBlockAPICopyRequest) (*CopyAddressBlockResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []internal.FormFile
		localVarReturnValue *CopyAddressBlockResponse
	)

	localBasePath, err := a.Client.Cfg.ServerURLWithContext(r.ctx, "AddressBlockAPIService.Copy")
	if err != nil {
		return localVarReturnValue, nil, internal.NewGenericOpenAPIError(err.Error())
	}

	localVarPath := localBasePath + "/ipam/address_block/{id}/copy"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(internal.ParameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, internal.ReportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := internal.SelectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := internal.SelectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.Client.PrepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.Client.CallAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := internal.NewGenericOpenAPIErrorWithBody(localVarHTTPResponse.Status, localVarBody)
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.Client.Decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := internal.NewGenericOpenAPIErrorWithBody(err.Error(), localVarBody)
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	return localVarReturnValue, localVarHTTPResponse, nil
}

type AddressBlockAPICreateRequest struct {
	ctx        context.Context
	ApiService AddressBlockAPI
	body       *AddressBlock
	inherit    *string
}

func (r AddressBlockAPICreateRequest) Body(body AddressBlock) AddressBlockAPICreateRequest {
	r.body = &body
	return r
}

// This parameter is used for getting inheritance_sources.  Allowed values: * _none_, * _partial_, * _full_.  Defaults to _none
func (r AddressBlockAPICreateRequest) Inherit(inherit string) AddressBlockAPICreateRequest {
	r.inherit = &inherit
	return r
}

func (r AddressBlockAPICreateRequest) Execute() (*CreateAddressBlockResponse, *http.Response, error) {
	return r.ApiService.CreateExecute(r)
}

/*
Create Create the address block.

Use this method to create an __AddressBlock__ object.
The __AddressBlock__ object allows a uniform representation of the address space segmentation, supporting functions such as administrative grouping, routing aggregation, delegation etc.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return AddressBlockAPICreateRequest
*/
func (a *AddressBlockAPIService) Create(ctx context.Context) AddressBlockAPICreateRequest {
	return AddressBlockAPICreateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return CreateAddressBlockResponse
func (a *AddressBlockAPIService) CreateExecute(r AddressBlockAPICreateRequest) (*CreateAddressBlockResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []internal.FormFile
		localVarReturnValue *CreateAddressBlockResponse
	)

	localBasePath, err := a.Client.Cfg.ServerURLWithContext(r.ctx, "AddressBlockAPIService.Create")
	if err != nil {
		return localVarReturnValue, nil, internal.NewGenericOpenAPIError(err.Error())
	}

	localVarPath := localBasePath + "/ipam/address_block"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, internal.ReportError("body is required and must be specified")
	}

	if r.inherit != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "_inherit", r.inherit, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := internal.SelectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := internal.SelectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if len(a.Client.Cfg.DefaultTags) > 0 && r.body != nil {
		if r.body.Tags == nil {
			r.body.Tags = make(map[string]interface{})
		}
		for k, v := range a.Client.Cfg.DefaultTags {
			if _, ok := r.body.Tags[k]; !ok {
				r.body.Tags[k] = v
			}
		}
	}
	// body params
	localVarPostBody = r.body
	req, err := a.Client.PrepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.Client.CallAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := internal.NewGenericOpenAPIErrorWithBody(localVarHTTPResponse.Status, localVarBody)
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.Client.Decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := internal.NewGenericOpenAPIErrorWithBody(err.Error(), localVarBody)
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	return localVarReturnValue, localVarHTTPResponse, nil
}

type AddressBlockAPICreateNextAvailableABRequest struct {
	ctx        context.Context
	ApiService AddressBlockAPI
	id         string
	cidr       *int32
	count      *int32
	name       *string
	comment    *string
}

// The cidr value of address blocks to be created.
func (r AddressBlockAPICreateNextAvailableABRequest) Cidr(cidr int32) AddressBlockAPICreateNextAvailableABRequest {
	r.cidr = &cidr
	return r
}

// Number of address blocks to generate. Default 1 if not set.
func (r AddressBlockAPICreateNextAvailableABRequest) Count(count int32) AddressBlockAPICreateNextAvailableABRequest {
	r.count = &count
	return r
}

// Name of next available address blocks.
func (r AddressBlockAPICreateNextAvailableABRequest) Name(name string) AddressBlockAPICreateNextAvailableABRequest {
	r.name = &name
	return r
}

// Comment of next available address blocks.
func (r AddressBlockAPICreateNextAvailableABRequest) Comment(comment string) AddressBlockAPICreateNextAvailableABRequest {
	r.comment = &comment
	return r
}

func (r AddressBlockAPICreateNextAvailableABRequest) Execute() (*CreateNextAvailableABResponse, *http.Response, error) {
	return r.ApiService.CreateNextAvailableABExecute(r)
}

/*
CreateNextAvailableAB Create the Next Available Address Block object.

Use this method to create a Next Available __AddressBlock__ object.
The Next Available Address Block is a generator that allocates one or more _ipam/address_block_ resource from available address blocks when the network address is not known prior to allocation.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id An application specific resource identity of a resource
	@return AddressBlockAPICreateNextAvailableABRequest
*/
func (a *AddressBlockAPIService) CreateNextAvailableAB(ctx context.Context, id string) AddressBlockAPICreateNextAvailableABRequest {
	return AddressBlockAPICreateNextAvailableABRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return CreateNextAvailableABResponse
func (a *AddressBlockAPIService) CreateNextAvailableABExecute(r AddressBlockAPICreateNextAvailableABRequest) (*CreateNextAvailableABResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []internal.FormFile
		localVarReturnValue *CreateNextAvailableABResponse
	)

	localBasePath, err := a.Client.Cfg.ServerURLWithContext(r.ctx, "AddressBlockAPIService.CreateNextAvailableAB")
	if err != nil {
		return localVarReturnValue, nil, internal.NewGenericOpenAPIError(err.Error())
	}

	localVarPath := localBasePath + "/ipam/address_block/{id}/nextavailableaddressblock"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(internal.ParameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.cidr == nil {
		return localVarReturnValue, nil, internal.ReportError("cidr is required and must be specified")
	}

	internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "cidr", r.cidr, "")
	if r.count != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	} else {
		var defaultValue int32 = 1
		r.count = &defaultValue
	}
	if r.name != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "")
	}
	if r.comment != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "comment", r.comment, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := internal.SelectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := internal.SelectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.Client.PrepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.Client.CallAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := internal.NewGenericOpenAPIErrorWithBody(localVarHTTPResponse.Status, localVarBody)
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.Client.Decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := internal.NewGenericOpenAPIErrorWithBody(err.Error(), localVarBody)
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	return localVarReturnValue, localVarHTTPResponse, nil
}

type AddressBlockAPICreateNextAvailableIPRequest struct {
	ctx        context.Context
	ApiService AddressBlockAPI
	id         string
	contiguous *bool
	count      *int32
}

// Indicates whether the IP addresses should belong to a contiguous block.  Defaults to _false_.
func (r AddressBlockAPICreateNextAvailableIPRequest) Contiguous(contiguous bool) AddressBlockAPICreateNextAvailableIPRequest {
	r.contiguous = &contiguous
	return r
}

// The number of IP addresses requested.  Defaults to 1.
func (r AddressBlockAPICreateNextAvailableIPRequest) Count(count int32) AddressBlockAPICreateNextAvailableIPRequest {
	r.count = &count
	return r
}

func (r AddressBlockAPICreateNextAvailableIPRequest) Execute() (*CreateNextAvailableIPResponse, *http.Response, error) {
	return r.ApiService.CreateNextAvailableIPExecute(r)
}

/*
CreateNextAvailableIP Allocate the next available IP address.

Use this method to allocate the next available IP address.
This allocates one or more __Address__ (_ipam/address_) resource from available addresses, when the IP address is not known prior to allocation.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id An application specific resource identity of a resource
	@return AddressBlockAPICreateNextAvailableIPRequest
*/
func (a *AddressBlockAPIService) CreateNextAvailableIP(ctx context.Context, id string) AddressBlockAPICreateNextAvailableIPRequest {
	return AddressBlockAPICreateNextAvailableIPRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return CreateNextAvailableIPResponse
func (a *AddressBlockAPIService) CreateNextAvailableIPExecute(r AddressBlockAPICreateNextAvailableIPRequest) (*CreateNextAvailableIPResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []internal.FormFile
		localVarReturnValue *CreateNextAvailableIPResponse
	)

	localBasePath, err := a.Client.Cfg.ServerURLWithContext(r.ctx, "AddressBlockAPIService.CreateNextAvailableIP")
	if err != nil {
		return localVarReturnValue, nil, internal.NewGenericOpenAPIError(err.Error())
	}

	localVarPath := localBasePath + "/ipam/address_block/{id}/nextavailableip"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(internal.ParameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.contiguous != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "contiguous", r.contiguous, "")
	} else {
		var defaultValue bool = false
		r.contiguous = &defaultValue
	}
	if r.count != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	} else {
		var defaultValue int32 = 1
		r.count = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := internal.SelectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := internal.SelectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.Client.PrepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.Client.CallAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := internal.NewGenericOpenAPIErrorWithBody(localVarHTTPResponse.Status, localVarBody)
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.Client.Decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := internal.NewGenericOpenAPIErrorWithBody(err.Error(), localVarBody)
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	return localVarReturnValue, localVarHTTPResponse, nil
}

type AddressBlockAPICreateNextAvailableSubnetRequest struct {
	ctx        context.Context
	ApiService AddressBlockAPI
	id         string
	cidr       *int32
	count      *int32
	name       *string
	comment    *string
	dhcpHost   *string
}

// The cidr value of subnets to be created.
func (r AddressBlockAPICreateNextAvailableSubnetRequest) Cidr(cidr int32) AddressBlockAPICreateNextAvailableSubnetRequest {
	r.cidr = &cidr
	return r
}

// Number of subnets to generate. Default 1 if not set.
func (r AddressBlockAPICreateNextAvailableSubnetRequest) Count(count int32) AddressBlockAPICreateNextAvailableSubnetRequest {
	r.count = &count
	return r
}

// Name of next available subnets.
func (r AddressBlockAPICreateNextAvailableSubnetRequest) Name(name string) AddressBlockAPICreateNextAvailableSubnetRequest {
	r.name = &name
	return r
}

// Comment of next available subnets.
func (r AddressBlockAPICreateNextAvailableSubnetRequest) Comment(comment string) AddressBlockAPICreateNextAvailableSubnetRequest {
	r.comment = &comment
	return r
}

// Reference of OnPrem Host associated with the next available subnets to be created.
func (r AddressBlockAPICreateNextAvailableSubnetRequest) DhcpHost(dhcpHost string) AddressBlockAPICreateNextAvailableSubnetRequest {
	r.dhcpHost = &dhcpHost
	return r
}

func (r AddressBlockAPICreateNextAvailableSubnetRequest) Execute() (*CreateNextAvailableSubnetResponse, *http.Response, error) {
	return r.ApiService.CreateNextAvailableSubnetExecute(r)
}

/*
CreateNextAvailableSubnet Create the Next Available Subnet object.

Use this method to create a Next Available __Subnet__ object.
The Next Available Subnet is a generator that allocates one or more _ipam/subnet_ resource from available subnets when the network address is not known prior to allocation.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id An application specific resource identity of a resource
	@return AddressBlockAPICreateNextAvailableSubnetRequest
*/
func (a *AddressBlockAPIService) CreateNextAvailableSubnet(ctx context.Context, id string) AddressBlockAPICreateNextAvailableSubnetRequest {
	return AddressBlockAPICreateNextAvailableSubnetRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return CreateNextAvailableSubnetResponse
func (a *AddressBlockAPIService) CreateNextAvailableSubnetExecute(r AddressBlockAPICreateNextAvailableSubnetRequest) (*CreateNextAvailableSubnetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []internal.FormFile
		localVarReturnValue *CreateNextAvailableSubnetResponse
	)

	localBasePath, err := a.Client.Cfg.ServerURLWithContext(r.ctx, "AddressBlockAPIService.CreateNextAvailableSubnet")
	if err != nil {
		return localVarReturnValue, nil, internal.NewGenericOpenAPIError(err.Error())
	}

	localVarPath := localBasePath + "/ipam/address_block/{id}/nextavailablesubnet"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(internal.ParameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.cidr == nil {
		return localVarReturnValue, nil, internal.ReportError("cidr is required and must be specified")
	}

	internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "cidr", r.cidr, "")
	if r.count != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	} else {
		var defaultValue int32 = 1
		r.count = &defaultValue
	}
	if r.name != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "")
	}
	if r.comment != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "comment", r.comment, "")
	}
	if r.dhcpHost != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "dhcp_host", r.dhcpHost, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := internal.SelectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := internal.SelectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.Client.PrepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.Client.CallAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := internal.NewGenericOpenAPIErrorWithBody(localVarHTTPResponse.Status, localVarBody)
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.Client.Decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := internal.NewGenericOpenAPIErrorWithBody(err.Error(), localVarBody)
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	return localVarReturnValue, localVarHTTPResponse, nil
}

type AddressBlockAPIDeleteRequest struct {
	ctx        context.Context
	ApiService AddressBlockAPI
	id         string
}

func (r AddressBlockAPIDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteExecute(r)
}

/*
Delete Move the address block to the recycle bin.

Use this method to move an __AddressBlock__ object to the recycle bin.
The __AddressBlock__ object allows a uniform representation of the address space segmentation, supporting functions such as administrative grouping, routing aggregation, delegation etc.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id An application specific resource identity of a resource
	@return AddressBlockAPIDeleteRequest
*/
func (a *AddressBlockAPIService) Delete(ctx context.Context, id string) AddressBlockAPIDeleteRequest {
	return AddressBlockAPIDeleteRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
func (a *AddressBlockAPIService) DeleteExecute(r AddressBlockAPIDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []internal.FormFile
	)

	localBasePath, err := a.Client.Cfg.ServerURLWithContext(r.ctx, "AddressBlockAPIService.Delete")
	if err != nil {
		return nil, internal.NewGenericOpenAPIError(err.Error())
	}

	localVarPath := localBasePath + "/ipam/address_block/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(internal.ParameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := internal.SelectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := internal.SelectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.Client.PrepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.Client.CallAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := internal.NewGenericOpenAPIErrorWithBody(localVarHTTPResponse.Status, localVarBody)
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type AddressBlockAPIListRequest struct {
	ctx        context.Context
	ApiService AddressBlockAPI
	fields     *string
	filter     *string
	offset     *int32
	limit      *int32
	pageToken  *string
	orderBy    *string
	torderBy   *string
	tfilter    *string
	inherit    *string
}

// A collection of response resources can be transformed by specifying a set of JSON tags to be returned. For a “flat” resource, the tag name is straightforward. If field selection is allowed on non-flat hierarchical resources, the service should implement a qualified naming scheme such as dot-qualification to reference data down the hierarchy. If a resource does not have the specified tag, the tag does not appear in the output resource.  Specify this parameter as a comma-separated list of JSON tag names.
func (r AddressBlockAPIListRequest) Fields(fields string) AddressBlockAPIListRequest {
	r.fields = &fields
	return r
}

// A collection of response resources can be filtered by a logical expression string that includes JSON tag references to values in each resource, literal values, and logical operators. If a resource does not have the specified tag, its value is assumed to be null.  Literal values include numbers (integer and floating-point), and quoted (both single- or double-quoted) literal strings, and &#39;null&#39;. The following operators are commonly used in filter expressions:  |  Op   |  Description               |  |  --   |  -----------               |  |  &#x3D;&#x3D;   |  Equal                     |  |  !&#x3D;   |  Not Equal                 |  |  &gt;    |  Greater Than              |  |   &gt;&#x3D;  |  Greater Than or Equal To  |  |  &lt;    |  Less Than                 |  |  &lt;&#x3D;   |  Less Than or Equal To     |  |  and  |  Logical AND               |  |  ~    |  Matches Regex             |  |  !~   |  Does Not Match Regex      |  |  or   |  Logical OR                |  |  not  |  Logical NOT               |  |  ()   |  Groupping Operators       |
func (r AddressBlockAPIListRequest) Filter(filter string) AddressBlockAPIListRequest {
	r.filter = &filter
	return r
}

// The integer index (zero-origin) of the offset into a collection of resources. If omitted or null the value is assumed to be &#39;0&#39;.
func (r AddressBlockAPIListRequest) Offset(offset int32) AddressBlockAPIListRequest {
	r.offset = &offset
	return r
}

// The integer number of resources to be returned in the response. The service may impose maximum value. If omitted the service may impose a default value.
func (r AddressBlockAPIListRequest) Limit(limit int32) AddressBlockAPIListRequest {
	r.limit = &limit
	return r
}

// The service-defined string used to identify a page of resources. A null value indicates the first page.
func (r AddressBlockAPIListRequest) PageToken(pageToken string) AddressBlockAPIListRequest {
	r.pageToken = &pageToken
	return r
}

// A collection of response resources can be sorted by their JSON tags. For a &#39;flat&#39; resource, the tag name is straightforward. If sorting is allowed on non-flat hierarchical resources, the service should implement a qualified naming scheme such as dot-qualification to reference data down the hierarchy. If a resource does not have the specified tag, its value is assumed to be null.)  Specify this parameter as a comma-separated list of JSON tag names. The sort direction can be specified by a suffix separated by whitespace before the tag name. The suffix &#39;asc&#39; sorts the data in ascending order. The suffix &#39;desc&#39; sorts the data in descending order. If no suffix is specified the data is sorted in ascending order.
func (r AddressBlockAPIListRequest) OrderBy(orderBy string) AddressBlockAPIListRequest {
	r.orderBy = &orderBy
	return r
}

// This parameter is used for sorting by tags.
func (r AddressBlockAPIListRequest) TorderBy(torderBy string) AddressBlockAPIListRequest {
	r.torderBy = &torderBy
	return r
}

// This parameter is used for filtering by tags.
func (r AddressBlockAPIListRequest) Tfilter(tfilter string) AddressBlockAPIListRequest {
	r.tfilter = &tfilter
	return r
}

// This parameter is used for getting inheritance_sources.  Allowed values: * _none_, * _partial_, * _full_.  Defaults to _none
func (r AddressBlockAPIListRequest) Inherit(inherit string) AddressBlockAPIListRequest {
	r.inherit = &inherit
	return r
}

func (r AddressBlockAPIListRequest) Execute() (*ListAddressBlockResponse, *http.Response, error) {
	return r.ApiService.ListExecute(r)
}

/*
List Retrieve the address blocks.

Use this method to retrieve __AddressBlock__ objects.
The __AddressBlock__ object allows a uniform representation of the address space segmentation, supporting functions such as administrative grouping, routing aggregation, delegation etc.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return AddressBlockAPIListRequest
*/
func (a *AddressBlockAPIService) List(ctx context.Context) AddressBlockAPIListRequest {
	return AddressBlockAPIListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return ListAddressBlockResponse
func (a *AddressBlockAPIService) ListExecute(r AddressBlockAPIListRequest) (*ListAddressBlockResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []internal.FormFile
		localVarReturnValue *ListAddressBlockResponse
	)

	localBasePath, err := a.Client.Cfg.ServerURLWithContext(r.ctx, "AddressBlockAPIService.List")
	if err != nil {
		return localVarReturnValue, nil, internal.NewGenericOpenAPIError(err.Error())
	}

	localVarPath := localBasePath + "/ipam/address_block"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "_fields", r.fields, "")
	}
	if r.filter != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "_filter", r.filter, "")
	}
	if r.offset != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "_offset", r.offset, "")
	}
	if r.limit != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "_limit", r.limit, "")
	}
	if r.pageToken != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "_page_token", r.pageToken, "")
	}
	if r.orderBy != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "_order_by", r.orderBy, "")
	}
	if r.torderBy != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "_torder_by", r.torderBy, "")
	}
	if r.tfilter != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "_tfilter", r.tfilter, "")
	}
	if r.inherit != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "_inherit", r.inherit, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := internal.SelectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := internal.SelectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.Client.PrepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.Client.CallAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := internal.NewGenericOpenAPIErrorWithBody(localVarHTTPResponse.Status, localVarBody)
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.Client.Decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := internal.NewGenericOpenAPIErrorWithBody(err.Error(), localVarBody)
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	return localVarReturnValue, localVarHTTPResponse, nil
}

type AddressBlockAPIListNextAvailableABRequest struct {
	ctx        context.Context
	ApiService AddressBlockAPI
	id         string
	cidr       *int32
	count      *int32
	name       *string
	comment    *string
}

// The cidr value of address blocks to be created.
func (r AddressBlockAPIListNextAvailableABRequest) Cidr(cidr int32) AddressBlockAPIListNextAvailableABRequest {
	r.cidr = &cidr
	return r
}

// Number of address blocks to generate. Default 1 if not set.
func (r AddressBlockAPIListNextAvailableABRequest) Count(count int32) AddressBlockAPIListNextAvailableABRequest {
	r.count = &count
	return r
}

// Name of next available address blocks.
func (r AddressBlockAPIListNextAvailableABRequest) Name(name string) AddressBlockAPIListNextAvailableABRequest {
	r.name = &name
	return r
}

// Comment of next available address blocks.
func (r AddressBlockAPIListNextAvailableABRequest) Comment(comment string) AddressBlockAPIListNextAvailableABRequest {
	r.comment = &comment
	return r
}

func (r AddressBlockAPIListNextAvailableABRequest) Execute() (*NextAvailableABResponse, *http.Response, error) {
	return r.ApiService.ListNextAvailableABExecute(r)
}

/*
ListNextAvailableAB List Next Available Address Block objects.

Use this method to list Next Available __AddressBlock__ objects.
The Next Available __AddressBlock__ is a generator that returns one or more _ipam/address_block_ resource from available address blocks when the network address is not known prior to allocation.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id An application specific resource identity of a resource
	@return AddressBlockAPIListNextAvailableABRequest
*/
func (a *AddressBlockAPIService) ListNextAvailableAB(ctx context.Context, id string) AddressBlockAPIListNextAvailableABRequest {
	return AddressBlockAPIListNextAvailableABRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return NextAvailableABResponse
func (a *AddressBlockAPIService) ListNextAvailableABExecute(r AddressBlockAPIListNextAvailableABRequest) (*NextAvailableABResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []internal.FormFile
		localVarReturnValue *NextAvailableABResponse
	)

	localBasePath, err := a.Client.Cfg.ServerURLWithContext(r.ctx, "AddressBlockAPIService.ListNextAvailableAB")
	if err != nil {
		return localVarReturnValue, nil, internal.NewGenericOpenAPIError(err.Error())
	}

	localVarPath := localBasePath + "/ipam/address_block/{id}/nextavailableaddressblock"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(internal.ParameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.cidr != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "cidr", r.cidr, "")
	}
	if r.count != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	}
	if r.name != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "")
	}
	if r.comment != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "comment", r.comment, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := internal.SelectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := internal.SelectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.Client.PrepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.Client.CallAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := internal.NewGenericOpenAPIErrorWithBody(localVarHTTPResponse.Status, localVarBody)
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.Client.Decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := internal.NewGenericOpenAPIErrorWithBody(err.Error(), localVarBody)
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	return localVarReturnValue, localVarHTTPResponse, nil
}

type AddressBlockAPIListNextAvailableIPRequest struct {
	ctx        context.Context
	ApiService AddressBlockAPI
	id         string
	contiguous *bool
	count      *int32
}

// Indicates whether the IP addresses should belong to a contiguous block.  Defaults to _false_.
func (r AddressBlockAPIListNextAvailableIPRequest) Contiguous(contiguous bool) AddressBlockAPIListNextAvailableIPRequest {
	r.contiguous = &contiguous
	return r
}

// The number of IP addresses requested.  Defaults to 1.
func (r AddressBlockAPIListNextAvailableIPRequest) Count(count int32) AddressBlockAPIListNextAvailableIPRequest {
	r.count = &count
	return r
}

func (r AddressBlockAPIListNextAvailableIPRequest) Execute() (*NextAvailableIPResponse, *http.Response, error) {
	return r.ApiService.ListNextAvailableIPExecute(r)
}

/*
ListNextAvailableIP Retrieve the next available IP address.

Use this method to retrieve the next available IP address.
This returns one or more __Address__ (_ipam/address_) resource from available addresses, when IP address is not known prior to allocation.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id An application specific resource identity of a resource
	@return AddressBlockAPIListNextAvailableIPRequest
*/
func (a *AddressBlockAPIService) ListNextAvailableIP(ctx context.Context, id string) AddressBlockAPIListNextAvailableIPRequest {
	return AddressBlockAPIListNextAvailableIPRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return NextAvailableIPResponse
func (a *AddressBlockAPIService) ListNextAvailableIPExecute(r AddressBlockAPIListNextAvailableIPRequest) (*NextAvailableIPResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []internal.FormFile
		localVarReturnValue *NextAvailableIPResponse
	)

	localBasePath, err := a.Client.Cfg.ServerURLWithContext(r.ctx, "AddressBlockAPIService.ListNextAvailableIP")
	if err != nil {
		return localVarReturnValue, nil, internal.NewGenericOpenAPIError(err.Error())
	}

	localVarPath := localBasePath + "/ipam/address_block/{id}/nextavailableip"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(internal.ParameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.contiguous != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "contiguous", r.contiguous, "")
	}
	if r.count != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := internal.SelectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := internal.SelectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.Client.PrepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.Client.CallAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := internal.NewGenericOpenAPIErrorWithBody(localVarHTTPResponse.Status, localVarBody)
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.Client.Decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := internal.NewGenericOpenAPIErrorWithBody(err.Error(), localVarBody)
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	return localVarReturnValue, localVarHTTPResponse, nil
}

type AddressBlockAPIListNextAvailableSubnetRequest struct {
	ctx        context.Context
	ApiService AddressBlockAPI
	id         string
	cidr       *int32
	count      *int32
	name       *string
	comment    *string
	dhcpHost   *string
}

// The cidr value of subnets to be created.
func (r AddressBlockAPIListNextAvailableSubnetRequest) Cidr(cidr int32) AddressBlockAPIListNextAvailableSubnetRequest {
	r.cidr = &cidr
	return r
}

// Number of subnets to generate. Default 1 if not set.
func (r AddressBlockAPIListNextAvailableSubnetRequest) Count(count int32) AddressBlockAPIListNextAvailableSubnetRequest {
	r.count = &count
	return r
}

// Name of next available subnets.
func (r AddressBlockAPIListNextAvailableSubnetRequest) Name(name string) AddressBlockAPIListNextAvailableSubnetRequest {
	r.name = &name
	return r
}

// Comment of next available subnets.
func (r AddressBlockAPIListNextAvailableSubnetRequest) Comment(comment string) AddressBlockAPIListNextAvailableSubnetRequest {
	r.comment = &comment
	return r
}

// Reference of OnPrem Host associated with the next available subnets to be created.
func (r AddressBlockAPIListNextAvailableSubnetRequest) DhcpHost(dhcpHost string) AddressBlockAPIListNextAvailableSubnetRequest {
	r.dhcpHost = &dhcpHost
	return r
}

func (r AddressBlockAPIListNextAvailableSubnetRequest) Execute() (*NextAvailableSubnetResponse, *http.Response, error) {
	return r.ApiService.ListNextAvailableSubnetExecute(r)
}

/*
ListNextAvailableSubnet List Next Available Subnet objects.

Use this method to list Next Available __Subnet__ objects.
The Next Available Address Block is a generator that returns one or more _ipam/subnet_ resource from available subnets when the network address is not known prior to allocation.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id An application specific resource identity of a resource
	@return AddressBlockAPIListNextAvailableSubnetRequest
*/
func (a *AddressBlockAPIService) ListNextAvailableSubnet(ctx context.Context, id string) AddressBlockAPIListNextAvailableSubnetRequest {
	return AddressBlockAPIListNextAvailableSubnetRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return NextAvailableSubnetResponse
func (a *AddressBlockAPIService) ListNextAvailableSubnetExecute(r AddressBlockAPIListNextAvailableSubnetRequest) (*NextAvailableSubnetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []internal.FormFile
		localVarReturnValue *NextAvailableSubnetResponse
	)

	localBasePath, err := a.Client.Cfg.ServerURLWithContext(r.ctx, "AddressBlockAPIService.ListNextAvailableSubnet")
	if err != nil {
		return localVarReturnValue, nil, internal.NewGenericOpenAPIError(err.Error())
	}

	localVarPath := localBasePath + "/ipam/address_block/{id}/nextavailablesubnet"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(internal.ParameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.cidr != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "cidr", r.cidr, "")
	}
	if r.count != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	}
	if r.name != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "")
	}
	if r.comment != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "comment", r.comment, "")
	}
	if r.dhcpHost != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "dhcp_host", r.dhcpHost, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := internal.SelectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := internal.SelectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.Client.PrepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.Client.CallAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := internal.NewGenericOpenAPIErrorWithBody(localVarHTTPResponse.Status, localVarBody)
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.Client.Decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := internal.NewGenericOpenAPIErrorWithBody(err.Error(), localVarBody)
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	return localVarReturnValue, localVarHTTPResponse, nil
}

type AddressBlockAPIReadRequest struct {
	ctx        context.Context
	ApiService AddressBlockAPI
	id         string
	fields     *string
	inherit    *string
}

// A collection of response resources can be transformed by specifying a set of JSON tags to be returned. For a “flat” resource, the tag name is straightforward. If field selection is allowed on non-flat hierarchical resources, the service should implement a qualified naming scheme such as dot-qualification to reference data down the hierarchy. If a resource does not have the specified tag, the tag does not appear in the output resource.  Specify this parameter as a comma-separated list of JSON tag names.
func (r AddressBlockAPIReadRequest) Fields(fields string) AddressBlockAPIReadRequest {
	r.fields = &fields
	return r
}

// This parameter is used for getting inheritance_sources.  Allowed values: * _none_, * _partial_, * _full_.  Defaults to _none
func (r AddressBlockAPIReadRequest) Inherit(inherit string) AddressBlockAPIReadRequest {
	r.inherit = &inherit
	return r
}

func (r AddressBlockAPIReadRequest) Execute() (*ReadAddressBlockResponse, *http.Response, error) {
	return r.ApiService.ReadExecute(r)
}

/*
Read Retrieve the address block.

Use this method to retrieve an __AddressBlock__ object.
The __AddressBlock__ object allows a uniform representation of the address space segmentation, supporting functions such as administrative grouping, routing aggregation, delegation etc.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id An application specific resource identity of a resource
	@return AddressBlockAPIReadRequest
*/
func (a *AddressBlockAPIService) Read(ctx context.Context, id string) AddressBlockAPIReadRequest {
	return AddressBlockAPIReadRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return ReadAddressBlockResponse
func (a *AddressBlockAPIService) ReadExecute(r AddressBlockAPIReadRequest) (*ReadAddressBlockResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []internal.FormFile
		localVarReturnValue *ReadAddressBlockResponse
	)

	localBasePath, err := a.Client.Cfg.ServerURLWithContext(r.ctx, "AddressBlockAPIService.Read")
	if err != nil {
		return localVarReturnValue, nil, internal.NewGenericOpenAPIError(err.Error())
	}

	localVarPath := localBasePath + "/ipam/address_block/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(internal.ParameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "_fields", r.fields, "")
	}
	if r.inherit != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "_inherit", r.inherit, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := internal.SelectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := internal.SelectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.Client.PrepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.Client.CallAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := internal.NewGenericOpenAPIErrorWithBody(localVarHTTPResponse.Status, localVarBody)
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.Client.Decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := internal.NewGenericOpenAPIErrorWithBody(err.Error(), localVarBody)
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	return localVarReturnValue, localVarHTTPResponse, nil
}

type AddressBlockAPIUpdateRequest struct {
	ctx        context.Context
	ApiService AddressBlockAPI
	id         string
	body       *AddressBlock
	inherit    *string
}

func (r AddressBlockAPIUpdateRequest) Body(body AddressBlock) AddressBlockAPIUpdateRequest {
	r.body = &body
	return r
}

// This parameter is used for getting inheritance_sources.  Allowed values: * _none_, * _partial_, * _full_.  Defaults to _none
func (r AddressBlockAPIUpdateRequest) Inherit(inherit string) AddressBlockAPIUpdateRequest {
	r.inherit = &inherit
	return r
}

func (r AddressBlockAPIUpdateRequest) Execute() (*UpdateAddressBlockResponse, *http.Response, error) {
	return r.ApiService.UpdateExecute(r)
}

/*
Update Update the address block.

Use this method to update an __AddressBlock__ object.
The __AddressBlock__ object allows a uniform representation of the address space segmentation, supporting functions such as administrative grouping, routing aggregation, delegation etc.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id An application specific resource identity of a resource
	@return AddressBlockAPIUpdateRequest
*/
func (a *AddressBlockAPIService) Update(ctx context.Context, id string) AddressBlockAPIUpdateRequest {
	return AddressBlockAPIUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return UpdateAddressBlockResponse
func (a *AddressBlockAPIService) UpdateExecute(r AddressBlockAPIUpdateRequest) (*UpdateAddressBlockResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []internal.FormFile
		localVarReturnValue *UpdateAddressBlockResponse
	)

	localBasePath, err := a.Client.Cfg.ServerURLWithContext(r.ctx, "AddressBlockAPIService.Update")
	if err != nil {
		return localVarReturnValue, nil, internal.NewGenericOpenAPIError(err.Error())
	}

	localVarPath := localBasePath + "/ipam/address_block/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(internal.ParameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, internal.ReportError("body is required and must be specified")
	}

	if r.inherit != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "_inherit", r.inherit, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := internal.SelectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := internal.SelectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if len(a.Client.Cfg.DefaultTags) > 0 && r.body != nil {
		if r.body.Tags == nil {
			r.body.Tags = make(map[string]interface{})
		}
		for k, v := range a.Client.Cfg.DefaultTags {
			if _, ok := r.body.Tags[k]; !ok {
				r.body.Tags[k] = v
			}
		}
	}
	// body params
	localVarPostBody = r.body
	req, err := a.Client.PrepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.Client.CallAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := internal.NewGenericOpenAPIErrorWithBody(localVarHTTPResponse.Status, localVarBody)
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.Client.Decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := internal.NewGenericOpenAPIErrorWithBody(err.Error(), localVarBody)
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	return localVarReturnValue, localVarHTTPResponse, nil
}
